<map version="1.0.1"><node CREATED="1638264284746" ID="ID_root" MODIFIED="1638264284746" TEXT="数据结构与算法"><node CREATED="1638264284746" ID="ID_e520c01f9a71" POSITION="right" MODIFIED="1638264284746" TEXT="1. 基本概念"><node CREATED="1638264284746" ID="ID_428c95d5cace" MODIFIED="1638264284746" TEXT="1. 数据结构"><node CREATED="1638264284746" ID="ID_32e9ce51477b" MODIFIED="1638264284746" TEXT="1. 什么是数据结构"><node CREATED="1638264284746" ID="ID_392530bace8c" MODIFIED="1638264284746" TEXT="是指相互之间存在一种或多种特定关系的数据元素的集合"></node><node CREATED="1638264284746" ID="ID_b3eb67f25ca6" MODIFIED="1638264284746" TEXT="或者说，数据结构是带结构的数据元素的集合"></node></node><node CREATED="1638264284746" ID="ID_1b9ffe2a6012" MODIFIED="1638264284746" TEXT="2. 数据结构的两种层次"><node CREATED="1638264284746" ID="ID_6df175892e71" MODIFIED="1638264284746" TEXT="逻辑结构"><node CREATED="1638264284746" ID="ID_dd264950cb94" MODIFIED="1638264284746" TEXT="描述数据元素之间的逻辑关系"></node><node CREATED="1638264284746" ID="ID_fe1614626672" MODIFIED="1638264284746" TEXT="与数据的存储无关，独立于计算机"></node><node CREATED="1638264284746" ID="ID_f46ac65f3b9c" MODIFIED="1638264284746" TEXT="是从具体问题抽象出来的数学模型"></node></node><node CREATED="1638264284746" ID="ID_0c9c79f45401" MODIFIED="1638264284746" TEXT="物理结构（存储结构））"><node CREATED="1638264284746" ID="ID_db44f8476252" MODIFIED="1638264284746" TEXT="数据元素及其关系在计算机存储器中的结构（存储方式）"></node></node></node></node><node CREATED="1638264284746" ID="ID_7d6f57c4e7de" MODIFIED="1638264284746" TEXT="2. 算法"><node CREATED="1638264284746" ID="ID_0f76f6ad5f2d" MODIFIED="1638264284746" TEXT="对特定问题求解方法和步骤的一种描述，它是指令的有限序列。&amp;lt;br&amp;gt;对解决问题的方法的描述"></node><node CREATED="1638264284746" ID="ID_0b9396f5f54b" MODIFIED="1638264284746" TEXT="算法的描述方法"><node CREATED="1638264284746" ID="ID_e9fa2ea362d9" MODIFIED="1638264284746" TEXT="1. 自然语言：英语、中文"></node><node CREATED="1638264284746" ID="ID_0654855bc835" MODIFIED="1638264284746" TEXT="2. 流程图：传统流程图、NS流程图"></node><node CREATED="1638264284746" ID="ID_4be5f82b130f" MODIFIED="1638264284746" TEXT="3. 伪代码：类C语言"></node><node CREATED="1638264284746" ID="ID_8020a316edad" MODIFIED="1638264284746" TEXT="4. 程序代码：C语言，C++语言程序"></node></node><node CREATED="1638264284746" ID="ID_e90f460dcbf7" MODIFIED="1638264284746" TEXT="算法的特性"><node CREATED="1638264284746" ID="ID_918a819f3bc8" MODIFIED="1638264284746" TEXT="1. 有穷性：一个算法总是在执行有穷步骤后结束"></node><node CREATED="1638264284746" ID="ID_297ab5951a90" MODIFIED="1638264284746" TEXT="2. 确定性：算法中的每一条指令必须有确切的含义，没有二义性"></node><node CREATED="1638264284746" ID="ID_2862e50364c7" MODIFIED="1638264284746" TEXT="3. 可行性： 算法是可执行的"></node><node CREATED="1638264284746" ID="ID_b7b3211bbf2d" MODIFIED="1638264284746" TEXT="4. 输入：一个算法有0个或者多个输入"></node><node CREATED="1638264284746" ID="ID_fc8a4e3e34bd" MODIFIED="1638264284746" TEXT="5. 输出：输出待求结果"></node></node><node CREATED="1638264284746" ID="ID_9c88ca3afdbf" MODIFIED="1638264284746" TEXT="算法设计的要求"><node CREATED="1638264284746" ID="ID_f68ccda18d23" MODIFIED="1638264284746" TEXT="1. 正确性："><node CREATED="1638264284746" ID="ID_87a3eb85d7f7" MODIFIED="1638264284746" TEXT="1. 没有语法错误"></node><node CREATED="1638264284746" ID="ID_d68d2d82415d" MODIFIED="1638264284746" TEXT="2. 对于精心选择的，苛刻的刁难的数据也能输出正确的结果"></node><node CREATED="1638264284746" ID="ID_286480a99a61" MODIFIED="1638264284746" TEXT="3. 程序对于一切合法的输入数据都能得到正确的输出结果"></node></node><node CREATED="1638264284746" ID="ID_bdeeebc2667c" MODIFIED="1638264284746" TEXT="2. 可读性&amp;lt;br&amp;gt;"></node><node CREATED="1638264284746" ID="ID_ed7ab0063f0c" MODIFIED="1638264284746" TEXT="3. 健壮性"><node CREATED="1638264284746" ID="ID_9702d71d1c93" MODIFIED="1638264284746" TEXT="1. 指当输入非法数据的时候，算法能够恰当的做出反应或进行相应处理，而不是输出莫名其妙的结果"></node><node CREATED="1638264284746" ID="ID_156493f64979" MODIFIED="1638264284746" TEXT="2. 处理出错的方法，不应是中断程序的执行，而应是返回一个表示错误或者错误性质的值，以便在更高抽象层次上进行处理"></node></node><node CREATED="1638264284746" ID="ID_dcda09d30ee7" MODIFIED="1638264284746" TEXT="4. 高效性"><node CREATED="1638264284746" ID="ID_0e4eb8336ee1" MODIFIED="1638264284746" TEXT="要求花费尽量少的时间和尽量低的存储需求"><node CREATED="1638264284746" ID="ID_75db358ac057" MODIFIED="1638264284746" TEXT="时间效率：指的是算法所耗费的时间"><node CREATED="1638264284746" ID="ID_2269e23f19a7" MODIFIED="1638264284746" TEXT="算法时间效率的度量"><node CREATED="1638264284746" ID="ID_83e6a5145350" MODIFIED="1638264284746" TEXT="1. 事后统计：将算法实现运行，测算其时间和空间的开销"><node CREATED="1638264284746" ID="ID_4e2b2e600215" MODIFIED="1638264284746" TEXT="缺点：&amp;lt;br&amp;gt;1. 将算法转换为实际能够运行的程序需要花费大量的时间&amp;lt;br&amp;gt;2. 所得到的测试结果依赖于计算的软硬件等环境因素&amp;lt;br&amp;gt;因此——不常用"></node></node><node CREATED="1638264284746" ID="ID_4ae31d413607" MODIFIED="1638264284746" TEXT="2. 事前分析：对算法所耗时间和空间资源的一种估计"><node CREATED="1638264284746" ID="ID_4342bae72042" MODIFIED="1638264284746" TEXT="事前分析方法：&amp;lt;br&amp;gt;算法运行时间 =一个简单操作所需的时间（如赋值、移动、比较）*简单操作次数&amp;lt;br&amp;gt;简单来说，就是算法中每条语句执行时间之和&amp;lt;br&amp;gt;更进一步，将单条语句的执行之间设定为单位执行时间，不考虑硬件和语言特性&amp;lt;br&amp;gt;则算法的耗费时间定义为&amp;lt;b&amp;gt;该算法中每条语句的频度之和&amp;lt;/b&amp;gt;"><node CREATED="1638264284746" ID="ID_76def241b747" MODIFIED="1638264284746" TEXT="王卓老师视频截图"></node><node CREATED="1638264284746" ID="ID_4cd76ec82e50" MODIFIED="1638264284746" TEXT="为了便于比较不同算法的时间效率，简化我们分析算法的时间耗度，我们一般仅比较他们的数量级"></node><node CREATED="1638264284746" ID="ID_7ec60b15b714" MODIFIED="1638264284746" TEXT="时间复杂度的概念：若有某个辅助函数f（n），使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度&amp;lt;br&amp;gt;"><node CREATED="1638264284746" ID="ID_6541c7304c83" MODIFIED="1638264284746" TEXT="对于复杂的算法，我们可以将算法分成容易估算的几个部分&amp;lt;br&amp;gt;然后利用加法规则和乘法规则计算算法总的时间复杂度"><node CREATED="1638264284746" ID="ID_fea326c275b7" MODIFIED="1638264284746" TEXT="1. 加法规则 O(f(n))=O(f1+f2)"></node><node CREATED="1638264284746" ID="ID_5cedfe6d4f49" MODIFIED="1638264284746" TEXT="2. 乘法规则 O(f(n))=O(f1xf2)"></node></node></node></node></node></node></node><node CREATED="1638264284746" ID="ID_1c21225c6f37" MODIFIED="1638264284746" TEXT="空间效率：指的是算法执行过程中所耗费的存储空间"></node></node></node><node CREATED="1638264284746" ID="ID_fcaaa3f19e31" MODIFIED="1638264284746" TEXT="5. 鲁棒性？"></node></node></node></node><node CREATED="1638264284746" ID="ID_0e704fdaa4e4" POSITION="right" MODIFIED="1638264284746" TEXT="2. 数据结构"><node CREATED="1638264284746" ID="ID_25a74480057b" MODIFIED="1638264284746" TEXT="1. 线性表"><node CREATED="1638264284746" ID="ID_f5565eb3c0c6" MODIFIED="1638264284746" TEXT="线性表的定义：零个或多个元素的有限序列&amp;lt;br&amp;gt;"><node CREATED="1638264284746" ID="ID_e79d9805052f" MODIFIED="1638264284746" TEXT="线性表只有一个表头和一个表尾"></node><node CREATED="1638264284746" ID="ID_896b6b9c019e" MODIFIED="1638264284746" TEXT="线性表中每一个元素最多只有一个前趋和一个后继"></node></node><node CREATED="1638264284746" ID="ID_f287cd61ea3e" MODIFIED="1638264284746" TEXT="存储结构方式"><node CREATED="1638264284746" ID="ID_563ae58f2519" MODIFIED="1638264284746" TEXT="1. 顺序存储：必须是占用一片连续的存储空间。中间有空出来的地址，都不能叫做线性表的顺序存储&amp;lt;br&amp;gt;利用数据元素的存储位置表示线性表中相邻元素的前后关系；&amp;lt;br&amp;gt;顺序存储的线性表其逻辑关系和存储关系是一致的"><node CREATED="1638264284746" ID="ID_eb48c6e6a722" MODIFIED="1638264284746" TEXT="1. 顺序线性表初始化算法实现"></node><node CREATED="1638264284746" ID="ID_a4d95b3499d6" MODIFIED="1638264284746" TEXT="2. 顺序线性表清空、销毁算法实现"></node><node CREATED="1638264284746" ID="ID_f7bf0c23b6bf" MODIFIED="1638264284746" TEXT="3. 顺序线性表查找算法实现（时间复杂度O(n)）"></node><node CREATED="1638264284746" ID="ID_ab335f4f5e16" MODIFIED="1638264284746" TEXT="4. 顺序线性表插入、删除算法实现（时间复杂度为O(n)）"></node></node><node CREATED="1638264284746" ID="ID_a43bdf5d810a" MODIFIED="1638264284746" TEXT="2. 链式存储&amp;lt;br&amp;gt;"><node CREATED="1638264284746" ID="ID_a5785ebb6831" MODIFIED="1638264284746" TEXT="链式存储，由一个个结点相互链接形成的数据存储结构；&amp;lt;br&amp;gt;每一个结点由数据域和指针域组成；&amp;lt;br&amp;gt;数据域负责存储元素的数值数据；&amp;lt;br&amp;gt;指针域负责存储直接后继（以及前趋）结点的存储位置；"><node CREATED="1638264284746" ID="ID_71af578c1d5c" MODIFIED="1638264284746" TEXT="1. 单链表"><node CREATED="1638264284746" ID="ID_1b65143139ea" MODIFIED="1638264284746" TEXT="每个结点只有一个数据域和一个指针域"></node></node><node CREATED="1638264284746" ID="ID_fbd146a92da0" MODIFIED="1638264284746" TEXT="2. 双链表"><node CREATED="1638264284746" ID="ID_79d96a8734c6" MODIFIED="1638264284746" TEXT="每个结点有一个数据域和两个指针域"></node></node><node CREATED="1638264284746" ID="ID_5a1a7023ec3e" MODIFIED="1638264284746" TEXT="3. 循环链表"><node CREATED="1638264284747" ID="ID_57a684ba2b14" MODIFIED="1638264284747" TEXT="首尾相接的链表成为循环链表"></node></node></node></node></node></node><node CREATED="1638264284747" ID="ID_6da251609dca" MODIFIED="1638264284747" TEXT="2. 栈和队列"><node CREATED="1638264284747" ID="ID_dfc9aa940b21" MODIFIED="1638264284747" TEXT="栈和队列是一种特殊的线性表&amp;lt;br&amp;gt;栈只能从表尾插入元素，删除元素只能删除最后一个元素，秉持着先进后出的原则&amp;lt;br&amp;gt;队列只能从表尾插入元素，删除元素只能删除第一个元素，秉持着先进先出的原则"><node CREATED="1638264284747" ID="ID_42cbbe7cfce6" MODIFIED="1638264284747" TEXT="栈"><node CREATED="1638264284747" ID="ID_a3e5550fe50d" MODIFIED="1638264284747" TEXT="1. 顺序结构栈"><node CREATED="1638264284747" ID="ID_9682ccb7a02d" MODIFIED="1638264284747" TEXT="常用，因为比较简单，清空和销毁都比较方便"></node></node><node CREATED="1638264284747" ID="ID_67aa15322f06" MODIFIED="1638264284747" TEXT="2. 链式结构栈"></node><node CREATED="1638264284747" ID="ID_61ecb718c782" MODIFIED="1638264284747" TEXT="3. 栈和递归"><node CREATED="1638264284747" ID="ID_c6947ae3397f" MODIFIED="1638264284747" TEXT="我们熟知的递归函数就是使用了栈的一种方法。每一次函数的调用，变量和返回地址都会被保存在栈里&amp;lt;br&amp;gt;最先调用的，最后拿出来。"></node></node></node><node CREATED="1638264284747" ID="ID_ae0bb7288c71" MODIFIED="1638264284747" TEXT="队列"><node CREATED="1638264284747" ID="ID_ac0db752e258" MODIFIED="1638264284747" TEXT="表尾插入、表头删除&amp;lt;br&amp;gt;"><node CREATED="1638264284747" ID="ID_0bf85e15d9c1" MODIFIED="1638264284747" TEXT="1. 顺序队列"><node CREATED="1638264284747" ID="ID_2840904ec774" MODIFIED="1638264284747" TEXT="常用循环顺序队列"></node><node CREATED="1638264284747" ID="ID_e10c3a5feec1" MODIFIED="1638264284747" TEXT="循环顺序队列如何判断空队和满队？"><node CREATED="1638264284747" ID="ID_02564d8069e6" MODIFIED="1638264284747" TEXT="1. 设置一个标志flag"></node><node CREATED="1638264284747" ID="ID_d145929a5277" MODIFIED="1638264284747" TEXT="2. 增加了一个变量对元素个数计数"></node><node CREATED="1638264284747" ID="ID_ea07413525f9" MODIFIED="1638264284747" TEXT="3. 少使用一个空间，让空队的判断条件是front==rear&amp;lt;br&amp;gt;满队的判断条件为front == rear_next"><node CREATED="1638264284747" ID="ID_c1cadf7d831b" MODIFIED="1638264284747"></node></node></node></node><node CREATED="1638264284747" ID="ID_7d6381f3c7b6" MODIFIED="1638264284747" TEXT="2. 链式队列"><node CREATED="1638264284747" ID="ID_cec681db4a0b" MODIFIED="1638264284747" TEXT="链式队列其实就是一种简化版的链表"><node CREATED="1638264284747" ID="ID_ee26ea3b4242" MODIFIED="1638264284747" TEXT="与链表的相同的地方"><node CREATED="1638264284747" ID="ID_26c74ea64502" MODIFIED="1638264284747" TEXT="初始化、添加、删除元素用的是同一种逻辑"></node></node><node CREATED="1638264284747" ID="ID_6a7742c2eb16" MODIFIED="1638264284747" TEXT="与链表不同的地方"><node CREATED="1638264284747" ID="ID_7fbb7251c2f0" MODIFIED="1638264284747" TEXT="插入元素只能在表尾插，删除元素只能删除表头的元素"></node><node CREATED="1638264284747" ID="ID_7b4ebfa54d36" MODIFIED="1638264284747" TEXT="定义的方式有些许不一样，导致后面函数的访问就不一样"><node CREATED="1638264284747" ID="ID_eadd068e16f8" MODIFIED="1638264284747" TEXT="struct Qnode&amp;lt;br&amp;gt;{&amp;lt;br&amp;gt;    ELemType data;&amp;lt;br&amp;gt;    Qnode *next;&amp;lt;br&amp;gt;};&amp;lt;br&amp;gt;struct LinkQueue //再定义一个抽象数据类型，一次性建立两个Qnode指针&amp;lt;br&amp;gt;{&amp;lt;br&amp;gt;    Qnode *front; //头指针&amp;lt;br&amp;gt;    Qnode *rear;  //尾指针&amp;lt;br&amp;gt;};"></node></node></node></node></node></node></node></node></node><node CREATED="1638264284747" ID="ID_80f3966044ee" MODIFIED="1638264284747" TEXT="3. 串、数组、广义表"><node CREATED="1638264284747" ID="ID_0399eb7719f3" MODIFIED="1638264284747" TEXT="1. 串：字符串的简称"><node CREATED="1638264284747" ID="ID_ae22f256b04e" MODIFIED="1638264284747" TEXT="串的一些术语"><node CREATED="1638264284747" ID="ID_3dfcdd441760" MODIFIED="1638264284747" TEXT="1. 子串：串中任意个连续字符组成的子序列成为该串的子串&amp;lt;br&amp;gt;"></node><node CREATED="1638264284747" ID="ID_e2740263116d" MODIFIED="1638264284747" TEXT="2. 主串：包含子串的串相应地称为主串"></node><node CREATED="1638264284747" ID="ID_16d74bee2ece" MODIFIED="1638264284747" TEXT="3. 字符位置：字符在序列中的序号为该字符在串中的位置"></node><node CREATED="1638264284747" ID="ID_05bb82d9dcb1" MODIFIED="1638264284747" TEXT="4. 子串位置：子串第一个字符在主串中的位置"></node><node CREATED="1638264284747" ID="ID_6c9d04b33891" MODIFIED="1638264284747" TEXT="5. 空格串：由一个或多个空格组成的串，与空串是不一样的"></node><node CREATED="1638264284747" ID="ID_80bbbcd4c0a4" MODIFIED="1638264284747" TEXT="6. 串相等：当且仅当两个串的长度一样，且对应的字符都一一相等才能叫做串相等"></node></node><node CREATED="1638264284747" ID="ID_41094baf579b" MODIFIED="1638264284747" TEXT="串的存储结构"><node CREATED="1638264284747" ID="ID_b95035de0403" MODIFIED="1638264284747" TEXT="1. 顺序存储：简单，灵活。常用"></node><node CREATED="1638264284747" ID="ID_29a90ff64a78" MODIFIED="1638264284747" TEXT="2. 链式存储：插入和删除比较方便，但是存储效率只有20%，太低了"></node></node></node><node CREATED="1638264284747" ID="ID_75b1db652140" MODIFIED="1638264284747" TEXT="2.数组"><node CREATED="1638264284747" ID="ID_84cd83af47ea" MODIFIED="1638264284747" TEXT="1. 二维数组的逻辑结构"><node CREATED="1638264284747" ID="ID_a4d2706b82f6" MODIFIED="1638264284747" TEXT="1. 可以看做是非线性结构：一个在二维数组的元素，可能不止有一个前趋和一个后继，因此不是一个线性结构&amp;lt;br&amp;gt;"></node><node CREATED="1638264284747" ID="ID_a727543fd829" MODIFIED="1638264284747" TEXT="2. 也可以看作是线性的。因为其实没有二维数组的概念，二维数组本质上是数组的数组，一维数组中每一个元素又是一维数组罢了"></node></node><node CREATED="1638264284747" ID="ID_eca439af9972" MODIFIED="1638264284747" TEXT="2. 二维数据的压缩存储方法"><node CREATED="1638264284747" ID="ID_39c46ab2df24" MODIFIED="1638264284747" TEXT="1. 对称矩阵"><node CREATED="1638264284747" ID="ID_a25feb19a532" MODIFIED="1638264284747" TEXT="压缩存储方法：一般只存储下三角矩阵的元素（包括对角线），&amp;lt;br&amp;gt;下三角矩阵是一个递增的等差数列：元素个数=n*(n+1)/2&amp;lt;br&amp;gt;把这么多个数存在一行里。如果要解压缩，还是比较好推的&amp;lt;br&amp;gt;"></node></node><node CREATED="1638264284747" ID="ID_cbfd33e9fbee" MODIFIED="1638264284747" TEXT="2. 稀疏矩阵（矩阵中超过95%的元素都是0）"><node CREATED="1638264284747" ID="ID_7912af557887" MODIFIED="1638264284747" TEXT="压缩存储方式：用一个三元组表示稀疏矩阵中的非零元素&amp;lt;br&amp;gt;三元组的前两个元素是表示元素的坐标，第三个元素是值本身"></node></node><node CREATED="1638264284747" ID="ID_faae70daae6e" MODIFIED="1638264284747" TEXT="3. 带状矩阵（对角矩阵）"><node CREATED="1638264284747" ID="ID_19414691f3c8" MODIFIED="1638264284747" TEXT="压缩存储方法：1. 每一条带（对角线）存一行&amp;lt;br&amp;gt;2. 带状矩阵每一行非零的存一行（最前面几行和最后面几行要补0）"></node></node></node></node><node CREATED="1638264284747" ID="ID_aa6d5953b44a" MODIFIED="1638264284747" TEXT="3. 广义表"><node CREATED="1638264284747" ID="ID_70598f1b93d4" MODIFIED="1638264284747" TEXT="广义表是线性表的推广&amp;lt;br&amp;gt;线性表中的元素是单一的，&amp;lt;br&amp;gt;而广义表中的元素可以是一种普通的数据类型&amp;lt;br&amp;gt;也可以是广义表本身，有一种递归的潜质"><node CREATED="1638264284747" ID="ID_1233f3baa5d4" MODIFIED="1638264284747" TEXT="广义表的几种定义"><node CREATED="1638264284747" ID="ID_cff89d49c022" MODIFIED="1638264284747" TEXT="广义表的表头是第一个元素，表尾是除开第一个元素的剩余元素集合&amp;lt;br&amp;gt;广义表的递归有些类似于链表"></node></node><node CREATED="1638264284747" ID="ID_bccc956cdeef" MODIFIED="1638264284747" TEXT="广义表的一些术语"><node CREATED="1638264284747" ID="ID_f8ff9f5b80d6" MODIFIED="1638264284747" TEXT="1. 广义表的长度：最外层括号所包含的元素个数"></node><node CREATED="1638264284747" ID="ID_c6898637863b" MODIFIED="1638264284747" TEXT="2. 广义表的深度：把广义表展开，括号对的重数&amp;lt;br&amp;gt;空表是深度为1，原子深度为0"></node><node CREATED="1638264284747" ID="ID_94469cf981e1" MODIFIED="1638264284747"></node><node CREATED="1638264284747" ID="ID_7076b85b9845" MODIFIED="1638264284747" TEXT="4. 一个非空广义表的表头可以是一个原子，也可以是一个广义表&amp;lt;br&amp;gt;但是广义表的表尾一定是一个表尾"></node></node></node></node></node><node CREATED="1638264284747" ID="ID_589bfe5396cc" MODIFIED="1638264284747" TEXT="4. 树"><node CREATED="1638264284747" ID="ID_058adfafb8fb" MODIFIED="1638264284747" TEXT="1. 树的定义"><node CREATED="1638264284747" ID="ID_5333d636bd86" MODIFIED="1638264284747" TEXT="1. 树的定义"><node CREATED="1638264284747" ID="ID_7ff7eb416795" MODIFIED="1638264284747" TEXT="n（n&amp;gt;=0）个结点的有限集"><node CREATED="1638264284747" ID="ID_6dc7463976fe" MODIFIED="1638264284747" TEXT="1. n=0时称为空树"></node><node CREATED="1638264284747" ID="ID_877efdaaa79b" MODIFIED="1638264284747" TEXT="2. n&amp;gt;=1时&amp;lt;br&amp;gt;有且仅有一个结点称为树的根（root）&amp;lt;br&amp;gt;其余结点可分为m(m&amp;gt;=0)个互不相交的有限集合，T1,T2...&amp;lt;br&amp;gt;其中每一个有限集合又可以看作是一个树，称为子树（sub-tree）"></node></node><node CREATED="1638264284747" ID="ID_8f242a6f376b" MODIFIED="1638264284747" TEXT="常见的，我们写文章标题的分类，就是树的结构"></node></node><node CREATED="1638264284747" ID="ID_319d4bef0353" MODIFIED="1638264284747" TEXT="2. 树的术语"><node CREATED="1638264284747" ID="ID_c4f3f07df8ae" MODIFIED="1638264284747" TEXT="1. 根结点：非空树表中，没有直接前趋的结点就是根节点"></node><node CREATED="1638264284747" ID="ID_58fb4b378bf5" MODIFIED="1638264284747" TEXT="2. 结点的度：结点所包含的子树的个数"></node><node CREATED="1638264284747" ID="ID_f10aec79f86b" MODIFIED="1638264284747" TEXT="3. 树的度：树内各结点的度的最大值"></node><node CREATED="1638264284747" ID="ID_5798dc19048f" MODIFIED="1638264284747"></node><node CREATED="1638264284747" ID="ID_0d7e304506c0" MODIFIED="1638264284747" TEXT="4. 树的深度：树种结点层次的最大数，有时也叫树的高度"></node><node CREATED="1638264284747" ID="ID_21ecc165d538" MODIFIED="1638264284747" TEXT="5. 森林：m（m&amp;gt;=0）互不相交的树的集合"></node></node><node CREATED="1638264284747" ID="ID_59f396566c3c" MODIFIED="1638264284747" TEXT="3. 树和线性表之间的区别："><node CREATED="1638264284747" ID="ID_9a1aa0f5f53e" MODIFIED="1638264284747" TEXT="1. 线性表的表头元素无前趋&amp;lt;br&amp;gt;树的根节点无双亲&amp;lt;br&amp;gt;"></node><node CREATED="1638264284747" ID="ID_1b25adce9764" MODIFIED="1638264284747" TEXT="2. 线性表的表尾元素无后继&amp;lt;br&amp;gt;树的叶子无孩子"></node><node CREATED="1638264284747" ID="ID_263731712f4b" MODIFIED="1638264284747" TEXT="3. 线性表中的元素只有一个前趋和一个后继：一对一的关系&amp;lt;br&amp;gt;树中的结点是有一个双亲和多个孩子：一对多的关系"></node></node></node><node CREATED="1638264284747" ID="ID_458cd983fe2c" MODIFIED="1638264284747" TEXT="2. 二叉树"><node CREATED="1638264284747" ID="ID_8f056fed66c5" MODIFIED="1638264284747" TEXT="二叉树的存在意义：普通的树因为太复杂了，用计算机实现的话非常麻烦&amp;lt;br&amp;gt;因此我们常用二叉树来使用树"></node><node CREATED="1638264284747" ID="ID_c1dbaba5a544" MODIFIED="1638264284747" TEXT="1. 二叉树的定义："><node CREATED="1638264284747" ID="ID_3819e05f21e8" MODIFIED="1638264284747" TEXT="由一个根节点和两个互不相交的左子树和右子树构成的集合"><node CREATED="1638264284747" ID="ID_2d4fd5cc3c02" MODIFIED="1638264284747" TEXT="1. 二叉树的结点最多只有两个度，也即只有两个孩子"></node><node CREATED="1638264284747" ID="ID_ce8e40310acd" MODIFIED="1638264284747" TEXT="2. 二叉树的子树是有左右之分的"></node><node CREATED="1638264284747" ID="ID_ca1716ab3665" MODIFIED="1638264284747" TEXT="严格来说，二叉树不是树的特殊情况&amp;lt;br&amp;gt;这是因为二叉树对子树的左右次序进行了严格的要求，即使只有一个子树，也要说明是左还是右|&amp;lt;br&amp;gt;这是二叉树和树之间最大的差别"></node></node></node><node CREATED="1638264284747" ID="ID_a5c1b6bd3940" MODIFIED="1638264284747" TEXT="2. 二叉树的性质"><node CREATED="1638264284747" ID="ID_f4f284af1f1b" MODIFIED="1638264284747" TEXT="1. 二叉树的第i层中最多有2^(i-1)个结点&amp;lt;br&amp;gt;最少也得有1个结点"></node><node CREATED="1638264284747" ID="ID_2626ab928751" MODIFIED="1638264284747" TEXT="2. 深度为k的二叉树的结点总数最多为2^k - 1&amp;lt;br&amp;gt;最少结点数为k"></node><node CREATED="1638264284747" ID="ID_d235d0e2b841" MODIFIED="1638264284747" TEXT="3. 在一个二叉树中，设叶子数（没有分支）的个数为n0，度为2（有两个分支）的个数为n2&amp;lt;br&amp;gt;则有n0 = n2 + 1&amp;lt;br&amp;gt;证明：设二叉树的边线总数为 B&amp;lt;br&amp;gt;B = n - 1&amp;lt;br&amp;gt;B = 2*n2 + n1&amp;lt;br&amp;gt;n = n0 + n1 + n2&amp;lt;br&amp;gt;则有：&amp;lt;br&amp;gt;n0 + n1 + n2 -1 = 2*n2 + n1&amp;lt;br&amp;gt;n0 = n2 +1"></node><node CREATED="1638264284747" ID="ID_1ca5a2673233" MODIFIED="1638264284747" TEXT="补充知识点"><node CREATED="1638264284747" ID="ID_dad4d010f043" MODIFIED="1638264284747" TEXT="1. 满二叉树：深度为k，结点总数为2^k-1(max)"><node CREATED="1638264284747" ID="ID_f23c3ea25520" MODIFIED="1638264284747" TEXT="满二叉树的叶子数是同深度最多的，2^(k-1)"></node><node CREATED="1638264284747" ID="ID_e93fe2a6dace" MODIFIED="1638264284747" TEXT="满二叉树在同样深度的二叉树中，结点数是最多的"></node></node><node CREATED="1638264284747" ID="ID_098b356e4c72" MODIFIED="1638264284747" TEXT="2. 完全二叉树：从满二叉树的最后一个结点（二叉树顺序：从上到下，从左到右），依次连续的去掉结点的二叉树，才能叫完全二叉树"><node CREATED="1638264284747" ID="ID_8aa183950271" MODIFIED="1638264284747" TEXT="完全二叉树和满二叉树的编号是一一对应的"></node><node CREATED="1638264284747" ID="ID_6e6af6e3ba86" MODIFIED="1638264284747" TEXT="完全二叉树的叶子结点只能分布在第i层和第i-1层"></node><node CREATED="1638264284748" ID="ID_3555301af6e1" MODIFIED="1638264284748" TEXT="完全二叉树的某个结点的左子树的层数一定是右子树的同级后者下一级"></node></node><node CREATED="1638264284748" ID="ID_9ab44ff0c118" MODIFIED="1638264284748" TEXT="3. 具有n个结点的二叉树，有n+1个空指针域"></node></node><node CREATED="1638264284748" ID="ID_52048e396cbc" MODIFIED="1638264284748" TEXT="4. 具有n个结点的完全二叉树的深度k为：k = 向上取整（log2 n）"></node><node CREATED="1638264284748" ID="ID_d7e733306d9a" MODIFIED="1638264284748" TEXT="5. 具有n个结点的完全二叉树，其结点i有如下性质"><node CREATED="1638264284748" ID="ID_e66f38cdaf4f" MODIFIED="1638264284748" TEXT="1. i= 1：该结点是根节点"></node><node CREATED="1638264284748" ID="ID_96fda7120b26" MODIFIED="1638264284748" TEXT="2. i的双亲结点是 向下取整（i/2）"></node><node CREATED="1638264284748" ID="ID_d9ec831ea181" MODIFIED="1638264284748" TEXT="3. 如果2*i &amp;gt; n。那么该结点为叶子结点&amp;lt;br&amp;gt;"></node><node CREATED="1638264284748" ID="ID_f7ed8f752c5f" MODIFIED="1638264284748" TEXT="4. 如果2*i +1&amp;gt;n。那么该节点没有右孩子"></node></node></node><node CREATED="1638264284748" ID="ID_a665dc4eb3d9" MODIFIED="1638264284748" TEXT="3. 二叉树的存储方式"><node CREATED="1638264284748" ID="ID_aee89e252fe0" MODIFIED="1638264284748" TEXT="1. 顺序存储方式"><node CREATED="1638264284748" ID="ID_bd6aa0cde23f" MODIFIED="1638264284748" TEXT="不常用，缺点如下：&amp;lt;br&amp;gt;1. 顺序结构不能改变长度，插入和删除很慢&amp;lt;br&amp;gt;2. 顺序结构表示非完全二叉树的时候，非常浪费空间"></node></node><node CREATED="1638264284748" ID="ID_93a26d58f05a" MODIFIED="1638264284748" TEXT="2. 链式存储方式"><node CREATED="1638264284748" ID="ID_1d9031590fdd" MODIFIED="1638264284748" TEXT="记一条性质：有n个结点的二叉树，其结点的链域为空的个数为n+1"></node></node></node><node CREATED="1638264284748" ID="ID_d310908feea4" MODIFIED="1638264284748" TEXT="4. 二叉树的遍历方式"><node CREATED="1638264284748" ID="ID_df5ec4cb6328" MODIFIED="1638264284748" TEXT="遍历二叉树时，我们选定一种遍历方式，比如说LDR中序遍历&amp;lt;br&amp;gt;在遍历时，对每一个结点（子树）都采用该遍历方式"></node><node CREATED="1638264284748" ID="ID_3197b09d24e0" MODIFIED="1638264284748" TEXT="已知遍历结果，能否反推二叉树的形状？"><node CREATED="1638264284748" ID="ID_fecef3b8b9b8" MODIFIED="1638264284748" TEXT="1. 一种先序和中序可以反推"><node CREATED="1638264284748" ID="ID_80d110becbf2" MODIFIED="1638264284748" TEXT="先序的首元素一定是根结点&amp;lt;br&amp;gt;那么，在中序中找到根结点，位于根结点之前的都是根结点的左子树，之后的都是右子树的&amp;lt;br&amp;gt;再反复根据先序和中序确定每一个元素的位置"></node></node><node CREATED="1638264284748" ID="ID_352bf7735fa7" MODIFIED="1638264284748" TEXT="2. 已知中序和后序可以反推"><node CREATED="1638264284748" ID="ID_ec5e1a835993" MODIFIED="1638264284748" TEXT="后序（LRD）的尾元素一定是根结点&amp;lt;br&amp;gt;那么，在中序中找到根结点，位于根结点之前的都是根结点的左子树，之后的都是右子树的&amp;lt;br&amp;gt;再反复根据后序和中序确定每一个元素的位置&amp;lt;br&amp;gt;"></node></node></node></node><node CREATED="1638264284748" ID="ID_9bde85ff532f" MODIFIED="1638264284748" TEXT="5. 二叉树的操作"><node CREATED="1638264284748" ID="ID_461aa43499d8" MODIFIED="1638264284748" TEXT="1. 二叉树的遍历"><node CREATED="1638264284748" ID="ID_2253fc0e6555" MODIFIED="1638264284748" TEXT="1. 先序遍历DLR"></node><node CREATED="1638264284748" ID="ID_d38451dd9238" MODIFIED="1638264284748" TEXT="2. 中序遍历LDR"></node><node CREATED="1638264284748" ID="ID_3e5c4f30f3fe" MODIFIED="1638264284748" TEXT="3. 后序遍历LRD"></node><node CREATED="1638264284748" ID="ID_9276e944d8dc" MODIFIED="1638264284748" TEXT="4. 中序遍历的非递归算法——使用栈保存结点信息"></node><node CREATED="1638264284748" ID="ID_fc2990c1a6f8" MODIFIED="1638264284748" TEXT="5. 二叉树的层次遍历算法"><node CREATED="1638264284748" ID="ID_e078cd3ae1e4" MODIFIED="1638264284748" TEXT="BFS广度优先算法"></node><node CREATED="1638264284748" ID="ID_6ade5bbf5109" MODIFIED="1638264284748" TEXT="算法设计思路：&amp;lt;br&amp;gt;    1.将根结点入队&amp;lt;br&amp;gt;    2.队列不为空时循环，从队列中出列一个元素，访问它，并作以下步骤：&amp;lt;br&amp;gt;        2.1 如果该元素的左孩子不为空，让该元素的左孩子入队&amp;lt;br&amp;gt;        2.2 如果该元素的右孩子不为空，让该元素的右孩子入队&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1638264284748" ID="ID_e7baaf598114" MODIFIED="1638264284748" TEXT="2. 二叉树的创建"><node CREATED="1638264284748" ID="ID_3951a6b5771e" MODIFIED="1638264284748" TEXT="1. 选定一个遍历方式。常用先序遍历DLR"></node><node CREATED="1638264284748" ID="ID_85742a91c4bc" MODIFIED="1638264284748" TEXT="2. 使用递归函数，创建一个二叉树"></node><node CREATED="1638264284748" ID="ID_2d90190c2a7f" MODIFIED="1638264284748" TEXT="3. 设定一个输入的特定字符，用于判定当前创建的结点没有左右孩子"></node></node><node CREATED="1638264284748" ID="ID_ec50cba3866b" MODIFIED="1638264284748" TEXT="3. 二叉树的复制"><node CREATED="1638264284748" ID="ID_ce4eb222ac32" MODIFIED="1638264284748" TEXT="同二叉树的创建操作基本一致"></node></node><node CREATED="1638264284748" ID="ID_6fabd7eef2d0" MODIFIED="1638264284748" TEXT="4. 求二叉树的深度"><node CREATED="1638264284748" ID="ID_929376626a15" MODIFIED="1638264284748" TEXT="算法非常巧妙，还是递归函数的方式，只不过在函数内部有两个变量，用于保存当前的深度值，通过比较输出双亲的左或右孩子的深度值"></node></node><node CREATED="1638264284748" ID="ID_473a3a01d362" MODIFIED="1638264284748" TEXT="5. 求二叉树的结点数"></node><node CREATED="1638264284748" ID="ID_7b34a014c5f4" MODIFIED="1638264284748" TEXT="6. 求二叉树的叶子数"></node></node><node CREATED="1638264284748" ID="ID_127d01a0fb6e" MODIFIED="1638264284748" TEXT="6. 线索二叉树"><node CREATED="1638264284748" ID="ID_a56f7f9adacc" MODIFIED="1638264284748" TEXT="1. 线索二叉树的定义"><node CREATED="1638264284748" ID="ID_7da5c30fb548" MODIFIED="1638264284748" TEXT="如果一个二叉树的的结点的左指针域为空，那么我们将左指针指向这个结点的前驱&amp;lt;br&amp;gt;如果结点的右指针为空，那么将右指针指向这个结点的后继&amp;lt;br&amp;gt;这里的前驱和后继指的是输出序列中结点的前后关系哈"></node></node></node></node><node CREATED="1638264284748" ID="ID_016aeeb9f7d3" MODIFIED="1638264284748" TEXT="3. 树和森林"><node CREATED="1638264284748" ID="ID_5a0828402f30" MODIFIED="1638264284748" TEXT="1. 树的存储方式"><node CREATED="1638264284748" ID="ID_eaca2196e70c" MODIFIED="1638264284748" TEXT="1. 双亲表示法"><node CREATED="1638264284748" ID="ID_2a9e97c7dc43" MODIFIED="1638264284748" TEXT="用一个数组存放一棵树，数组的元素是结构体，结构体的内容是树结点的内容，以及当前结点的双亲在数组中的下标"></node></node><node CREATED="1638264284748" ID="ID_110d27cd8455" MODIFIED="1638264284748" TEXT="2. 孩子链表法"><node CREATED="1638264284748" ID="ID_aa0dd0a8e457" MODIFIED="1638264284748" TEXT="把每一层的每一个结点的孩子们看作是一个链表，然后用数组存储树的每一个结点（从上到下，从左到右）&amp;lt;br&amp;gt;每个结点的孩子链表的数据域内容是孩子结点在数组中的位置"></node><node CREATED="1638264284748" ID="ID_8b0f47779c6e" MODIFIED="1638264284748" TEXT="这种存储方式，比较容易找到一个结点的孩子，但是不容易找到结点的双亲，那怎么样可以又快速找到双亲，又找孩子呢？&amp;lt;br&amp;gt;答案就是将孩子链表和双亲表示法结合起来，得到一个双亲孩子链表表示方法"></node></node><node CREATED="1638264284748" ID="ID_985dd55deb50" MODIFIED="1638264284748" TEXT="3. 孩子兄弟表示法"><node CREATED="1638264284748" ID="ID_520f3c9466d0" MODIFIED="1638264284748" TEXT="同二叉树的定义方式相似，定义一个数据域，两个指针域。左指针指向当前结点的孩子，右指针呢，指向当前结点的兄弟结点，没有就为空。"></node></node></node><node CREATED="1638264284748" ID="ID_5e58759835ad" MODIFIED="1638264284748" TEXT="2. 树和二叉树的转换方式"><node CREATED="1638264284748" ID="ID_163133c51123" MODIFIED="1638264284748" TEXT="树转换成二叉树"><node CREATED="1638264284748" ID="ID_5d4548786c27" MODIFIED="1638264284748" TEXT="借助与树的孩子兄弟链表表示法&amp;lt;br&amp;gt;我们将树转换为二叉树&amp;lt;br&amp;gt;几个字概括其转换方式：兄弟相连留长子"></node><node CREATED="1638264284748" ID="ID_e180cb868652" MODIFIED="1638264284748"></node></node><node CREATED="1638264284748" ID="ID_fd975030b235" MODIFIED="1638264284748" TEXT="二叉树转换成树"><node CREATED="1638264284748" ID="ID_83000531c605" MODIFIED="1638264284748" TEXT="口诀：左孩右右连双亲&amp;lt;br&amp;gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 去掉原来右孩线"></node><node CREATED="1638264284748" ID="ID_c5a948134482" MODIFIED="1638264284748"></node></node></node><node CREATED="1638264284748" ID="ID_278b7884b795" MODIFIED="1638264284748" TEXT="3. 树的遍历方式"><node CREATED="1638264284748" ID="ID_2f35058bebf0" MODIFIED="1638264284748" TEXT="1. 先根（序）遍历：先访问树的根节点，再访问子树"><linktarget COLOR="#b0b0b0" DESTINATION="ID_2f35058bebf0" ENDARROW="Default" ID="Arrow_ID_4ec6f295cc9d" SOURCE="ID_78f081e740ce" STARTARROW="None"/></node><node CREATED="1638264284748" ID="ID_4fe76d3cbb22" MODIFIED="1638264284748" TEXT="2. 后根（序）遍历：先访问树的子树，最后访问根结点"><linktarget COLOR="#b0b0b0" DESTINATION="ID_4fe76d3cbb22" ENDARROW="Default" ID="Arrow_ID_2ae5da826739" SOURCE="ID_1f61d31b21ed" STARTARROW="None"/></node><node CREATED="1638264284748" ID="ID_4ce88b6d3a28" MODIFIED="1638264284748" TEXT="3. 层次遍历"></node></node><node CREATED="1638264284748" ID="ID_d075fcd15636" MODIFIED="1638264284748" TEXT="4. 森林的遍历方式"><node CREATED="1638264284748" ID="ID_82fb8087d568" MODIFIED="1638264284748" TEXT="1. 先序遍历"><node CREATED="1638264284748" ID="ID_78f081e740ce" MODIFIED="1638264284748" TEXT="把森林拆分成一个个树，对树进行先根遍历"><arrowlink DESTINATION="ID_2f35058bebf0" ENDARROW="Default" ID="Arrow_ID_4ec6f295cc9d" STARTARROW="None"/></node></node><node CREATED="1638264284748" ID="ID_a866ec9603e6" MODIFIED="1638264284748" TEXT="2. 中序遍历"><node CREATED="1638264284748" ID="ID_1f61d31b21ed" MODIFIED="1638264284748" TEXT="把森林拆分成一个个树，对树进行后根遍历"><arrowlink DESTINATION="ID_4fe76d3cbb22" ENDARROW="Default" ID="Arrow_ID_2ae5da826739" STARTARROW="None"/></node></node></node></node><node CREATED="1638264284748" ID="ID_12357f4cf0ed" MODIFIED="1638264284748" TEXT="4. 哈夫曼树"><node CREATED="1638264284748" ID="ID_7dec72fbaf7d" MODIFIED="1638264284748" TEXT="1. 最优哈夫曼树的概念"><node CREATED="1638264284748" ID="ID_a919dc2777d0" MODIFIED="1638264284748" TEXT="1. 先补充点知识"><node CREATED="1638264284748" ID="ID_365278dc57ca" MODIFIED="1638264284748" TEXT="1. 路径：树的结点与结点之间的连线就是路径"></node><node CREATED="1638264284748" ID="ID_a8e4956925c0" MODIFIED="1638264284748" TEXT="2. 树的路径长度：从树的根节点到树的每个结点的路径长度之和"></node><node CREATED="1638264284748" ID="ID_171294bf3800" MODIFIED="1638264284748" TEXT="3. 权重：叶子结点的权重系数"></node><node CREATED="1638264284748" ID="ID_80497f31ee32" MODIFIED="1638264284748" TEXT="4. 树的带权路径长度之和：从根节点到叶子结点的路径之和再乘以对应的叶子结点的权重系数"></node></node><node CREATED="1638264284748" ID="ID_51c9adace46f" MODIFIED="1638264284748" TEXT="2. 哈夫曼树就是带权路径长度之和最小的树，也即最优树"></node><node CREATED="1638264284748" ID="ID_e59476ec1ae9" MODIFIED="1638264284748" TEXT="3. 哈夫曼树不唯一，同一带权路径长度之和可以有多种二叉树形式"></node><node CREATED="1638264284748" ID="ID_0f96080918ae" MODIFIED="1638264284748" TEXT="4. 满二叉树不一定是哈夫曼树"></node><node CREATED="1638264284748" ID="ID_f5309250cfa6" MODIFIED="1638264284748" TEXT="5. 哈夫曼树中权重越大的结点离根结点越近"></node></node><node CREATED="1638264284748" ID="ID_b95b45121644" MODIFIED="1638264284748" TEXT="2. 哈夫曼树的构造"><node CREATED="1638264284748" ID="ID_f99ea7f95302" MODIFIED="1638264284748" TEXT="1. 构造思路"><node CREATED="1638264284748" ID="ID_7ce8cfaf966e" MODIFIED="1638264284748" TEXT="1. 删除两小造新人：&amp;lt;br&amp;gt;把权重结点设定为只有根结点的一颗颗树，把这些树组成一个森林&amp;lt;br&amp;gt;从树里面找到权重最小的两棵树，组成一颗新树，新树的权重是两小树的和&amp;lt;br&amp;gt;在森林中删除这两个小树，保留新的合成树&amp;lt;br&amp;gt;重复以上过程，直到森林变成一棵树"></node></node></node><node CREATED="1638264284748" ID="ID_9c6053780e2e" MODIFIED="1638264284748" TEXT="3. 哈夫曼编码"><node CREATED="1638264284748" ID="ID_f699ae3c45fc" MODIFIED="1638264284748" TEXT="构造思路"><node CREATED="1638264284748" ID="ID_5eb3cfea9e03" MODIFIED="1638264284748" TEXT="1. 由结点的权重构造一颗哈夫曼树（调用哈夫曼树构造函数）"></node><node CREATED="1638264284748" ID="ID_dab45320e5c4" MODIFIED="1638264284748" TEXT="2. 从哈夫曼树的根节点开始，左边的路径是0，右边的路径是1，每一个的叶子结点的哈夫曼编码就此产生"></node></node></node><node CREATED="1638264284748" ID="ID_6fe6578aaa2e" MODIFIED="1638264284748" TEXT="4. 哈夫曼解码"><node CREATED="1638264284748" ID="ID_d976fc2c7a1e" MODIFIED="1638264284748" TEXT="解码思路"><node CREATED="1638264284748" ID="ID_2a6a5d02da71" MODIFIED="1638264284748" TEXT="1. 要通过哈夫曼编码算法得到哈夫曼的编码HC"></node><node CREATED="1638264284748" ID="ID_79558a284291" MODIFIED="1638264284748" TEXT="2. 有了字母对应的哈夫曼编码表，我们可以使用两种方式进行解码"><node CREATED="1638264284748" ID="ID_e46a071ca152" MODIFIED="1638264284748" TEXT="1. 不查表：用暗文的二进制码，代入到哈夫曼树中，根据哈夫曼编码的原则，从哈夫曼树的根节点开始&amp;lt;br&amp;gt;向下，直到到达叶子结点，该叶子结点的就是对应的明文"></node><node CREATED="1638264284748" ID="ID_f5784edd7071" MODIFIED="1638264284748" TEXT="2. 查表：我们通过哈夫曼编码算法都已经得到一个明文-暗文的对照表了，那我们就可以使用BF或者KMP匹配算法&amp;lt;br&amp;gt;在暗文中一点点的匹配对应的解码暗文，最终翻译整个暗文（我感觉这个速度应该有点慢、）"></node></node></node></node></node></node><node CREATED="1638264284748" ID="ID_c7fb1158cc82" MODIFIED="1638264284748" TEXT="5. 图"><node CREATED="1638264284748" ID="ID_837c078f9d24" MODIFIED="1638264284748" TEXT="1. 图的定义"><node CREATED="1638264284748" ID="ID_196f1cd0957b" MODIFIED="1638264284748" TEXT="1. G=（V,E）&amp;lt;br&amp;gt;V：顶点（数据元素）组成的有限非空集合&amp;lt;br&amp;gt;E：边的有限集合"><node CREATED="1638264284748" ID="ID_8ea3b7a88b0f" MODIFIED="1638264284748" TEXT="1. 有向图，图的边是有方向的"></node><node CREATED="1638264284748" ID="ID_ae481122caff" MODIFIED="1638264284748" TEXT="2. 无向图，图的边没有方向"></node><node CREATED="1638264284748" ID="ID_5b6b02531d37" MODIFIED="1638264284748" TEXT="3. 完全图：图的任意两个点都有边相连"><node CREATED="1638264284748" ID="ID_bdee987d89e9" MODIFIED="1638264284748" TEXT="无向图边的条数：n*(n-1)/2"></node><node CREATED="1638264284748" ID="ID_a94a9e04824e" MODIFIED="1638264284748" TEXT="有向图边的条数：n*(n-1)"></node></node><node CREATED="1638264284748" ID="ID_1b82896c27c0" MODIFIED="1638264284748" TEXT="4.稀疏图和稠密图"><node CREATED="1638264284748" ID="ID_b39d4a93c26c" MODIFIED="1638264284748" TEXT="稀疏图：图的边数量很少&amp;lt;nlogn"></node><node CREATED="1638264284748" ID="ID_a111b5330f64" MODIFIED="1638264284748" TEXT="稠密图：图的边数量很多"></node></node><node CREATED="1638264284748" ID="ID_6fc9e7b4e348" MODIFIED="1638264284748" TEXT="5. 图的度：图的顶点相关联的边的数目&amp;lt;br&amp;gt;无向图中，一个顶点有几条边就是度多少&amp;lt;br&amp;gt;有向图中，分为出度和入度，出度和入度加起来是度"></node><node CREATED="1638264284748" ID="ID_9562c4bd0220" MODIFIED="1638264284748" TEXT="6. 图的路径：接续（连续的）边构成的顶点序列"></node><node CREATED="1638264284748" ID="ID_986855a99cce" MODIFIED="1638264284748" TEXT="7.连通图：在一个图中，任意两个顶点V,U都能找到连接他们的路径，那么这个图就是一个连通图，如果图是有向图的话，那称为强连通图"></node><node CREATED="1638264284749" ID="ID_24aba6857754" MODIFIED="1638264284749" TEXT="8. 子图：有如下G1和G两个图，如果有V1属于V，E1属于E，那么可以说G1属于G，G1是G的子图"></node></node></node><node CREATED="1638264284749" ID="ID_b31b8441f5c8" MODIFIED="1638264284749" TEXT="2. 图的存储方式"><node CREATED="1638264284749" ID="ID_19310ee4e5bb" MODIFIED="1638264284749" TEXT="1. 邻接矩阵表示法"><node CREATED="1638264284749" ID="ID_048d1be03de3" MODIFIED="1638264284749" TEXT="用一个二维数组，数组大小等于图的顶点个数的方阵。两个顶点之间有邻接关系，数组相应位置记为1，否则记为0&amp;lt;br&amp;gt;无向完全图的矩阵对角线为0，其余位置元素为1。无向图的邻接矩阵是一个对称矩阵&amp;lt;br&amp;gt;无向图的每一行或者每一列就代表对应元素的度"></node><node CREATED="1638264284749" ID="ID_7aae22780384" MODIFIED="1638264284749" TEXT="在有向图中，邻接矩阵不是对称矩阵了&amp;lt;br&amp;gt;每一行表示的是从这个顶点发出的边（出度）&amp;lt;br&amp;gt;每一列表示的是这个顶点接收的边（入度）&amp;lt;br&amp;gt;行的非0元素和+列的非0元素和=度"></node><node CREATED="1638264284749" ID="ID_e6c1ff12cfee" MODIFIED="1638264284749" TEXT="优缺点："><node CREATED="1638264284749" ID="ID_c11d6a3bf6c7" MODIFIED="1638264284749" TEXT="优点：简单、直观、便于理解&amp;lt;br&amp;gt;计算某个顶点的度十分的方便&amp;lt;br&amp;gt;便于判断两个顶点v1和v2之间是否有边"></node><node CREATED="1638264284749" ID="ID_f8da01b4aa6e" MODIFIED="1638264284749" TEXT="缺点：对图进行增加或者删除顶点的操作很麻烦&amp;lt;br&amp;gt;存储效率低，尤其是稀疏图，顶点多边少，很浪费计算机资源&amp;lt;br&amp;gt;创建图的算法时间复杂度高：O(n^2)"></node></node></node><node CREATED="1638264284749" ID="ID_106c81b69f64" MODIFIED="1638264284749" TEXT="2. 邻接表表示法"><node CREATED="1638264284749" ID="ID_24211d4363a4" MODIFIED="1638264284749" TEXT="类似于树的孩子链表表示法&amp;lt;br&amp;gt;首先需要一个数组，数组的元素是顶点和指针域&amp;lt;br&amp;gt;指针域指向与顶点相连的边结点&amp;lt;br&amp;gt;在邻接表中每个顶点后面带的链表，就是与该顶点相连的边"></node><node CREATED="1638264284749" ID="ID_1b3dfe8aeef2" MODIFIED="1638264284749" TEXT="在无向图中，邻接表的空间复杂度为O(n+2*e)&amp;lt;br&amp;gt;在有向图中，邻接表的空间复杂度为O(n+e)。其中表示表示有向图的出度的叫邻接表&amp;lt;br&amp;gt;表示有向图入度的叫逆邻接表。"></node><node CREATED="1638264284749" ID="ID_d40efbfe3458" MODIFIED="1638264284749" TEXT="优缺点："><node CREATED="1638264284749" ID="ID_4a5fed2b0a5c" MODIFIED="1638264284749" TEXT="优点：空间复杂度低，适合于稀疏图&amp;lt;br&amp;gt;便于图的增加和删除顶点&amp;lt;br&amp;gt;在无向图中便于查看每个顶点的度"></node><node CREATED="1638264284749" ID="ID_ca76d5006761" MODIFIED="1638264284749" TEXT="缺点：不便于查看两个顶点v1和v2之间是否有边&amp;lt;br&amp;gt;对于有向图，不便于统计每一个顶点的度。因为需要构造逆邻接表"></node></node></node><node CREATED="1638264284749" ID="ID_ae61220798ba" MODIFIED="1638264284749" TEXT="3. 十字链表表示法"><node CREATED="1638264284749" ID="ID_b7472181d834" MODIFIED="1638264284749" TEXT="解决了有向图在邻接表表示时，顶点度的统计不便问题"></node></node><node CREATED="1638264284749" ID="ID_17cef6f34ae8" MODIFIED="1638264284749" TEXT="4. 邻接多重表表示法"><node CREATED="1638264284749" ID="ID_81c6723cef8a" MODIFIED="1638264284749" TEXT="解决了无向图在邻接表表示时，每一个边要被保存两次，会带来操作上的不便（例如删除边，要去找到重复的这两个边）"></node></node></node><node CREATED="1638264284749" ID="ID_ed301f598217" MODIFIED="1638264284749" TEXT="3. 图的遍历方式"><node CREATED="1638264284749" ID="ID_895569353b15" MODIFIED="1638264284749" TEXT="1. 深度优先遍历算法"><node CREATED="1638264284749" ID="ID_a6f5228eb967" MODIFIED="1638264284749" TEXT="邻接矩阵"><node CREATED="1638264284749" ID="ID_f67a3fe8a4e1" MODIFIED="1638264284749" TEXT="时间复杂度：O(n^2)"></node><node CREATED="1638264284749" ID="ID_29605bc11f44" MODIFIED="1638264284749" TEXT="空间复杂度O(n)"></node></node><node CREATED="1638264284749" ID="ID_896d91f5c59a" MODIFIED="1638264284749" TEXT="邻接表"><node CREATED="1638264284749" ID="ID_efe2d2945671" MODIFIED="1638264284749" TEXT="时间复杂度：O(n+e)"></node><node CREATED="1638264284749" ID="ID_6f8265558fb7" MODIFIED="1638264284749" TEXT="空间复杂度O(n)"></node></node></node><node CREATED="1638264284749" ID="ID_ff8823e6e473" MODIFIED="1638264284749" TEXT="2.广度优先遍历算法"><node CREATED="1638264284749" ID="ID_c12fb842d36c" MODIFIED="1638264284749" TEXT="邻接矩阵"><node CREATED="1638264284749" ID="ID_6360d4a810f3" MODIFIED="1638264284749" TEXT="时间复杂度：O(n^2)"></node><node CREATED="1638264284749" ID="ID_fc62fecdbcc8" MODIFIED="1638264284749" TEXT="空间复杂度O(n)"></node></node><node CREATED="1638264284749" ID="ID_0347ab8405a0" MODIFIED="1638264284749" TEXT="邻接表"><node CREATED="1638264284749" ID="ID_9b07bf228b3a" MODIFIED="1638264284749" TEXT="时间复杂度：O(n+e)"></node><node CREATED="1638264284749" ID="ID_4dbb89d5135b" MODIFIED="1638264284749" TEXT="空间复杂度O(n)"></node></node></node></node><node CREATED="1638264284749" ID="ID_206e3a3605ee" MODIFIED="1638264284749" TEXT="4. 最小生成树"><node CREATED="1638264284749" ID="ID_3cc4445b6c2f" MODIFIED="1638264284749" TEXT="1. prim算法"><node CREATED="1638264284749" ID="ID_8d03341d6b02" MODIFIED="1638264284749" TEXT="该算法就像是一条蛇一样，每一次都从&amp;lt;已选顶点&amp;gt;和&amp;lt;未选顶点&amp;gt;中选择权重最小的一条边，连接成新的图"><node CREATED="1638264284749" ID="ID_3bb58b00a329" MODIFIED="1638264284749" TEXT="算法时间复杂度O(n^2)"></node><node CREATED="1638264284749" ID="ID_548a44484819" MODIFIED="1638264284749" TEXT="适合稠密图"></node></node></node><node CREATED="1638264284749" ID="ID_f0fd31da68b6" MODIFIED="1638264284749" TEXT="2. Kruskal算法"><node CREATED="1638264284749" ID="ID_c5664e4a4e90" MODIFIED="1638264284749" TEXT="该算法是把图的边按照权重大小排序，在保证不会连接成环的情况下，依次选择最小的边，当边数=n-1或者图已经连通了，这个算法就可以终止了"><node CREATED="1638264284749" ID="ID_1ae34fdaff9f" MODIFIED="1638264284749" TEXT="算法时间复杂度O(eloge)"></node><node CREATED="1638264284749" ID="ID_f7b1ddcdf6e8" MODIFIED="1638264284749" TEXT="适合稀疏图"></node></node></node></node><node CREATED="1638264284749" ID="ID_b236d9bf2b76" MODIFIED="1638264284749" TEXT="5. 最短路径"><node CREATED="1638264284749" ID="ID_75f973efcf9f" MODIFIED="1638264284749" TEXT="地图线路规划问题，哪一条路时间最短最快"></node><node CREATED="1638264284749" ID="ID_a4de9fc2d565" MODIFIED="1638264284749" TEXT="1. dijkstra算法"></node></node><node CREATED="1638264284749" ID="ID_7a7f9a19a170" MODIFIED="1638264284749" TEXT="6. 拓扑排序"></node><node CREATED="1638264284749" ID="ID_1bae63044687" MODIFIED="1638264284749" TEXT="7. 关键路径"></node></node></node><node CREATED="1638264284749" ID="ID_e937a2f32964" POSITION="right" MODIFIED="1638264284749" TEXT="3. 算法"><node CREATED="1638264284749" ID="ID_c7d7d875874c" MODIFIED="1638264284749" TEXT="1. 查找"><node CREATED="1638264284749" ID="ID_0ee218edf912" MODIFIED="1638264284749" TEXT="1. 基础知识"><node CREATED="1638264284749" ID="ID_d363e159509c" MODIFIED="1638264284749" TEXT="1. 查找算法是在什么数据结构上作查找？"><node CREATED="1638264284749" ID="ID_2059982091d6" MODIFIED="1638264284749" TEXT="散列表，也叫查找表&amp;lt;br&amp;gt;这是一种新的数据结构，也是数据元素的有限集合，不过各元素之间的关系比较松散，没有太多严格的限制"></node></node><node CREATED="1638264284749" ID="ID_e1f5f1aa2525" MODIFIED="1638264284749" TEXT="2. 什么是查找"><node CREATED="1638264284749" ID="ID_428b060c363c" MODIFIED="1638264284749" TEXT="也就是我们给定一个值，在查找表上找到对应的数据元素内容或者记录"></node></node><node CREATED="1638264284749" ID="ID_3de8c470de2b" MODIFIED="1638264284749" TEXT="3. 基础概念"><node CREATED="1638264284749" ID="ID_2e04a8f03f19" MODIFIED="1638264284749" TEXT="1. 关键字：用于标识一个数据元素某个数据项的值"><node CREATED="1638264284749" ID="ID_cadf0f238d5d" MODIFIED="1638264284749" TEXT="1. 主关键字：通过关键字只能唯一的标识一个数据元素"></node><node CREATED="1638264284749" ID="ID_981940efa852" MODIFIED="1638264284749" TEXT="2. 次关键字：通过关键字标识的数据元素不止一个"></node></node><node CREATED="1638264284749" ID="ID_3d223ac408c0" MODIFIED="1638264284749" TEXT="2. ASL（平均查找长度））：关键字的平均比较次数"></node><node CREATED="1638264284749" ID="ID_07d9212d62be" MODIFIED="1638264284749" TEXT="3. 查找表的分类"><node CREATED="1638264284749" ID="ID_0048dbdf799d" MODIFIED="1638264284749" TEXT="1. 静态查找表：只对查找表作查询和遍历操作，不会改变查找表，这时使用静态查找表（const）"></node><node CREATED="1638264284749" ID="ID_3b2db853e803" MODIFIED="1638264284749" TEXT="2. 动态查找表：对查找表要进行增删改的操作，会改变查找表"></node></node></node></node><node CREATED="1638264284749" ID="ID_0b1ebc9ada10" MODIFIED="1638264284749" TEXT="2. 查找算法"><node CREATED="1638264284749" ID="ID_167aacd78785" MODIFIED="1638264284749" TEXT="1. 线性表的查找算法"><node CREATED="1638264284749" ID="ID_fcb861d66d0e" MODIFIED="1638264284749" TEXT="1. 顺序查找法"><node CREATED="1638264284749" ID="ID_f3d382a3cd14" MODIFIED="1638264284749" TEXT="1. 查找对象：顺序表（链表也是一个道理）"></node><node CREATED="1638264284749" ID="ID_ff4f19be525a" MODIFIED="1638264284749" TEXT="2. 优缺点"><node CREATED="1638264284749" ID="ID_e7d1152df00e" MODIFIED="1638264284749" TEXT="1. 优点：算法简单，对数据的逻辑结构没有太多要求，对大多数数据结构都适用"></node><node CREATED="1638264284749" ID="ID_e839439f9682" MODIFIED="1638264284749" TEXT="2. 缺点：ASL过长(n+1)/2，时间效率低"></node></node></node><node CREATED="1638264284749" ID="ID_b4b5f8e61dd8" MODIFIED="1638264284749" TEXT="2. 二分（折半查找）"><node CREATED="1638264284749" ID="ID_5202d95e532e" MODIFIED="1638264284749" TEXT="1. 查找对象：顺序结构"></node><node CREATED="1638264284749" ID="ID_f8219755f590" MODIFIED="1638264284749" TEXT="2. 优缺点"><node CREATED="1638264284749" ID="ID_16838bc5620e" MODIFIED="1638264284749" TEXT="1. 优点：算法简单，时间效率高O(log2(n))，ASL低log2(n+1)-1(n&amp;gt;50)"></node><node CREATED="1638264284749" ID="ID_39cfa1478f32" MODIFIED="1638264284749" TEXT="2. 缺点：数据结构必须得是顺序结构；表中的元素事前要进行排序"></node></node><node CREATED="1638264284749" ID="ID_a9c75450300d" MODIFIED="1638264284749" TEXT="判定树"><node CREATED="1638264284749" ID="ID_3d1634b8af24" MODIFIED="1638264284749" TEXT="用一颗二叉树表示顺序表中每个元素的查找的程序执行次数"></node></node></node><node CREATED="1638264284749" ID="ID_eec10072085c" MODIFIED="1638264284749" TEXT="3. 分块查找算法"><node CREATED="1638264284749" ID="ID_f960f6f33d10" MODIFIED="1638264284749" TEXT="分块查找的思想类似于小时候使用的新华字典&amp;lt;br&amp;gt;先对关键字进行分块的查找，确定关键在哪一个大致的范围内&amp;lt;br&amp;gt;再从那一个小范围内继续查找&amp;lt;br&amp;gt;第一步确定分块采用的是二分查找，第二步在分块内查找用的是顺序查找"></node><node CREATED="1638264284749" ID="ID_15c044a008ba" MODIFIED="1638264284749" TEXT="优缺点："><node CREATED="1638264284749" ID="ID_4c5f461b6f98" MODIFIED="1638264284749" TEXT="1. 优点：查找效率还是蛮高的，至少是比顺序查找要高的&amp;lt;br&amp;gt;由于数据本身可以采用链表存储，因为插入和删除比较方便&amp;lt;br&amp;gt;"></node><node CREATED="1638264284749" ID="ID_fd55a7856561" MODIFIED="1638264284749" TEXT="2. 缺点：要单独建一个索引的表，并且要对索引表进行排序&amp;lt;br&amp;gt;"></node></node></node></node><node CREATED="1638264284749" ID="ID_03eefbe17c30" MODIFIED="1638264284749" TEXT="2. 二叉树的查找算法"><node CREATED="1638264284749" ID="ID_4d8bdaaf8961" MODIFIED="1638264284749" TEXT="1. 补充点基础知识"><node CREATED="1638264284749" ID="ID_dc07e052e3fe" MODIFIED="1638264284749" TEXT="1. 什么是二叉排序树"><node CREATED="1638264284749" ID="ID_3e9da0a1937f" MODIFIED="1638264284749" TEXT="二叉排序树是指：&amp;lt;br&amp;gt;二叉树的左子树的所有元素的值都小于根结点，&amp;lt;br&amp;gt;右子树的元素大于等于根结点&amp;lt;br&amp;gt;左子树和右子树又是一颗二叉树"></node><node CREATED="1638264284749" ID="ID_7dd582dd9835" MODIFIED="1638264284749" TEXT="对二叉排序树进行中序遍历，便能得到一个按照关键字排序的递增序列"></node></node></node><node CREATED="1638264284749" ID="ID_5c5fb4ec3dd9" MODIFIED="1638264284749" TEXT="2. 基于二叉搜索树的查找算法"><node CREATED="1638264284749" ID="ID_43ce09f91f47" MODIFIED="1638264284749" TEXT="1. 二叉搜索树本质上还是一个二叉树的遍历，遍历方式是DLR先序遍历"></node><node CREATED="1638264284749" ID="ID_cb8cf8d6584b" MODIFIED="1638264284749" TEXT="时间复杂度：时间复杂度与二叉树的形态有关？&amp;lt;br&amp;gt;如果二叉搜索树的形态是判定树，即树的深度为log2n+1，那么二叉搜索树的查找时间复杂度O(log2n)&amp;lt;br&amp;gt;但是，如果二叉搜索树根结点的元素是最小的元素，那么二叉树会退化成一个全是右孩子的树，其查找变成了顺序查找O(n)&amp;lt;br&amp;gt;因此，如果二叉排序树形态不好，就会影响我们查找的效率，因此我们要将二叉排序树转化成平衡二叉树"><arrowlink DESTINATION="ID_68029dc9a199" ENDARROW="Default" ID="Arrow_ID_33d571445ab3" STARTARROW="None"/></node></node><node CREATED="1638264284749" ID="ID_68029dc9a199" MODIFIED="1638264284749" TEXT="3. AVL平衡二叉树"><linktarget COLOR="#b0b0b0" DESTINATION="ID_68029dc9a199" ENDARROW="Default" ID="Arrow_ID_33d571445ab3" SOURCE="ID_cb8cf8d6584b" STARTARROW="None"/><node CREATED="1638264284749" ID="ID_7313447dccb2" MODIFIED="1638264284749" TEXT="1. 平衡二叉树的定义"><node CREATED="1638264284749" ID="ID_aca4c9df72a5" MODIFIED="1638264284749" TEXT="一颗非空具有如下特征的二叉排序树：&amp;lt;br&amp;gt;(1 )左子树和右子树的深度之差的绝对值不超过1;&amp;lt;br&amp;gt;(2)左子树和右子树也是平衡二叉树。&amp;lt;br&amp;gt;就可以称作平衡二叉树"></node></node><node CREATED="1638264284749" ID="ID_e43185920e94" MODIFIED="1638264284749" TEXT="2. 4种非平衡二叉树的调整"><node CREATED="1638264284749" ID="ID_9b1387dbcbb1" MODIFIED="1638264284749" TEXT="L_L型"></node><node CREATED="1638264284749" ID="ID_6d1d275674fd" MODIFIED="1638264284749" TEXT="L_R型"></node><node CREATED="1638264284749" ID="ID_944191f47cd9" MODIFIED="1638264284749" TEXT="R_L型"></node><node CREATED="1638264284749" ID="ID_998f96fe60b6" MODIFIED="1638264284749" TEXT="R_R型"></node><node CREATED="1638264284749" ID="ID_dff70f9fb78b" MODIFIED="1638264284749" TEXT="在生成二叉排序树的时候，如果存在某个结点的平衡因子绝对值大于1，那么就需要对该结点的树进行调整，&amp;lt;br&amp;gt;如果有多个结点都出现该情况，我们只需要去调整最小的失衡二叉树即可将整棵树调整好"></node></node></node></node><node CREATED="1638264284749" ID="ID_7cbd0431ebbd" MODIFIED="1638264284749" TEXT="3. 基于散列表的查找算法"><node CREATED="1638264284749" ID="ID_132a818a8521" MODIFIED="1638264284749" TEXT="1. 什么是散列表"><node CREATED="1638264284749" ID="ID_3bc61bb49450" MODIFIED="1638264284749" TEXT="1.散列表是一种存储结构，其元素的存储位置是通过一个散列函数（Hash函数）将元素的关键值与存储位置形成一个映射"></node><node CREATED="1638264284749" ID="ID_77d761c8daf6" MODIFIED="1638264284749" TEXT="2. 常用的Hash函数"><node CREATED="1638264284749" ID="ID_81680f185fbd" MODIFIED="1638264284749" TEXT="1. 除留余数法：用元素的关键值除以一个数m，m通常小于等于要存放的数的元素个数，常记作：H(k)=key mod m"></node><node CREATED="1638264284749" ID="ID_645202590e76" MODIFIED="1638264284749" TEXT="2. 直接定址法：用元素关键值除以一个系数得到除数，常记作 H(k)=key/a+b"></node><node CREATED="1638264284749" ID="ID_096a5714d8b9" MODIFIED="1638264284749" TEXT="3. 数字分析法"></node><node CREATED="1638264284749" ID="ID_c4e39fde8e26" MODIFIED="1638264284749" TEXT="4. 平方取中法"></node><node CREATED="1638264284750" ID="ID_4a4d92f82958" MODIFIED="1638264284750" TEXT="5. 折叠法"></node></node></node><node CREATED="1638264284750" ID="ID_5a5ef4d18a16" MODIFIED="1638264284750" TEXT="2. 散列表存储时的冲突问题"><node CREATED="1638264284750" ID="ID_13b5354152da" MODIFIED="1638264284750" TEXT="1. 为什么会产生冲突？元素关键字通过哈希函数生成的存储地址有可能会发生重叠，同一位置有多个元素要存放，这便是冲突，如何解决冲突？"></node><node CREATED="1638264284750" ID="ID_b1554a0ffeab" MODIFIED="1638264284750" TEXT="2. 解决冲突的方式："><node CREATED="1638264284750" ID="ID_5053d2006f94" MODIFIED="1638264284750" TEXT="1. 开放地址法&amp;lt;br&amp;gt;开放地址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字 key的初始散&amp;lt;br&amp;gt;列地址H0=H(key)发生冲突时，以H0为基础 ，采取合适方法计算得到另一个地址H1,, 如果H1仍&amp;lt;br&amp;gt;然发生冲突，以H1为基础再求下一个地址H2，若H2仍然冲突，再求得H3。依次类推，直至Hk&amp;lt;br&amp;gt;不发生冲突为止，则Hk为该记录在表中的散列地址。&amp;lt;br&amp;gt;"><node CREATED="1638264284750" ID="ID_b995eb8b3064" MODIFIED="1638264284750" TEXT="1. 线性探测法：如果存放位置有冲突，探索该位置的下一个地址，以此类推"></node><node CREATED="1638264284750" ID="ID_578084bf9dcb" MODIFIED="1638264284750" TEXT="2. 二次探测法：以1^2, -1^2, 2^2, -2^2依次往下探测"></node><node CREATED="1638264284750" ID="ID_658f77e6bb78" MODIFIED="1638264284750" TEXT="3. 伪随机探测法"></node></node><node CREATED="1638264284750" ID="ID_37f139d3fb2e" MODIFIED="1638264284750" TEXT="2. 链地址法&amp;lt;br&amp;gt;链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链&amp;lt;br&amp;gt;表。有 m 个散列地址就有 m 个单链表，同时用数组 HT[O…m-1]存放各个链表的头指针，凡是&amp;lt;br&amp;gt;散列地址为 l 的记录都以结点方式插入到以 HT[i]为头结点的单链表中。&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1638264284750" ID="ID_7303e5897599" MODIFIED="1638264284750" TEXT="3. 散列表的查找"><node CREATED="1638264284750" ID="ID_44718da6623b" MODIFIED="1638264284750" TEXT="散列表的查找其实就是散列表的生成过程"><node CREATED="1638264284750" ID="ID_1a1dfea409e2" MODIFIED="1638264284750" TEXT="散列表查找性能分析"><node CREATED="1638264284750" ID="ID_52f0bf7785f6" MODIFIED="1638264284750" TEXT="1. 散列函数（Hash函数）"></node><node CREATED="1638264284750" ID="ID_8d8912682411" MODIFIED="1638264284750" TEXT="2. 冲突解决方法"><node CREATED="1638264284750" ID="ID_b275cf0223ba" MODIFIED="1638264284750" TEXT="链地址解决冲突要比开放地址法好"></node></node><node CREATED="1638264284750" ID="ID_9d362ed21e86" MODIFIED="1638264284750" TEXT="3.装填因子=表中填入元素的个数/散列表的长度。直观的来说，装填因子越小，一般发生冲突的可能性也就越小"></node></node></node></node></node></node></node><node CREATED="1638264284750" ID="ID_1bf98d715f00" MODIFIED="1638264284750" TEXT="2. 排序"><node CREATED="1638264284750" ID="ID_40be85dd6774" MODIFIED="1638264284750" TEXT="1. 插入排序"><node CREATED="1638264284750" ID="ID_75a9c6823556" MODIFIED="1638264284750" TEXT="1. 用顺序查找法确定插入位置：直接插入排序"><node CREATED="1638264284750" ID="ID_21d95130d540" MODIFIED="1638264284750" TEXT="1. 将第一个还没有排序的元素与它之前已经排好的那部分序列，从有序序列的后面开始，依次比较，直到找到第一个小于该元素的元素，在这个小元素的后面插入"></node><node CREATED="1638264284750" ID="ID_56aee9028e8a" MODIFIED="1638264284750" TEXT="2. 时间复杂度：O(n^2)，空间复杂度：O(1)"></node></node><node CREATED="1638264284750" ID="ID_6281a393b31e" MODIFIED="1638264284750" TEXT="2. 用二分查找法确定插入位置：二分插入排序"><node CREATED="1638264284750" ID="ID_792147ff3007" MODIFIED="1638264284750" TEXT="1. 将第一个还未排序的元素，在它之前的有序序列中，进行二分查找，二分查找会不断的缩小比较区间，直至缩小到只有一个元素的区间，该元素的位置+1就是未排元素的插入位置"></node><node CREATED="1638264284750" ID="ID_fab290c879a5" MODIFIED="1638264284750" TEXT="2. 时间复杂度：O(n^2)，空间复杂度：O(1)"></node><node CREATED="1638264284750" ID="ID_627aa252aa2f" MODIFIED="1638264284750" TEXT="3. 二分插入要比直接插入在平均时间效率上好一点。&amp;lt;br&amp;gt;只能比较平均时间效率，因为直接插入排序最好情况是O(n)，最好的ASL=1最差情况是O(n^2)，最坏的ASL=i-1&amp;lt;br&amp;gt;但是二分插入排序的ASL都是||log2i||+1，所以只能比较平均时间效率"></node></node><node CREATED="1638264284750" ID="ID_2ad04e4016f8" MODIFIED="1638264284750" TEXT="3. 缩小增量，多遍插入排序：希尔排序&amp;lt;br&amp;gt;"><node CREATED="1638264284750" ID="ID_0e0b7d74740b" MODIFIED="1638264284750" TEXT="1. 设置一个增量序列，让待排元素按照一个特定的值分组进行排序，不断减小分组的间隔，最后就能得到一个排好序的序列"></node><node CREATED="1638264284750" ID="ID_4c231e9d5989" MODIFIED="1638264284750" TEXT="2. 时间复杂度：没有严格的数学证明，但是猜想为O(n^1.25)~1.6O(n^1.25)之间&amp;lt;br&amp;gt;"></node><node CREATED="1638264284750" ID="ID_ea28b113c9cb" MODIFIED="1638264284750" TEXT="3. 希尔排序是一种不稳定的排序，直接插入排序和二分插入排序都是稳定的排序"></node></node></node><node CREATED="1638264284750" ID="ID_da9a42120225" MODIFIED="1638264284750" TEXT="2. 交换排序"><node CREATED="1638264284750" ID="ID_4bbc10c79456" MODIFIED="1638264284750" TEXT="1. 冒泡排序"><node CREATED="1638264284750" ID="ID_fe56f5fb560a" MODIFIED="1638264284750" TEXT="冒泡排序不多说了，学C语言的时候就已经学过了"></node><node CREATED="1638264284750" ID="ID_9f01187b3565" MODIFIED="1638264284750" TEXT="时间复杂度：O(n^2)，空间复杂度：O(1)"></node></node><node CREATED="1638264284750" ID="ID_412af67ca99e" MODIFIED="1638264284750" TEXT="2. 快速排序"><node CREATED="1638264284750" ID="ID_854a4eb4aa6a" MODIFIED="1638264284750" TEXT="原理讲起来有些复杂，不过基本思想类似于二叉树的遍历，都是要使用递归函数来解决问题。简单来说，是在无序序列中找一个中枢点，将小于中枢点的放在中枢点左边，大于中枢点的放在中枢点右边，再对中枢点左边的重复刚刚那个步骤，再对右边的重复那个步骤。。。一直持续下去，直到无序序列长度为1，"></node><node CREATED="1638264284750" ID="ID_e83f0aa46edb" MODIFIED="1638264284750" TEXT="时间复杂度：O(nlogn)，空间复杂度O(nlogn)"></node><node CREATED="1638264284750" ID="ID_ab948c7711e8" MODIFIED="1638264284750" TEXT="快速排序不是一种稳定的排序方式。其次，快速排序不适用于有一定顺序的序列，否则快排将会退化成冒泡排序，因此，序列越乱，使用快速排序的效果越好"></node></node></node><node CREATED="1638264284750" ID="ID_2fb128d3b8e5" MODIFIED="1638264284750" TEXT="3. 选择排序"><node CREATED="1638264284750" ID="ID_91bc10e92543" MODIFIED="1638264284750" TEXT="1. 直接选择排序"><node CREATED="1638264284750" ID="ID_583e81cb9b4c" MODIFIED="1638264284750" TEXT="算法思路很简单，每次从序列中拿出一个最小值，依次往复，就能排好序"></node><node CREATED="1638264284750" ID="ID_c1e05f899ba9" MODIFIED="1638264284750" TEXT="时间复杂度：O(n^2)，空间复杂度：O(1)"></node><node CREATED="1638264284750" ID="ID_974be2128cb0" MODIFIED="1638264284750" TEXT="直接选择排序不是一个稳定的算法"></node></node><node CREATED="1638264284750" ID="ID_af2b2c5b6503" MODIFIED="1638264284750" TEXT="2. 堆排序"><node CREATED="1638264284750" ID="ID_94160a69ec7b" MODIFIED="1638264284750" TEXT="1. 什么是堆"><node CREATED="1638264284750" ID="ID_733bce872311" MODIFIED="1638264284750" TEXT="堆分为大根堆和小根堆&amp;lt;br&amp;gt;大根堆是指，对于一个完全二叉树，其每一个结点的值大于结点孩子的值&amp;lt;br&amp;gt;小根堆和大根堆的比较相反，结点小于孩子的值"></node></node><node CREATED="1638264284750" ID="ID_185023f08c25" MODIFIED="1638264284750" TEXT="2. 如何由无序序列创建一个堆"><node CREATED="1638264284750" ID="ID_c27ab3730b0b" MODIFIED="1638264284750" TEXT="首先，我们是用一个顺序存储结构保存这个完全二叉树，完全二叉树的双亲和孩子是通过下标位置联系再一起的（双亲i，左孩子2i，右孩子2i+1）&amp;lt;br&amp;gt;先把无序序列依次保存在顺序存储结构中&amp;lt;br&amp;gt;然后从完全二叉树的最后一个非叶子结点开始，比较结点的值和孩子的值，让结点值交换成最小的值，每次交换要一直延续到叶子结点&amp;lt;br&amp;gt;重复上面的过程，一直到根结点"></node></node><node CREATED="1638264284750" ID="ID_189c446d6be4" MODIFIED="1638264284750" TEXT="3. 有了堆之后，如何输出有序序列"><node CREATED="1638264284750" ID="ID_e7e03b03ba61" MODIFIED="1638264284750" TEXT="先输出完全二叉树的顶点的值，然后完全二叉树变成了两个树，再将这两个树重新建立成新的堆的完全二叉树，在输出顶点，再建二叉树，循环往复直到最后一个结点"></node></node></node></node><node CREATED="1638264284750" ID="ID_c62cef98b10c" MODIFIED="1638264284750" TEXT="4. 归并排序"><node CREATED="1638264284750" ID="ID_46c2f6147572" MODIFIED="1638264284750" TEXT="自底向上的归并排序：归并排序的思想：用单个元素的序列开始，两两一对排序形成新序列，再把两个元素的序列两两组成一对，再排序，形成四个有序元素的序列，一直这样循环往复，逐渐得到一个完整的有序序列"></node><node CREATED="1638264284750" ID="ID_c0c7128b4257" MODIFIED="1638264284750" TEXT="自顶而下的归并排序：使用递归思想，分而治之，将大数组的排序分成若干个小数组的排序，再把这些小数组重新合并成一个打的大的有序数组"></node><node CREATED="1638264284750" ID="ID_a2ea6cd95195" MODIFIED="1638264284750" TEXT="自顶而下是把整打撒成零、自底向上是把零归纳成整。两者方向相反，但是还是有共同之处。掌握了一个就能反推另一个。"></node></node><node CREATED="1638264284750" ID="ID_d3613c3fd480" MODIFIED="1638264284750" TEXT="5. 基数排序（桶排序）"><node CREATED="1638264284750" ID="ID_09fb49713b8d" MODIFIED="1638264284750" TEXT="子主题"></node></node><node CREATED="1638264284750" ID="ID_ce26c414a5e7" MODIFIED="1638264284750"></node></node></node></node></map>