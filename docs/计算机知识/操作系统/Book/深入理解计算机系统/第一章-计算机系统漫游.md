# 第一章-计算机系统漫游

## 源程序是如何存储的

hello.c源程序：

```c
#include <stdio.h>
int main()
{
	printf("hello,world\n");
	return 0;
}
```

源程序实际上就是一个由值**0和1组成的位（又称为比特）序列**，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。现代计算机都使用ASCII标准来表示文本字符。

![image-20201019170810469](resource/img/5dc51782311536841956d32463ab22c3.png)

hello.c程序是以**字节序列**的方式储存在文件中的。

hello.c的表示方法说明了一个基本思想：系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是**由一串比特表示的**。区分不同数据对象的唯一方法是我们读到这些数据对象的**上下文**。

## 编译过程

![s20130823152815265](resource/img/20130823152815265.png)

### 预编译

1、处理所有的注释，以空格代替

2、将所有#define删除，并展开所有宏定义，字符串替换

3、处理条件编译指令#if，#ifdef，#elif，#else，#endif

4、处理#include，并展开被包含的文件，把头文件中的声明，全部拷贝到文件中。

5、保留编译器需要使用的#pragma指令

如何观察变化：输入预处理指令，可以看看不同文件经过预处理后变成什么样了，预处理指令：`gcc -E file.c -o file.i`  注意：-C -E一起使用是预编译的时候保留注释。

### 编译

1、对预处理文件进行一系列词法分析，语法分析和语义分析

-  词法分析：主要分析关键字，标示符，立即数等是否合法
-  语法分析：主要分析表达式是否遵循语法规则
-  语义分析：在语法分析的基础上进一步分析表达式是否合法

2、分析结束后进行代码优化生成相应的汇编代码文件，编译指令：`gcc -S file.c -o file.s`

### 汇编

汇编器将汇编代码转变为机器可以执行的指令，每个汇编语句几乎都对应一条机器指令，其实机器指令就是机器码，就是2进制码。

汇编指令：`gcc -c file.c -o file.o` 注意：-c是编译汇编不连接。

### 链接

再把产生的.o文件，进行链接就可以生成可执行文件。连接指令：`gcc file.o file1.o -o file` 这句指令是链接file.o和file1.o两个编译并汇编的文件，并生成可执行文件file。

链接分两种：**静态链接和动态链接**，静态链接是在编译器完成的，动态链接是在运行期完成的。静态链接的指令是：`gcc -static file.c -o file`对于一些没有动态库的嵌入式系统，这是常用的。

一般要想通过一条指令生成可执行文件的指令是：  `gcc file.c -o file`

## shell是什么

shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。

如果该命令行的第一个单词不是一个内置的shell命令，那么 shell就会假设这是个可执行文件的名字，它将加载并运行这个文件。

## 系统的硬件组成

![img](resource/img/4b0330999b13bb8eaa5aade03ed3055c.png)

![image-20241005232003091](resource/img/image-20241005232003091.png)

### CPU

中央处理单元（CPU），简称处理器，是执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，**PC都指向主存中的某条机器语言指令**（即含有该条指令的地址）。

处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PCÿ 使其指向下一条指令，
而这条指令并不一定和在内存中刚刚执行的指令相邻。

这样的简单操作并不多，它们围绕着主存、寄存器文件（register file)和算术/逻辑单元(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个
寄存器都有唯一的名字。ALU 计算新的数据和地址值。

CPU可能执行以下这些操作：

- 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容
- 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容
- 操作：把两个寄存器的内容复制到ALU, ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容
- 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖
  PC 中原来的值

### Main memory

主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

- 从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。
- 从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C 程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux 的X86-64 机器上，short 类型的数据
需要2 个字节，int 和float 类型需要4 个字节，而long 和double 类型需要8 个宇节。

### IO device

I/O(输入/输出）设备是系统与外部世界的联系通道。

- 输入：鼠标、键盘
- 输出：显示器、用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘）。最开始，可执行程序hello 就存放在磁盘上。

每个I/O 设备都通过一个控制器或适配器与I/O 总线相连，功能是在I/O总线和I/O设备之间传递信息。（控制器或适配器在于封装方式不同）

- 控制器是I/O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组
- 适配器则是一块插在主板插槽上的卡

### 总线

贯穿整个系统的是一组**电子通道**，称作总线。通常总线中传输的是**固定长度的字节块**，也就是字（word）。字中的字节数（字长）是一个基本的**系统参数**。不同系统字长不同。比如32位系统的字长为4个字节，64位系统的字长为8个字节。

## 运行helloc程序

shell读取到我们从键盘输入的“./hello”后，计算机中的信息流向如下图红线所示：

键盘->USB控制器->I/O总线->I/O桥->系统总线->寄存器

寄存器->系统总线->I/O桥->内存总线->主存

shell程序需要把用户输入的内容作为一个变量使用，而这个变量一定在内存中有个地址，所以它最终会到达内存。

![image-20201019191356753](resource/img/3b8b8ecc8260fd07d66d8a0cd65e54a8.png)

当我们在键盘上敲回车键时， shell程序就知道我们已经结束了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的**代码和数据从磁盘复制到主存**。数据包括最终会被输出的字符串“ hello,world\n”。信息流向如下所示。

![image-20201019191522808](resource/img/6ff4a9a6683a160b88d2cbc5d8adfed7.png)

加载完hello文件后，CPU将会开始从hello程序的主函数处执行指令。这些指令将“hello,world\n”**字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备**，最终显示在屏幕上。信息流向如下图所示。

主存->寄存器->系统总线->I/O桥->I/O总线->图形适配器->显示器

![image-20201019191644207](resource/img/233e0942cc072801da759fffba06ebdd.png)

## 高速缓存

通过运行hello程序，我们可以知道，指令和数据需要多次在寄存器、主存、磁盘之间来回复制，这些复制其实就是开销，减慢了程序工作的速度。这个时候我们就需要**高速缓存存储器**（cache memory）来解决这个问题。

![image-20201019195237101](resource/img/c23d46f5835401fb4e6d77a0f53d0ded.png)

![image-20241005233918162](resource/img/image-20241005233918162.png)

L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。

L2高速缓存容量为数十万到数百万字节，通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5~10倍。

L1和L2高速缓存是用一种叫做 静态随机访问存储器（SRAM） 的硬件技术实现的。

**高速缓存局部性原理**：程序具有访问局部区域中的数据和代码的趋势。因此，高速缓存存储器作为**暂时的**集结区域，存放处理器**近期可能会需要的信息**。

![image-20241005234358653](resource/img/image-20241005234358653.png)

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，
寄存器文件就是L1 的高速缓存，L1 是L2 的高速缓存，L2 是L3 的高速缓存，L3 是主存
的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本
地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整
个存储器层次结构的理解来提高程序性能。





