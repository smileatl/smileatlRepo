# 第三章-程序的机器级表示

![image-20250111174958060](resource/img/image-20250111174958060.png)

英特尔处理器发展历史：

![image-20250111175120077](resource/img/image-20250111175120077.png)

![image-20250111190252523](resource/img/image-20250111190252523.png)

其中编译选项-Og是用来告诉编译器生成符合原始C代码整体结构的机器代码。

在实际的项目，为了获得更高的编译性能，会使用-O1或-O2，甚至更高级别的编译选项。但是使用高级别的优化产生的代码会严重变形，导致产生的机器代码与最初的源代码之间的关系难以理解。

![image-20250111193437207](resource/img/image-20250111193437207.png)

其中以”.”开头的行都是指导汇编器和链接器工作的伪指令.

- pushq 这条指令的意思是将寄存器rbx的值压人程序栈进行保存，在使用pop指令，恢复寄存器rbx的内容。寄存器rbx是被调用者保存寄存器。
- 第二行汇编代码的含义是将寄存器rdx的内容复制到寄存器rbx，这条指令执行结束后，寄存器rbx与寄存器rdx的内容一致，都是dest指针所指向的内存地址。mov指分的后缀“q”表示数据的大小
- call指分对应于C代码中的医数调用，这一行代码比较容易理解。该函数的返回值会保存到寄存器rax中。因此寄存器rax中保存了x和y的乘积结果。 
- 下一条指分将寄存器rax的值送到内存中。**内存的地址就存放在寄存器rbx中**
- 最后一条指令ret就是函数返回

函数的三个入参分别保存在寄存器rdi, rsi和 rdx中

![image-20250111192806363](resource/img/image-20250111192806363.png)

Intel用字（word）来表示16位的数据类型。所以，32位的数据类型称为双字，64位的数据类型就称为四字。所以，32位的数据类型称为双字，64位的数据类型就称为四字。大多数GCC生成的汇编指分都有一个字符后缀来表示操作数的大小。 

![image-20250111193051007](resource/img/image-20250111193051007.png)

move有四个变种，其中l是long word的缩写。

在Intelx86-64的处理器中包含了16个通用目的的寄存器，这些寄存器用来存放整数数据和指针，他们的名字都以%r开头。

![image-20250111191621179](resource/img/image-20250111191621179.png)

两个概念，调用者保存寄存器 和 被调用者保存寄存器：

![image-20250111191850889](resource/img/image-20250111191850889.png)

函数A调用者，函数B为被调用者

由于调用了函数B，寄存器rbx在函数B中被修改了
，逻辑上寄存器rbx的内容在调用函数B的前后应该保持一致

两个策略：

调用者保存策略：一个是函数A在调用函数B之前，提前保存寄存器rbx的内容，执行完函数B之后，再恢复寄存器rbx原来存储的内容

![image-20250111192213870](resource/img/image-20250111192213870.png)

被调用者保存策略：函数B在使用寄存器rbx之前，先保存寄存器rbx的值，在函数B返回之前，先恢复寄存器rbx原来存储的内容

![image-20250111192346218](resource/img/image-20250111192346218.png)

对于具体使用哪一种策略，不同的寄存器被定义成不同的策略。

![image-20250111192439448](resource/img/image-20250111192439448.png)

接下来我们看一下C代码是如何翻译成机器代码的，只需要将编译选项-S替换成-c。执行这条命令，即可生产mstore.c所对应的机器代码文件mstore.0。

![image-20250111193831516](resource/img/image-20250111193831516.png)

通过图中的命令，我们可以查看mstore.o中的相关信息。

![image-20250111194047800](resource/img/image-20250111194047800.png)

细微差别：反汇编代码省略了很多指令的后缀的“q’，但在call和ret指合添加后缀'q'，由于q只是表示大小指示符，大多数情况下是可以省略的

![image-20250111194126089](resource/img/image-20250111194126089.png)

## 程序编码

### 计算机的抽象模型

计算机利用更简单的抽象模型来隐藏实现的细节。

对于机器级编程来说，其中**两种抽象尤为重要**：

- 第一种是由**指令集体系结构或指令集架构**（ Instruction Set Architecture,ISA）来定义机器级程序的格式和行为，它定义了**处理器状态**、**指令的格式**，以及**每条指令对状态的影响**。  
  大多数ISA，包括x86-64，将程序的行为描述成**好像每条指令都是按顺序执行的**，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。
- 第二种抽象是，**机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组**。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

### 汇编代码中的寄存器

程序计数器（通常称为“PC”，在x86-64中用号%rip表示）给出将要执行的下一条指令在内存中的地址。

整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。

条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和 while语句

一组向量寄存器可以存放一个或多个整数或浮点数值

### 机器代码示例

假如我们有一个main.c文件，使用 gcc -0g -S main.c可以产生一个汇编文件。接着使用gcc -0g -c main.c就可以产生目标代码文件main.o。通常，这个.o文件是二进制格式的，无法直接查看，我们打开编辑器可以调整为十六进制的格式，示例如下所示。

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

这就是汇编指令对应的**目标代码**。从中得到一个重要信息，即**机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。**

### 反汇编简介

查看机器代码文件的内容，有一类称为反汇编器（ disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux系统中，使用命令 objdump -d main.o可以产生反汇编文件。示例如下图。（汇编器将汇编代码翻译成二进制的机器代码，那么反汇编器就是机器代码翻译成汇编代码）