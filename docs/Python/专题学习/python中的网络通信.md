# Socket


 在任何类型的通信开始之前，网络应用程序都必须创建套接字

socket一般指套接字,套接字最初是为同一主机上的应用程序所创建，使得主机上运行的一个程序（又名一个进程）与另一个运行的程序进行通信。这就是所谓的进程间通信（Inter-Process Communication，IPC）

随着网络的不断发展，socket也在不断地更新，进而形成了现在可以实现不同主机之间进行通信的工具。

有两种类型的套接字：基于文件的和面向网络的

基于文件的套接字：

家族名：AF_UNIX，（又名AF_LOCAL，在POSIX1.g标准中指定），它代表地址家族(addressfamily）：UNIX。其他比较旧的系统可能会将地址家族表示成域（domain）或协议家族（protocolfamily），并使用其缩写PF而非AF。

类似地，AF_LOCAL（在2000～2001年标准化）将代替AF_UNIX

基于网络的套接字：

家族名：AF_INET，或者地址家族：因特网。另一个地址家族AF_INET6用于第6版因特网协议（IPv6）寻址。

此外，还有其他的地址家族，这些要么是专业的、过时的、很少使用的，要么是仍未实现的。在所有的地址家族之中，目前AF_INET是使用的最广泛的



面向连接的套接字：

TCP套接字的名字SOCK_STREAM，特点：可靠，开销大

在进行通信之前必须先建立一个连接，该连接的通信提供序列化的、可靠的和不重复的数据交付，而没有记录边界。

这种类型的通信也称为虚拟电路或流套接字。

实现这种连接类型的主要协议是传输控制协议（缩写 TCP）。为了创建 TCP套接字，必须使用 SOCK_STREAM 作为套接字类型。

无连接的套接字

UDP套接字的名字SOCK_DGRAM，特点：不可靠（局网内还是比较可靠的），开销小与虚拟电路形成鲜明对比的是数据报类型的套接字，它是一种无连接的套接字。在通信开始之前并不需要建立连接。此时，在数据传输过程中并无法保证它的顺序性、可靠性或重复性。数据报确实保存了记录边界，这就意味着消息是以整体发送的，而并非首先分成多个片段。实现这种连接类型的主要协议是用户数据报协议（缩写 UDP）。为了创建UDP套接字，必须使用SOCK_DGRAM作为套接字类型。

# Selectors

这个模块允许高水平和高效的I/O复用，建立在'select'模块基元。

DefaultSelector会自动选择在所在平台最高效的实现方式，顺序是：epoll，poll，select

\#selectors.DefaultSelector()默认的选择器类，使用当前平台上可用的最高效实现方式，这应为大多数用户的默认选择

# python中的网络通信

网络通信用于获取一个算法在本地运行所需的数据，还可以共享信息实现分布式处理，另外可以用来管理云服务。 python的标准库提供了一些模块来创建网络服务以及访问现有服务ipaddress模块提供了一些类来验证、比较和处理IPV4/IPV6网络地址。

**底层socket库允许直接访问原生C套接字库，可以用于与任何网络服务通信。selectors提供了一个高层接口，可以同时监视多个套接字，这对于支持网络服务器同时与多个客户通信很有用**。

select提供了selectors使用的底层API。socketserver中的框架抽象了创建一个新的网络服务器所需要的大量重复性工作。可以结合这些类创建服务器来建立或使用线程以及支持TCP或UDP。应用只需要完成实际的消息处理

 

## sock模块：套接字

提供了一个底层的C API，可以使用BSD套接字接口实现网络通信。它包括socket类，用于处理具体的数据通道，还包括用来完成网络相关任务的函数，如将一个服务器名转换为一个地址以及格式化数据以便在网络上发送。

**寻址、协议簇和套接字类型**

套接字(socket)是**程序在本地或者通过互联网来回传递数据时所用的通信通道的一个端点**。套接字有两个主要属性用于控制如何发送数据：**地址簇(address family)控制所用的OSI网络协议；套接字类型(socket type)控制传输层协议**。

IP、TCP或UDP

 python通常支持三个地址簇。最常用的是AF_INET，用于IPV4寻址。IPV4地址长度为4个字节，通常表示为4个数的序列，每个字节对应一个数，用点号分隔(如127.0.0.1)。这些值通常被称为IP地址，目前几乎所有的互联网网络通信都是用IPV4.

 AF_INET6用于IPV6寻址。IPV6是下一代Internet协议，它支持128位地址和通信流调整，还支持IPV4不支持的一些路由特性。采用IPV6的应用在不断增多，特别是伴随着云计算的大量普及以及物联网项目而为网络增加很多额外的设备，都促使IPV6得到更广泛的应用

 AF_UNIX是unix域套接字(unix domain socket,uds)的地址簇，这是一种POSIX兼容系统上的进程间通信协议。uds的实现通常允许操作系统直接从进程向进程传递数据，而不用通过网络栈。这比使用AF_INET更加高效，但是由于要使用文件系统作为寻址的命名空间，所以uds的优势仅限于同一个系统上的进程。相比其他的ipc机制(如命名管道或共享内存)，使用uds的优势在于它与ip网络应用的编程接口是一致的。这说明，应用在单个主机上运行时可以利用高效的通信，在网络上发送数据时仍然可以使用相同的代码。

套接字类型往往是SOCK_DGRAM或SOCK_STREAM，其中SOCK_DGRAM对应面向消息的数据报传输，而SOCK_STREAM对应面向流的传输。数据报套接字通常与UDP关联，即用户数据报协议(user datagram protocol)。这些套接字能提供不可靠的消息传送。面向流的套接字与TCP相关，即传输控制协议(transmission control protocol)。它们可以在客户和服务器之间提供字节流，通过超时管理、重传和其他特性确保提供消息传送或失败通知。

**大多数传送数据的应用协议(如HTTP)都建立在TCP基础上，因为这样可以更容易地创建自动处理消息排序和传送的复杂应用**。UDP通常用于顺序不太重要的协议(因为消息是自包含的，而且通常很小，如通过DNS的名字查找)，或者用于组播(向多个主机发送相同的数据)。UDP和TCP都可以用于IPV4或IPV6寻址

 举个例子：UDP就好比发短信，发完了就不管了，信息是可能丢失的，但是不管，只要发了就ok，对方是否接收到，我不管。TCP就好比打电话，我拨号，必须要确保对方接电话，才可以。所以说TCP相比UDP操作更复杂，但更安全

**通过结合ip地址、协议和端口号，可以唯一地标识一个通信通道，并确保通过一个套接字发送的消息能到达正确的目标**



## select：高效等待I/O

select模块允许访问特定于平台的I/O监视函数。最可移植的接口是POSIX函数select()，Unix和Windows都提供了这个函数。这个模块还包括poll(这个api只适用于Unix)，另外还提供了很多只适用于一些Unix特定版本的选项

 

### 使用select()

**python的select函数是底层操作系统实现的一个直接接口。它会监视套接字、打开的文件和管道**(可以是任何有fileno()方法的对象，这个方法会返回一个合法的文件描述符)，直到这个对象**可读或可写**，或者出现一个通信错误。**利用select函数可以很容易地同时创建多个连接**，这比python中使用**套接字超时编写一个轮询循环更为高效**，因为监视发生在操作系统网络层而不是在解释器中完成。

 

## selectors：I/O多路复用抽象

selectors模块在select中平台特定的I/O监视函数之上提供了一个平台独立的函数

**平台模型**

selectors中的api是基于时间的，与select中的poll类似。它有多个实现，并且这个模块会自动设置别名DefaultSelector来指示当前系统配置最高的一个实现选择器对象提供了一些方法，

可以指定在一个套接字是哪个，查找哪些事件，然后以一种平台独立的方式让调用者等待事件。

selectors.register函数：

注册对事件会创建一个SelectorKey，其中包含套接字、所注册事件的有关信息，其中还有可选的应用数据。

选择器的所有者调用它的select方法来了解事件。返回值是一个键对象序列和一个指示发生了那些事件的位掩码。使用选择器的程序要反复调用select，然后适当地处理事件

## selectors和socket的关系：

单个selectors能够监听很多个socket

使用socket 阻塞通讯时，当程序调用recv() 方法从socket 中读取数据时，如果没有读取到数据时，当前线程将会被阻塞，因此为了解决这个问题采用了多线程的方式，制约了服务器高并发的访问。

selectors 模块允许socket 以非阻塞的方式进行通信，selectors 相当于事件注册中心，程序只要将所有事件注册给selectors 管理，当selectors 检测到socket 中的特定事件后，程序就调用相关的监听方法进行处理。



selectors 主要支持两种事件：

selectors.EVENT_READ:当socket 有数据可读时触发该事件。当客户端连接进来时也会触发该事件。

selectors.EVENT_WRITE:当socket将要写数据时触发该事件。

### 结构层次关系

self.__sel = selectors.DefaultSelector()

建立__sel（selectors），

在selectors下面register，选择要监视的套接字；产生SelectorKey 实例，其中包含套接字、所注册事件的有关信息，其中还有可选的应用数据。

 

每一个SelectorKey实例都有一个与之相关联的Mapping实例。

 