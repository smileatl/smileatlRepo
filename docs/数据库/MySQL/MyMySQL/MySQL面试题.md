

## 千万条数据怎么导出来

首先，确定数据导出的格式，如果没有特别要求，使用比较通用的CSV格式。

使用数据库的分页功能，每次只导出一定数量的数据，最后将导出的所有数据合并成一个文件。避免一次性导出数据太多导致系统崩溃或者导出失败。

如果导出时间非常长，可以将数据分成多个部分，分给不同的服务器或者线程，然后将处理结果合并起来。

## 数据库查询效率很低怎么办

- 索引：对查询中经常访问到的数据加索引，或者重新设计表结构。
- 使用EXPLAIN命令：查看查询语句的执行计划，然后进行优化，比如走全表扫描的能不能走索引。尽可能避免使用子查询，使用合适的JOIN语句等，减少查询时间。
- 分页：对于大量数据的查询，可以使用分页查询，避免一次性查询大量数据导致效率过低。
- 缓存：对于需要复杂计算的查询，可以考虑使用数据库缓存，将计算结果缓存到内存中，避免重复计算。
- 读写分离、分库分表：对于高并发的查询，可以考虑使用数据库的读写分离、分库分表等技术，以提高数据库的并发处理能力。

## 读提交怎么解决幻读问题

**读提交**是指一个事务只有提交，另一个事务才能读取这个事务提交后的数据。不可能发生脏读，可能发生不可重复读和幻读。

**幻读**是指前后读取的数据数量不一致。

解决方式：

- 使用行级锁或者表级锁

可以使用行级锁或者表级锁来锁定某一行或某张表的记录，使用行级锁，可以避免锁住不必要锁住的数据，提高并发性能。使用表级锁可以避免幻读问题。

- MVCC

MVCC是多版本并发控制，可以通过维护版本链，解决并发条件下的读一致性问题。MVCC在每个数据行上维护版本号。每个事务在读取自己数据时，其他事务对自己当前事务没有影响。

如果考虑高并发性能，需要使用MVCC。如果需要更好数据一致性，可以考虑锁，如果要锁住的数据不多，可以选用行级锁。

## WHERE a > 1 and b=1 ORDER BY c 建立索引

可以建立联合索引，但是考虑到最左匹配原则，不能把a作为联合索引第一个，因为最左匹配原则是在前一个有序的情况下，才能走到后面的索引查询，而这里不确定a到底是2还是3还是什么，会导致索引失效。

如果c建立索引也会导致索引失效，因为有order by函数。

所以我选择(b,a)建立索引。

## 如何建立联合索引

where a = 1 and b = 2 and c > 3 and d = 4怎么建立索引

答：应该建立(a,b,d,c)的联合索引

因为c是范围查询，c后的字段不能走索引，按照最左匹配原则，在左边字段有序的情况下，才可以对后面的进行匹配查找，可以把范围查询的放在最后，比如(a,b,d,c)，where后字段顺序不重要，因为优化器会进行排序。

## 比较效率COUNT(1)、COUNT(*)、COUNT(主键)、COUNT(字段)

性能：COUNT(*) = COUNT(1) > COUNT(主键字段) > COUNT(字段)

COUNT(*)的作用是，统计符合条件的记录中，函数指定的参数不为NULL的参数有多少。

COUNT(1)和COUNT(*)的效率是相同的，都只是统计结果集的行数，而不用对列进行计算和判断，因此效率较高。

COUNT(主键)的效率较低，在统计主键列需要判断是否存在空值，然后排除空值计算出行数，需要额外的开销。

COUNT(字段)的效率最低，字段如果不是索引字段，只是普通字段，将会采用全表扫描的方式来计数。

## B+树可以并发修改吗

B+树是可以并发修改的。

B+树是MySQL默认的存储引擎InnoDB的索引数据结构，并发修改需要考虑到锁的结构来保证并发修改的正确性和一致性，还需要考虑到锁的粒度来控制开销。

锁的结构有表级锁和行级锁，行级锁的粒度较小，可以避免不必要的开销，比如只需要锁住需要修改的**数据行**，而其他数据行可以被其他事务访问和修改。

在实际应用中，为了提高并发性能，还可以采用粒度更小的锁，比如基于**索引**的锁，这样锁住的是**B+树的部分节点**，而不是整棵树，再比如基于**页**的锁。【B+树的每个节点对应一个页】

## 聚簇索引和非聚簇区别

聚簇索引又叫主键索引，叶子节点中存储主键和数据，非聚簇索引中存储索引和主键。聚簇索引中主键索引和数据在一起，都在叶子节点中，非聚簇索引中，索引和数据是分开的。

建立在主键上的是主键索引。我们自己建的索引基本上都是非聚簇索引。

在非聚簇索引中查询数据，还需要根据主键到聚簇索引中查询，这个过程叫做回表。第一次索引查询是顺序IO，回表是随机IO，消耗性能，回表次数越多，优化器越倾向于全表扫描。
