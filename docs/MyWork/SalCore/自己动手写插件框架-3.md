## 编程语言的支持

在前面的章节中，我们已经了解到，如果你能够使用编译器令应用程序和插件的虚表匹配，那么就可以保持 C++ 虚表级别的兼容性；或者你可以使用 C 级别的兼容性，然后就能使用不同的编译器去构建系统，但其限制在于你只能编写纯 C 应用。这样的话，你就不能够使用前面我们在例子 IActor 中看到的那种优雅的 C++ 接口。

## 纯 C 实现

在纯 C 的编程模型中，你只能使用 C 开发插件。当实现`PF_CreateFunc`函数时，需要返回一个 C 对象同应用程序的 C 对象模型进行交互。

但是，我们知道，C 语言是一个过程语言，没有对象的概念。那么，刚刚提到的 C 对象和 C 对象模型是怎么回事呢？为了理解这一点，我们必须认识到，C 语言已经提供了足够多的抽象机制来实现对象、引入多态（这一点在我们的插件框架中尤其重要）以及支持面向对象风格的编程。事实上，原始的 C++ 编译器就是一个 C 编译器的前端。它将 C++ 代码翻译成 C 代码，然后直接输出给一个普通的 C 编译器（当然，我们说的是“原始的”C++ 编译器）。它的名字就叫 [Cfront](http://en.wikipedia.org/wiki/Cfront) 这已经足够说明问题了。

核心技术是，使用包含函数指针的结构体。每个函数声明的第一个参数都应该是指向本结构体的指针。这个结构体也可能包含其他数据成员。也就是说，我们使用结构体模拟了 C++ 的类，提供了封装（在一个地方保存状态和行为）、继承（通过将父结构体作为第一个数据成员实现）和多态（通过设置不同的函数指针实现）。

C 不支持析构函数、函数和运算符的重载以及命名空间，所以在定义接口时，我们能够设置的选项极为有限。这可能有点因祸得福，因为那些掌握了 C++ 语言不同子集的人们都明白使用接口，而不一定了解析构函数、运算符重载那些机制。减少接口的语言结构上的限制，有助于简化接口，提高可用性。

在下面的章节中，我们将讨论面向对象的 C 语言设计。下面是我们的简单游戏的 C 对象模型的实现。如果你快速浏览一遍，你会发现它甚至支持集合类型和对象遍历器。