## 1、add_definitions后头文件中的宏定义不生效，源文件中的可以生效

宏定义，在.h中依赖于被调用者的定义的宏， 在.cpp中依赖于本工程定义的宏

1、base_foss_core的cmake文件定义了宏，base_foss_core模块中的cpp文件中的宏能直接成立

2、base_foss_core模块中的h文件的宏要想成立，就取决于其调用者定义的宏，也就是core_main的cmake文件定义的宏

## 5、Severity Code Description Project File Line Suppression State Error CMake Error: CMake can not determine linker language for target: base_foss_core

生成文件时没有c/cpp文件的链接

## 10、删除文件后的操作

删除文件后，要去相应的cmake文件把文件引用删除掉

## 15、typedef struct base_directories base_directories的意义

**简化类型声明**：在C语言中，定义结构体时，需要用关键字`struct`。使用`typedef`后，可以直接用新名字代替`struct`关键字。

**提高可维护性**：如果需要更改结构体的名字，只需更改`typedef`定义即可，而不用修改所有相关代码。

通过`typedef`，你可以直接使用`base_directories`和`base_filenames`，而不需要每次都使用`struct`关键字。

## 20、没加extern "C"，就都别加了，特殊需要再加

测试

## 25、当所有地方都对，还有链接不到的bug的时候

出现时可以检查该不该加extern "C"；都加或者都不加

## 30、freeswitch之前之所以没编成功是因为git和bash没加到环境变量，导致下载库失败

## 35、已下载了库，但是头文件找不到

这是因为下载的库有很多后缀

## 40、没办法在core_base模块的h文件包含apr库头文件的原因

因为我会在core_main.c文件中包含base.h头文件，然后base.h文件就会在core_main模块展开，此时base.h文件中所包含的那些头文件中如果有文件中包含了apr库的头文件，那么因为core_main模块并没有去include apr库的头文件，就出现了找不到头文件的情况。（对于core_base模块的c文件没有影响）

两种解决办法：

1. 不要在core_base模块的h文件include apr库的头文件，而是在core_base模块的c文件需要用到apr库的时候，include对应的apr库头文件（该框架所采用的方法）
2. 在core_main模块的cmake文件去include_directories apr库的头文件路径（我觉得不合适，因为不希望core_main再去额外包含apr库的文件路径了）

## 45、设置第三方库的产物路径

```cmake
cmake_minimum_required(VERSION 3.15.0)

project(Poco)

set(LIBRARY_OUTPUT_PATH ${base_srcdir}/out)
```

## 50、引入第三方库

将 Poco 库引入到您的 CMake 工程中可以通过以下几种方式实现：手动配置路径、使用 `find_package`、或者通过 `ExternalProject` 下载和构建。以下是引入 Poco 库的详细步骤。

### 1. 手动配置路径

如果您已经下载并编译好了 Poco 库，可以手动配置头文件路径和库文件路径。

#### 步骤

1. **下载并编译 Poco 库**（如果尚未完成）：

   访问 [Poco 官方网站](https://pocoproject.org/) 下载源代码，或者使用 Git 克隆仓库：

   ```sh
   git clone https://github.com/pocoproject/poco.git
   cd poco
   mkdir cmake-build
   cd cmake-build
   cmake ..
   cmake --build . --config Release
   ```

2. **配置头文件和库文件路径**：

   修改您的 `CMakeLists.txt` 文件，添加 Poco 库的头文件路径和库文件路径。

   ```cmake
   cmake_minimum_required(VERSION 3.8)

   project(SalCore)

   # 设置项目基础路径
   set(base_srcdir ${PROJECT_SOURCE_DIR})

   # 设置 Poco 库路径
   set(POCO_INCLUDE_DIR ${base_srcdir}/thirdparty/poco/include)
   set(POCO_LIB_DIR ${base_srcdir}/thirdparty/poco/lib)

   # 包含头文件路径
   include_directories(${POCO_INCLUDE_DIR})

   # 链接库文件路径
   link_directories(${POCO_LIB_DIR})

   # 添加子目录
   add_subdirectory(core_base)
   add_subdirectory(core_main)
   ```

3. **链接 Poco 库**：

   在需要使用 Poco 库的目标中，添加链接库。

   ```cmake
   # core_main/CMakeLists.txt

   cmake_minimum_required(VERSION 3.8)

   project(core_main)

   # 库生成路径
   set(EXECUTABLE_OUTPUT_DIRECTORY ${base_srcdir}/out)

   # 头文件
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_main/include)
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_base/include)

   # 源文件
   file(GLOB_RECURSE SOURCE_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
   aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SOURCE_SRC)

   # 生成可执行文件
   add_executable(core_main ${SOURCE_SRC} ${SOURCE_HEAD})

   # 链接 Poco 库
   target_link_libraries(core_main PRIVATE core_base PocoFoundation PocoNet PocoUtil)
   ```

### 2. 使用 `find_package`

Poco 库支持 CMake 的 `find_package` 命令，这使得引入库更加简洁和自动化。

#### 步骤

1. **确保 Poco 库安装在系统路径中**，或者设置 `CMAKE_PREFIX_PATH` 指向 Poco 库的安装路径。

2. **在 CMakeLists.txt 文件中使用 `find_package`**：

   ```cmake
   cmake_minimum_required(VERSION 3.8)

   project(SalCore)

   # 设置项目基础路径
   set(base_srcdir ${PROJECT_SOURCE_DIR})

   # 找到 Poco 库
   find_package(Poco REQUIRED COMPONENTS Foundation Net Util)

   # 包含头文件路径
   include_directories(${Poco_INCLUDE_DIRS})

   # 添加子目录
   add_subdirectory(core_base)
   add_subdirectory(core_main)
   ```

3. **链接 Poco 库**：

   在需要使用 Poco 库的目标中，添加链接库。

   ```cmake
   # core_main/CMakeLists.txt

   cmake_minimum_required(VERSION 3.8)

   project(core_main)

   # 库生成路径
   set(EXECUTABLE_OUTPUT_DIRECTORY ${base_srcdir}/out)

   # 头文件
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_main/include)
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_base/include)

   # 源文件
   file(GLOB_RECURSE SOURCE_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
   aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SOURCE_SRC)

   # 生成可执行文件
   add_executable(core_main ${SOURCE_SRC} ${SOURCE_HEAD})

   # 链接 Poco 库
   target_link_libraries(core_main PRIVATE core_base Poco::Foundation Poco::Net Poco::Util)
   ```

### 3. 使用 `ExternalProject` 下载和构建 Poco

如果您希望在构建过程中自动下载和构建 Poco 库，可以使用 CMake 的 `ExternalProject` 模块。

#### 步骤

1. **在 CMakeLists.txt 文件中添加 `ExternalProject` 配置**：

   ```cmake
   cmake_minimum_required(VERSION 3.8)

   project(SalCore)

   include(ExternalProject)

   # 设置项目基础路径
   set(base_srcdir ${PROJECT_SOURCE_DIR})

   # 下载并构建 Poco 库
   ExternalProject_Add(
       Poco
       GIT_REPOSITORY https://github.com/pocoproject/poco.git
       GIT_TAG master
       CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${base_srcdir}/thirdparty/poco
       UPDATE_DISCONNECTED 1
   )

   # 包含头文件路径
   include_directories(${base_srcdir}/thirdparty/poco/include)

   # 链接库文件路径
   link_directories(${base_srcdir}/thirdparty/poco/lib)

   # 添加子目录
   add_subdirectory(core_base)
   add_subdirectory(core_main)
   ```

2. **确保在需要使用 Poco 库的目标中添加依赖**：

   ```cmake
   # core_main/CMakeLists.txt

   cmake_minimum_required(VERSION 3.8)

   project(core_main)

   # 库生成路径
   set(EXECUTABLE_OUTPUT_DIRECTORY ${base_srcdir}/out)

   # 头文件
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_main/include)
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_base/include)

   # 源文件
   file(GLOB_RECURSE SOURCE_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
   aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SOURCE_SRC)

   # 生成可执行文件
   add_executable(core_main ${SOURCE_SRC} ${SOURCE_HEAD})

   # 添加依赖
   add_dependencies(core_main Poco)

   # 链接 Poco 库
   target_link_libraries(core_main PRIVATE core_base PocoFoundation PocoNet PocoUtil)
   ```

### 示例项目结构

确保您的项目结构清晰，并且各个模块的 `CMakeLists.txt` 文件配置正确：

```
SalCore/
├── CMakeLists.txt
├── core_base/
│   ├── CMakeLists.txt
│   ├── include/
│   │   └── *.h
│   └── src/
│       └── *.cpp
├── core_main/
│   └── CMakeLists.txt
├── thirdparty/
│   └── poco/
│       ├── CMakeLists.txt
│       ├── include/
│       │   └── *.h
│       └── src/
│           └── *.cpp
└── thirdparty_sal/
    └── ...
```

通过上述步骤，您应该能够成功将 Poco 库引入到您的 CMake 工程中。选择适合您的方式，并确保路径和依赖关系配置正确。


## apr库的修改

我自己手动复制了apr.hw文件内容到apr.h文件

apr库的cmake文件把test的option(APR_BUILD_TESTAPR "Build the test suite" OFF)关掉，然后需要删除out



## 我的修改点

去掉了switch_bool_t这个无用的东西

为了展示如何管理多个插件，并且支持插件间通过核心模块进行通信，我们需要编写两个独立的插件，并在主程序中加载它们。以下是详细的实现步骤。



## tmp

### 1. 定义核心模块接口

**core.h**

```c
#ifndef CORE_H
#define CORE_H

#include <apr-1/apr_pools.h>
#include <apr-1/apr_hash.h>

typedef void (*core_callback_t)(const char *message);

void core_initialize(apr_pool_t *pool);
void core_shutdown(void);
void core_register_callback(const char *name, core_callback_t cb);
void core_invoke_callback(const char *name, const char *message);

#endif // CORE_H
```

### 2. 实现核心模块

**core.c**

```c
#include "core.h"
#include <stdio.h>

static apr_pool_t *core_pool = NULL;
static apr_hash_t *callbacks = NULL;

void core_initialize(apr_pool_t *pool) {
    core_pool = pool;
    callbacks = apr_hash_make(core_pool);
    printf("Core initialized.\n");
}

void core_shutdown(void) {
    callbacks = NULL;
    core_pool = NULL;
    printf("Core shutdown.\n");
}

void core_register_callback(const char *name, core_callback_t cb) {
    apr_hash_set(callbacks, name, APR_HASH_KEY_STRING, cb);
    printf("Callback '%s' registered.\n", name);
}

void core_invoke_callback(const char *name, const char *message) {
    core_callback_t cb = apr_hash_get(callbacks, name, APR_HASH_KEY_STRING);
    if (cb) {
        cb(message);
    }
}
```

### 3. 定义插件接口

**plugin.h**

```c
#ifndef PLUGIN_H
#define PLUGIN_H

#include "core.h"

typedef struct {
    void (*initialize)(apr_pool_t *pool);
    void (*shutdown)(void);
} plugin_t;

#endif // PLUGIN_H
```

### 4. 实现第一个插件

**plugin1.c**

```c
#include "plugin.h"
#include <stdio.h>

static void plugin1_initialize(apr_pool_t *pool) {
    core_register_callback("plugin1_callback", (core_callback_t)printf);
    printf("Plugin1 initialized\n");
}

static void plugin1_shutdown(void) {
    printf("Plugin1 shutdown\n");
}

plugin_t plugin1 = {
    .initialize = plugin1_initialize,
    .shutdown = plugin1_shutdown
};

plugin_t* get_plugin(void) {
    return &plugin1;
}
```

### 5. 实现第二个插件

**plugin2.c**

```c
#include "plugin.h"
#include <stdio.h>

static void plugin2_initialize(apr_pool_t *pool) {
    core_register_callback("plugin2_callback", (core_callback_t)printf);
    printf("Plugin2 initialized\n");
}

static void plugin2_shutdown(void) {
    printf("Plugin2 shutdown\n");
}

plugin_t plugin2 = {
    .initialize = plugin2_initialize,
    .shutdown = plugin2_shutdown
};

plugin_t* get_plugin(void) {
    return &plugin2;
}
```

### 6. 实现插件框架

**plugin_framework.h**

```c
#ifndef PLUGIN_FRAMEWORK_H
#define PLUGIN_FRAMEWORK_H

#include "plugin.h"
#include <apr-1/apr_dso.h>

typedef struct {
    apr_dso_handle_t *dso;
    plugin_t *plugin;
} plugin_handle_t;

int load_plugin(plugin_handle_t *handle, const char *path, apr_pool_t *pool);
void unload_plugin(plugin_handle_t *handle);

#endif // PLUGIN_FRAMEWORK_H
```

**plugin_framework.c**

```c
#include "plugin_framework.h"
#include <stdio.h>

typedef plugin_t* (*get_plugin_func_t)(void);

int load_plugin(plugin_handle_t *handle, const char *path, apr_pool_t *pool) {
    if (apr_dso_load(&handle->dso, path, pool) != APR_SUCCESS) {
        fprintf(stderr, "Failed to load plugin: %s\n", path);
        return -1;
    }

    get_plugin_func_t get_plugin;
    if (apr_dso_sym((apr_dso_handle_sym_t*)&get_plugin, handle->dso, "get_plugin") != APR_SUCCESS) {
        fprintf(stderr, "Failed to find symbol: get_plugin\n");
        apr_dso_unload(handle->dso);
        return -1;
    }

    handle->plugin = get_plugin();
    handle->plugin->initialize(pool);

    return 0;
}

void unload_plugin(plugin_handle_t *handle) {
    if (handle->plugin) {
        handle->plugin->shutdown();
    }
    if (handle->dso) {
        apr_dso_unload(handle->dso);
    }
}
```

### 7. 编写主程序

**main.c**

```c
#include "core.h"
#include "plugin_framework.h"
#include <apr-1/apr_general.h>
#include <apr-1/apr_pools.h>

int main(int argc, char *argv[]) {
    apr_initialize();
    apr_pool_t *pool;
    apr_pool_create(&pool, NULL);

    core_initialize(pool);

    plugin_handle_t handle1, handle2;
    if (load_plugin(&handle1, "./plugin1.so", pool) != 0) {
        apr_pool_destroy(pool);
        apr_terminate();
        return -1;
    }

    if (load_plugin(&handle2, "./plugin2.so", pool) != 0) {
        unload_plugin(&handle1);
        apr_pool_destroy(pool);
        apr_terminate();
        return -1;
    }

    core_invoke_callback("plugin1_callback", "Hello from main to Plugin1");
    core_invoke_callback("plugin2_callback", "Hello from main to Plugin2");

    unload_plugin(&handle2);
    unload_plugin(&handle1);
    core_shutdown();

    apr_pool_destroy(pool);
    apr_terminate();
    return 0;
}
```

### 8. 编译和运行

编译插件和主程序：

```sh
gcc -shared -o plugin1.so plugin1.c -fPIC $(apr-1-config --cflags --libs)
gcc -shared -o plugin2.so plugin2.c -fPIC $(apr-1-config --cflags --libs)
gcc -o main main.c core.c plugin_framework.c $(apr-1-config --cflags --libs)
./main
```

### 总结

这个示例展示了如何使用 APR 实现一个核心模块和多个动态加载模块，并通过核心模块进行模块间通信。APR 提供了跨平台的动态库加载功能，使得这种实现变得相对简单和高效。通过这种方法，可以实现一个模块化的系统，方便插件的开发和管理。

## tmp2

以下是一个完整的示例，演示了如何实现多个插件，并在插件之间进行通信：

```cpp
// plugin_interface.h

#ifdef __cplusplus
extern "C" {
#endif

// 定义C接口的插件接口结构体
typedef struct {
    void (*initialize)(void);  // 初始化函数指针
    void (*process)(void);     // 处理函数指针
} PluginInterface;

#ifdef __cplusplus
}
#endif

// plugin1.cpp

#include <iostream>
#include "plugin_interface.h"

// 实现插件1
class Plugin1 {
public:
    static void initialize() {
        std::cout << "Plugin1 initialized" << std::endl;
    }

    static void process() {
        std::cout << "Plugin1 processing" << std::endl;
    }
};

// 将C++的实现转换为C接口
extern "C" {
    PluginInterface plugin1_interface = {
        .initialize = Plugin1::initialize,
        .process = Plugin1::process
    };
}

// plugin2.cpp

#include <iostream>
#include "plugin_interface.h"

// 实现插件2
class Plugin2 {
public:
    static void initialize() {
        std::cout << "Plugin2 initialized" << std::endl;
    }

    static void process() {
        std::cout << "Plugin2 processing" << std::endl;
    }
};

// 将C++的实现转换为C接口
extern "C" {
    PluginInterface plugin2_interface = {
        .initialize = Plugin2::initialize,
        .process = Plugin2::process
    };
}

// core.c

#include <apr_dso.h>
#include <apr_pools.h>
#include "plugin_interface.h"

apr_pool_t* pool;

// 加载插件
void load_plugin(const char* plugin_path, PluginInterface* plugin_interface) {
    apr_dso_handle_t* dso_handle;
    apr_dso_sym_t symbol;

    // 加载插件动态链接库
    apr_dso_load(&dso_handle, plugin_path, apr_dynamic_linker, pool);

    // 获取插件接口符号
    apr_dso_sym(&symbol, dso_handle, "plugin_interface");

    // 将符号转换为插件接口结构体
    *plugin_interface = *(PluginInterface*)symbol;

    // 调用插件初始化函数
    plugin_interface->initialize();
}

// 卸载插件
void unload_plugin(apr_dso_handle_t* dso_handle) {
    // 卸载插件动态链接库
    apr_dso_unload(dso_handle);
}

// 使用插件功能
void use_plugin_function(PluginInterface* plugin_interface) {
    // 调用插件的处理函数
    plugin_interface->process();
}

// main.c

#include "core.c"

int main() {
    apr_initialize();
    apr_pool_create(&pool, NULL);

    PluginInterface plugin1;
    PluginInterface plugin2;

    // 加载插件1
    load_plugin("plugin1.so", &plugin1);

    // 加载插件2
    load_plugin("plugin2.so", &plugin2);

    // 使用插件1功能
    use_plugin_function(&plugin1);

    // 使用插件2功能
    use_plugin_function(&plugin2);

    // 卸载插件1
    unload_plugin(dso_handle);

    // 卸载插件2
    unload_plugin(dso_handle);

    apr_pool_destroy(pool);
    apr_terminate();

    return 0;
}
```

在这个示例中，我们有两个插件：`plugin1.cpp`和`plugin2.cpp`。每个插件都实现了插件接口中定义的初始化函数和处理函数。在`core.c`中，我们使用`load_plugin()`函数加载插件，并将插件的接口存储在相应的变量中。然后，我们可以通过调用`use_plugin_function()`函数来使用插件的功能。

请注意，此示例假设您已经将插件编译为动态链接库（例如`.so`文件）。您需要根据您的编译环境和目标平台进行相应的调整。

希望这个示例能够帮助您实现多个插件，并在插件之间进行通信。如有需要，您可以根据实际需求进行进一步的扩展和修改。

## poco-tmp

是的，您也可以使用函数来封装 POCO 动态加载和管理插件的功能，而不一定非要使用类。

以下是一个示例，展示了如何使用函数来封装 POCO 动态加载和管理插件的功能：

```cpp
// plugin_interface.h

#ifdef __cplusplus
extern "C" {
#endif

// 定义C接口的插件接口结构体
typedef struct {
    void (*initialize)(void);  // 初始化函数指针
    void (*process)(void);     // 处理函数指针
} PluginInterface;

#ifdef __cplusplus
}
#endif

// plugin1.cpp

#include <iostream>
#include "plugin_interface.h"

// 实现插件1
class Plugin1 {
public:
    static void initialize() {
        std::cout << "Plugin1 initialized" << std::endl;
    }

    static void process() {
        std::cout << "Plugin1 processing" << std::endl;
    }
};

// 将C++的实现转换为C接口
extern "C" {
    PluginInterface plugin1_interface = {
        .initialize = Plugin1::initialize,
        .process = Plugin1::process
    };
}

// plugin2.cpp

#include <iostream>
#include "plugin_interface.h"

// 实现插件2
class Plugin2 {
public:
    static void initialize() {
        std::cout << "Plugin2 initialized" << std::endl;
    }

    static void process() {
        std::cout << "Plugin2 processing" << std::endl;
    }
};

// 将C++的实现转换为C接口
extern "C" {
    PluginInterface plugin2_interface = {
        .initialize = Plugin2::initialize,
        .process = Plugin2::process
    };
}
```

```cpp
// core.cpp

#include <iostream>
#include <Poco/ClassLoader.h>
#include <Poco/Manifest.h>
#include "plugin_interface.h"

typedef Poco::ClassLoader<PluginInterface> PluginClassLoader;
typedef Poco::Manifest<PluginInterface> PluginManifest;

void loadPlugins() {
    PluginClassLoader loader;

    // 添加插件库路径
    loader.addLibrary("plugin1");
    loader.addLibrary("plugin2");

    // 加载插件
    loader.loadAll();

    // 获取已加载的插件列表
    const PluginClassLoader::LibraryVec& libraries = loader.getLoadedLibraries();

    // 遍历插件并使用插件功能
    for (const auto& library : libraries) {
        PluginManifest::Iterator it(library);
        PluginInterface* plugin = it.createInstance();

        // 调用插件的初始化函数
        plugin->initialize();

        // 调用插件的处理函数
        plugin->process();

        delete plugin;
    }
}
```

```cpp
// main.cpp

#include "core.cpp"

int main() {
    loadPlugins();

    return 0;
}
```

在这个示例中，我们将 POCO 动态加载和管理插件的功能封装在了一个名为 `loadPlugins()` 的函数中。该函数执行了与之前示例相同的加载和使用插件的逻辑。

在 "main.cpp" 中，我们直接调用了 `loadPlugins()` 函数，以加载和使用插件。

这样，您就可以通过调用函数来使用 POCO 动态加载和管理插件的功能，而无需使用类。

希望这次回答能够满足您的需求，如果还有任何问题，请随时提问。