## 1、add_definitions后头文件中的宏定义不生效，源文件中的可以生效

宏定义，在.h中依赖于被调用者的定义的宏， 在.cpp中依赖于本工程定义的宏

1、base_foss_core的cmake文件定义了宏，base_foss_core模块中的cpp文件中的宏能直接成立

2、base_foss_core模块中的h文件的宏要想成立，就取决于其调用者定义的宏，也就是core_main的cmake文件定义的宏

## 5、Severity Code Description Project File Line Suppression State Error CMake Error: CMake can not determine linker language for target: base_foss_core

生成文件时没有c/cpp文件的链接

## 10、删除文件后的操作

删除文件后，要去相应的cmake文件把文件引用删除掉

## 15、typedef struct base_directories base_directories的意义

**简化类型声明**：在C语言中，定义结构体时，需要用关键字`struct`。使用`typedef`后，可以直接用新名字代替`struct`关键字。

**提高可维护性**：如果需要更改结构体的名字，只需更改`typedef`定义即可，而不用修改所有相关代码。

通过`typedef`，你可以直接使用`base_directories`和`base_filenames`，而不需要每次都使用`struct`关键字。

## 20、没加extern "C"，就都别加了，特殊需要再加

测试

## 25、当所有地方都对，还有链接不到的bug的时候

出现时可以检查该不该加extern "C"；都加或者都不加

## 30、freeswitch之前之所以没编成功是因为git和bash没加到环境变量，导致下载库失败

## 35、已下载了库，但是头文件找不到

这是因为下载的库有很多后缀

## 40、没办法在core_base模块的h文件包含apr库头文件的原因

因为我会在core_main.c文件中包含base.h头文件，然后base.h文件就会在core_main模块展开，此时base.h文件中所包含的那些头文件中如果有文件中包含了apr库的头文件，那么因为core_main模块并没有去include apr库的头文件，就出现了找不到头文件的情况。（对于core_base模块的c文件没有影响）

两种解决办法：

1. 不要在core_base模块的h文件include apr库的头文件，而是在core_base模块的c文件需要用到apr库的时候，include对应的apr库头文件（该框架所采用的方法）
2. 在core_main模块的cmake文件去include_directories apr库的头文件路径（我觉得不合适，因为不希望core_main再去额外包含apr库的文件路径了）

## 45、设置第三方库的产物路径

```cmake
cmake_minimum_required(VERSION 3.15.0)

project(Poco)

set(LIBRARY_OUTPUT_PATH ${base_srcdir}/out)
```

## 50、引入第三方库

将 Poco 库引入到您的 CMake 工程中可以通过以下几种方式实现：手动配置路径、使用 `find_package`、或者通过 `ExternalProject` 下载和构建。以下是引入 Poco 库的详细步骤。

### 1. 手动配置路径

如果您已经下载并编译好了 Poco 库，可以手动配置头文件路径和库文件路径。

#### 步骤

1. **下载并编译 Poco 库**（如果尚未完成）：

   访问 [Poco 官方网站](https://pocoproject.org/) 下载源代码，或者使用 Git 克隆仓库：

   ```sh
   git clone https://github.com/pocoproject/poco.git
   cd poco
   mkdir cmake-build
   cd cmake-build
   cmake ..
   cmake --build . --config Release
   ```

2. **配置头文件和库文件路径**：

   修改您的 `CMakeLists.txt` 文件，添加 Poco 库的头文件路径和库文件路径。

   ```cmake
   cmake_minimum_required(VERSION 3.8)

   project(SalCore)

   # 设置项目基础路径
   set(base_srcdir ${PROJECT_SOURCE_DIR})

   # 设置 Poco 库路径
   set(POCO_INCLUDE_DIR ${base_srcdir}/thirdparty/poco/include)
   set(POCO_LIB_DIR ${base_srcdir}/thirdparty/poco/lib)

   # 包含头文件路径
   include_directories(${POCO_INCLUDE_DIR})

   # 链接库文件路径
   link_directories(${POCO_LIB_DIR})

   # 添加子目录
   add_subdirectory(core_base)
   add_subdirectory(core_main)
   ```

3. **链接 Poco 库**：

   在需要使用 Poco 库的目标中，添加链接库。

   ```cmake
   # core_main/CMakeLists.txt

   cmake_minimum_required(VERSION 3.8)

   project(core_main)

   # 库生成路径
   set(EXECUTABLE_OUTPUT_DIRECTORY ${base_srcdir}/out)

   # 头文件
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_main/include)
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_base/include)

   # 源文件
   file(GLOB_RECURSE SOURCE_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
   aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SOURCE_SRC)

   # 生成可执行文件
   add_executable(core_main ${SOURCE_SRC} ${SOURCE_HEAD})

   # 链接 Poco 库
   target_link_libraries(core_main PRIVATE core_base PocoFoundation PocoNet PocoUtil)
   ```

### 2. 使用 `find_package`

Poco 库支持 CMake 的 `find_package` 命令，这使得引入库更加简洁和自动化。

#### 步骤

1. **确保 Poco 库安装在系统路径中**，或者设置 `CMAKE_PREFIX_PATH` 指向 Poco 库的安装路径。

2. **在 CMakeLists.txt 文件中使用 `find_package`**：

   ```cmake
   cmake_minimum_required(VERSION 3.8)

   project(SalCore)

   # 设置项目基础路径
   set(base_srcdir ${PROJECT_SOURCE_DIR})

   # 找到 Poco 库
   find_package(Poco REQUIRED COMPONENTS Foundation Net Util)

   # 包含头文件路径
   include_directories(${Poco_INCLUDE_DIRS})

   # 添加子目录
   add_subdirectory(core_base)
   add_subdirectory(core_main)
   ```

3. **链接 Poco 库**：

   在需要使用 Poco 库的目标中，添加链接库。

   ```cmake
   # core_main/CMakeLists.txt

   cmake_minimum_required(VERSION 3.8)

   project(core_main)

   # 库生成路径
   set(EXECUTABLE_OUTPUT_DIRECTORY ${base_srcdir}/out)

   # 头文件
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_main/include)
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_base/include)

   # 源文件
   file(GLOB_RECURSE SOURCE_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
   aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SOURCE_SRC)

   # 生成可执行文件
   add_executable(core_main ${SOURCE_SRC} ${SOURCE_HEAD})

   # 链接 Poco 库
   target_link_libraries(core_main PRIVATE core_base Poco::Foundation Poco::Net Poco::Util)
   ```

### 3. 使用 `ExternalProject` 下载和构建 Poco

如果您希望在构建过程中自动下载和构建 Poco 库，可以使用 CMake 的 `ExternalProject` 模块。

#### 步骤

1. **在 CMakeLists.txt 文件中添加 `ExternalProject` 配置**：

   ```cmake
   cmake_minimum_required(VERSION 3.8)

   project(SalCore)

   include(ExternalProject)

   # 设置项目基础路径
   set(base_srcdir ${PROJECT_SOURCE_DIR})

   # 下载并构建 Poco 库
   ExternalProject_Add(
       Poco
       GIT_REPOSITORY https://github.com/pocoproject/poco.git
       GIT_TAG master
       CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${base_srcdir}/thirdparty/poco
       UPDATE_DISCONNECTED 1
   )

   # 包含头文件路径
   include_directories(${base_srcdir}/thirdparty/poco/include)

   # 链接库文件路径
   link_directories(${base_srcdir}/thirdparty/poco/lib)

   # 添加子目录
   add_subdirectory(core_base)
   add_subdirectory(core_main)
   ```

2. **确保在需要使用 Poco 库的目标中添加依赖**：

   ```cmake
   # core_main/CMakeLists.txt

   cmake_minimum_required(VERSION 3.8)

   project(core_main)

   # 库生成路径
   set(EXECUTABLE_OUTPUT_DIRECTORY ${base_srcdir}/out)

   # 头文件
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_main/include)
   target_include_directories(core_main PRIVATE ${base_srcdir}/core_base/include)

   # 源文件
   file(GLOB_RECURSE SOURCE_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
   aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SOURCE_SRC)

   # 生成可执行文件
   add_executable(core_main ${SOURCE_SRC} ${SOURCE_HEAD})

   # 添加依赖
   add_dependencies(core_main Poco)

   # 链接 Poco 库
   target_link_libraries(core_main PRIVATE core_base PocoFoundation PocoNet PocoUtil)
   ```

### 示例项目结构

确保您的项目结构清晰，并且各个模块的 `CMakeLists.txt` 文件配置正确：

```
SalCore/
├── CMakeLists.txt
├── core_base/
│   ├── CMakeLists.txt
│   ├── include/
│   │   └── *.h
│   └── src/
│       └── *.cpp
├── core_main/
│   └── CMakeLists.txt
├── thirdparty/
│   └── poco/
│       ├── CMakeLists.txt
│       ├── include/
│       │   └── *.h
│       └── src/
│           └── *.cpp
└── thirdparty_sal/
    └── ...
```

通过上述步骤，您应该能够成功将 Poco 库引入到您的 CMake 工程中。选择适合您的方式，并确保路径和依赖关系配置正确。


## apr库的修改

我自己手动复制了apr.hw文件内容到apr.h文件

apr库的cmake文件把test的option(APR_BUILD_TESTAPR "Build the test suite" OFF)关掉，然后需要删除out



## 我的修改点

去掉了switch_bool_t这个无用的东西

为了展示如何管理多个插件，并且支持插件间通过核心模块进行通信，我们需要编写两个独立的插件，并在主程序中加载它们。以下是详细的实现步骤。



## tmp

### 1. 定义核心模块接口

**core.h**

```c
#ifndef CORE_H
#define CORE_H

#include <apr-1/apr_pools.h>
#include <apr-1/apr_hash.h>

typedef void (*core_callback_t)(const char *message);

void core_initialize(apr_pool_t *pool);
void core_shutdown(void);
void core_register_callback(const char *name, core_callback_t cb);
void core_invoke_callback(const char *name, const char *message);

#endif // CORE_H
```

### 2. 实现核心模块

**core.c**

```c
#include "core.h"
#include <stdio.h>

static apr_pool_t *core_pool = NULL;
static apr_hash_t *callbacks = NULL;

void core_initialize(apr_pool_t *pool) {
    core_pool = pool;
    callbacks = apr_hash_make(core_pool);
    printf("Core initialized.\n");
}

void core_shutdown(void) {
    callbacks = NULL;
    core_pool = NULL;
    printf("Core shutdown.\n");
}

void core_register_callback(const char *name, core_callback_t cb) {
    apr_hash_set(callbacks, name, APR_HASH_KEY_STRING, cb);
    printf("Callback '%s' registered.\n", name);
}

void core_invoke_callback(const char *name, const char *message) {
    core_callback_t cb = apr_hash_get(callbacks, name, APR_HASH_KEY_STRING);
    if (cb) {
        cb(message);
    }
}
```

### 3. 定义插件接口

**plugin.h**

```c
#ifndef PLUGIN_H
#define PLUGIN_H

#include "core.h"

typedef struct {
    void (*initialize)(apr_pool_t *pool);
    void (*shutdown)(void);
} plugin_t;

#endif // PLUGIN_H
```

### 4. 实现第一个插件

**plugin1.c**

```c
#include "plugin.h"
#include <stdio.h>

static void plugin1_initialize(apr_pool_t *pool) {
    core_register_callback("plugin1_callback", (core_callback_t)printf);
    printf("Plugin1 initialized\n");
}

static void plugin1_shutdown(void) {
    printf("Plugin1 shutdown\n");
}

plugin_t plugin1 = {
    .initialize = plugin1_initialize,
    .shutdown = plugin1_shutdown
};

plugin_t* get_plugin(void) {
    return &plugin1;
}
```

### 5. 实现第二个插件

**plugin2.c**

```c
#include "plugin.h"
#include <stdio.h>

static void plugin2_initialize(apr_pool_t *pool) {
    core_register_callback("plugin2_callback", (core_callback_t)printf);
    printf("Plugin2 initialized\n");
}

static void plugin2_shutdown(void) {
    printf("Plugin2 shutdown\n");
}

plugin_t plugin2 = {
    .initialize = plugin2_initialize,
    .shutdown = plugin2_shutdown
};

plugin_t* get_plugin(void) {
    return &plugin2;
}
```

### 6. 实现插件框架

**plugin_framework.h**

```c
#ifndef PLUGIN_FRAMEWORK_H
#define PLUGIN_FRAMEWORK_H

#include "plugin.h"
#include <apr-1/apr_dso.h>

typedef struct {
    apr_dso_handle_t *dso;
    plugin_t *plugin;
} plugin_handle_t;

int load_plugin(plugin_handle_t *handle, const char *path, apr_pool_t *pool);
void unload_plugin(plugin_handle_t *handle);

#endif // PLUGIN_FRAMEWORK_H
```

**plugin_framework.c**

```c
#include "plugin_framework.h"
#include <stdio.h>

typedef plugin_t* (*get_plugin_func_t)(void);

int load_plugin(plugin_handle_t *handle, const char *path, apr_pool_t *pool) {
    if (apr_dso_load(&handle->dso, path, pool) != APR_SUCCESS) {
        fprintf(stderr, "Failed to load plugin: %s\n", path);
        return -1;
    }

    get_plugin_func_t get_plugin;
    if (apr_dso_sym((apr_dso_handle_sym_t*)&get_plugin, handle->dso, "get_plugin") != APR_SUCCESS) {
        fprintf(stderr, "Failed to find symbol: get_plugin\n");
        apr_dso_unload(handle->dso);
        return -1;
    }

    handle->plugin = get_plugin();
    handle->plugin->initialize(pool);

    return 0;
}

void unload_plugin(plugin_handle_t *handle) {
    if (handle->plugin) {
        handle->plugin->shutdown();
    }
    if (handle->dso) {
        apr_dso_unload(handle->dso);
    }
}
```

### 7. 编写主程序

**main.c**

```c
#include "core.h"
#include "plugin_framework.h"
#include <apr-1/apr_general.h>
#include <apr-1/apr_pools.h>

int main(int argc, char *argv[]) {
    apr_initialize();
    apr_pool_t *pool;
    apr_pool_create(&pool, NULL);

    core_initialize(pool);

    plugin_handle_t handle1, handle2;
    if (load_plugin(&handle1, "./plugin1.so", pool) != 0) {
        apr_pool_destroy(pool);
        apr_terminate();
        return -1;
    }

    if (load_plugin(&handle2, "./plugin2.so", pool) != 0) {
        unload_plugin(&handle1);
        apr_pool_destroy(pool);
        apr_terminate();
        return -1;
    }

    core_invoke_callback("plugin1_callback", "Hello from main to Plugin1");
    core_invoke_callback("plugin2_callback", "Hello from main to Plugin2");

    unload_plugin(&handle2);
    unload_plugin(&handle1);
    core_shutdown();

    apr_pool_destroy(pool);
    apr_terminate();
    return 0;
}
```

### 8. 编译和运行

编译插件和主程序：

```sh
gcc -shared -o plugin1.so plugin1.c -fPIC $(apr-1-config --cflags --libs)
gcc -shared -o plugin2.so plugin2.c -fPIC $(apr-1-config --cflags --libs)
gcc -o main main.c core.c plugin_framework.c $(apr-1-config --cflags --libs)
./main
```

### 总结

这个示例展示了如何使用 APR 实现一个核心模块和多个动态加载模块，并通过核心模块进行模块间通信。APR 提供了跨平台的动态库加载功能，使得这种实现变得相对简单和高效。通过这种方法，可以实现一个模块化的系统，方便插件的开发和管理。