## å…¶ä»–

### 48 æ—‹è½¬å›¾åƒ

#### æ–¹æ³•1ï¼šåŸåœ°æ—‹è½¬

éœ€è¦ä¸€ä¸ªä¸€ä¸ªå»æ¨

![1678801241765](assets/1678801241765.png)

![1678801266615](assets/1678801266615.png)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < (n + 1) / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }

    }
};
```



### 75 é¢œè‰²åˆ†ç±»

#### æ–¹æ³•1ï¼šå•æŒ‡é’ˆ

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        // ç”¨ptrè¡¨ç¤ºå¤´éƒ¨çš„èŒƒå›´
        // ä»0åˆ°ptr-1éƒ½å±äºå¤´éƒ¨
        int ptr = 0;
        // æŠŠ0éƒ½äº¤æ¢åˆ°å¤´éƒ¨çš„èŒƒå›´
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
		// ä»0åé¢å¼€å§‹ï¼ŒæŠŠ1éƒ½äº¤æ¢åˆ°å¤´éƒ¨çš„èŒƒå›´
        for (int i = ptr; i < n; i++) {
            if (nums[i] == 1) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
    }
};
```



### 152 ä¹˜ç§¯æœ€å¤§å­åºåˆ—

#### æ–¹æ³•1ï¼š

![1678933870074](assets/1678933870074.png)

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int resMax=INT_MIN, imax = 1, imin = 1;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0) {
                int tmp = imax;
                imax = imin;
                imin = tmp;
            }

            imax = max(imax * nums[i], nums[i]);
            imin = min(imin * nums[i], nums[i]);
            resMax = max(resMax, imax);
        }
        return resMax;
    }
};
```



### 560 å’Œä¸ºKçš„å­æ•°ç»„

#### æ–¹æ³•1ï¼šå‰ç¼€è¡¨+å“ˆå¸Œè¡¨ä¼˜åŒ–

![1678938245355](assets/1678938245355.png)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto x : nums) {
            pre += x;
            if (mp.find(pre - k) != mp.end()) {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }
};
```



### 560 å’Œä¸ºKçš„å­æ•°ç»„

#### æ–¹æ³•1ï¼šå“ˆå¸Œè¡¨+å‰ç¼€å’Œ

![1678955718128](assets/1678955718128.png)

![1678955730862](assets/1678955730862.png)

éå†numsä¹‹å‰ï¼Œè®©-1å¯¹åº”çš„å‰ç¼€å’Œä¸º0ï¼Œè¿™æ ·é€šå¼åœ¨è¾¹ç•Œæƒ…å†µä¹Ÿæˆç«‹ã€‚å³åœ¨éå†ä¹‹å‰ï¼Œmapåˆå§‹æ”¾å…¥0:1é”®å€¼å¯¹ï¼ˆå‰ç¼€å’Œä¸º0å‡ºç°1æ¬¡äº†ï¼‰

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto& x : nums) {
            // éå†numsæ•°ç»„ï¼Œæ±‚æ¯ä¸€é¡¹çš„å‰ç¼€å’Œ
            pre += x;
            // è¾¹å­˜è¾¹æŸ¥çœ‹mpï¼Œå¦‚æœmpä¸­å­˜åœ¨keyä¸º[å½“å‰å‰ç¼€å’Œ-k],
            // è¯´æ˜ä¹‹å‰å‡ºç°è¿‡å‰ç¼€å’Œæ»¡è¶³ï¼šprefixSum[j]-prefixSum[i-1]=k
            if (mp[pre-k]>0) {
                // å°†è¿™æ ·å‰ç¼€å’Œçš„ä¸ªæ•°ç´¯åŠ ç»™count
                count += mp[pre - k];
            }
            // ç»Ÿè®¡è¯¥å‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°ï¼Œä»¥é”®å€¼å¯¹å­˜å…¥å“ˆå¸Œè¡¨mp
            mp[pre]++;
        }
        return count;
    }
};
```



### 238 é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯

#### æ–¹æ³•1ï¼š

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int length = nums.size();

        // L å’Œ R åˆ†åˆ«è¡¨ç¤ºå·¦å³ä¸¤ä¾§çš„ä¹˜ç§¯åˆ—è¡¨
        vector<int> L(length, 0), R(length, 0);

        vector<int> answer(length);

        // L[i] ä¸ºç´¢å¼• i å·¦ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯
        // å¯¹äºç´¢å¼•ä¸º '0' çš„å…ƒç´ ï¼Œå› ä¸ºå·¦ä¾§æ²¡æœ‰å…ƒç´ ï¼Œæ‰€ä»¥ L[0] = 1
        L[0] = 1;
        for (int i = 1; i < length; i++) {
            L[i] = nums[i - 1] * L[i - 1];
        }

        // R[i] ä¸ºç´¢å¼• i å³ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯
        // å¯¹äºç´¢å¼•ä¸º 'length-1' çš„å…ƒç´ ï¼Œå› ä¸ºå³ä¾§æ²¡æœ‰å…ƒç´ ï¼Œæ‰€ä»¥ R[length-1] = 1
        R[length - 1] = 1;
        for (int i = length - 2; i >= 0; i--) {
            R[i] = nums[i + 1] * R[i + 1];
        }

        // å¯¹äºç´¢å¼• iï¼Œé™¤ nums[i] ä¹‹å¤–å…¶ä½™å„å…ƒç´ çš„ä¹˜ç§¯å°±æ˜¯å·¦ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯ä¹˜ä»¥å³ä¾§æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯
        for (int i = 0; i < length; i++) {
            answer[i] = L[i] * R[i];
        }
        return answer;
    }
};

```



### 621. ä»»åŠ¡è°ƒåº¦å™¨

[ã€ä»»åŠ¡è°ƒåº¦å™¨ã€‘C++ æ¡¶å­_é…å›¾ç†è§£ - ä»»åŠ¡è°ƒåº¦å™¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/task-scheduler/solution/tong-zi-by-popopop/)

![image.png](assets/893c01db5923889a865d7a4fe71de22b9519fc5a673473196ab58f26c1073ed2-image.png)

1ã€è®°å½•æœ€å¤§ä»»åŠ¡æ•°é‡ Nï¼Œçœ‹ä¸€ä¸‹ä»»åŠ¡æ•°é‡å¹¶åˆ—æœ€å¤šçš„ä»»åŠ¡æœ‰å¤šå°‘ä¸ªï¼Œå³æœ€åä¸€ä¸ªæ¡¶å­çš„ä»»åŠ¡æ•° Xï¼Œè®¡ç®— NUM1=(N-1)*(n+1)+x

2ã€NUM2=tasks.size()
è¾“å‡ºå…¶ä¸­è¾ƒå¤§å€¼å³å¯
å› ä¸ºå­˜åœ¨ç©ºé—²æ—¶é—´æ—¶è‚¯å®šæ˜¯ NUM1 å¤§ï¼Œä¸å­˜åœ¨ç©ºé—²æ—¶é—´æ—¶è‚¯å®šæ˜¯ NUM2>=NUM1

```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        int len=tasks.size();
        vector<int> vec(26);
        for(auto c:tasks){
            vec[c-'A']++;
        }
        int cnt=1;
        // é™åºæ’åˆ—
        sort(vec.begin(), vec.end() ,[](const int& x, const int& y){return x>y;});
        // cntå°±æ˜¯æœ€åä¸€è¡Œçš„ä¸ªæ•°
        while(cnt<vec.size() && vec[cnt]==vec[0]) cnt++;
        return max(len, cnt+(n+1)*(vec[0]-1));
    }

};
```



### 399. é™¤æ³•æ±‚å€¼

[ğŸ¦ 399. é™¤æ³•æ±‚å€¼ - é™¤æ³•æ±‚å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/)

å¾ˆéš¾ï¼Œä¸æ‡‚

```cpp
class UnionFind {
private:
    vector<int> parent; // å­˜æ”¾çˆ¶èŠ‚ç‚¹
    vector<double> weight; // æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æƒå€¼
    
public:
    UnionFind(int n) {
        for (int i = 0; i < n; ++i) {
            parent.push_back(i);
            weight.push_back(1.0); // æƒé‡åˆå§‹åŒ–ä¸º1
        }
    }
    // è·¯å¾„å‹ç¼©ã€‚è¿”å›æ ¹èŠ‚ç‚¹id
    int find(int x) {
        // é€’å½’å¯»æ‰¾æ ¹èŠ‚ç‚¹ï¼Œæ›´æ–°è¯¥ç‚¹åˆ°æ ¹çš„æƒé‡ä¸ºè¯¥ç‚¹çˆ¶èŠ‚ç‚¹åˆ°æ ¹çš„æƒé‡
        if (x != parent[x]) {
            int origin = parent[x];
            parent[x] = find(parent[x]);
            weight[x] *= weight[origin];
        }
        return parent[x];
    }
    // è¿”å›é™¤æ³•ç»“æœã€‚å¦‚æœä¸¤ä¸ªå€¼ä¸å­˜åœ¨åˆ™-1
    double isConected(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        // å¦‚æœä¸¤ä¸ªå€¼æœ‰å…±åŒçš„æ ¹ä¹Ÿå°±æ˜¯å¯ä»¥è®¡ç®—ï¼Œåˆ™ç®—ç»“æœã€‚å¦åˆ™ä¸åœ¨åŒä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œ-1
        if (rootX == rootY) {
            return weight[x] / weight[y];
        } else {
            return -1.00000;
        }
    }
    void myunion(int x, int y, double value) {
        // åˆ†åˆ«æ‰¾åˆ°äºŒè€…çš„æ ¹èŠ‚ç‚¹
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) {
            return; // äºŒè€…å·²ç»æŒ‡å‘åŒä¸€ä¸ªæ ¹èŠ‚ç‚¹
        }
        // ä»¤åˆ†å­æŒ‡å‘åˆ†æ¯çš„æ ¹èŠ‚ç‚¹ï¼Œæƒé‡ä¸ºåˆ†æ¯åˆ°æ ¹çš„æƒé‡*åˆ†æ¯é™¤åˆ†å­çš„å€¼/åˆ†å­åˆ°æ ¹çš„æƒé‡ã€‚ä¸€å¼€å§‹éƒ½æ˜¯1
        parent[rootX] = rootY;
        weight[rootX] = weight[y] * value / weight[x];
    }
};
class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        // åˆå§‹åŒ–å¹¶æŸ¥é›†
        int equationsSize = equations.size();
        UnionFind unionFind(2 * equationsSize);
        // ç¬¬ 1 æ­¥ï¼šé¢„å¤„ç†ï¼Œå°†å˜é‡çš„å€¼ä¸ id è¿›è¡Œæ˜ å°„
        map<string, int> hashMap;
        int id = 0;
        for (int i = 0; i < equationsSize; ++i) {
            // å­˜åˆ†å­ï¼Œåˆ†æ¯ï¼Œå€¼ä¸ºid
            vector<string> equation = equations[i];
            string var1 = equation[0];
            string var2 = equation[1];
            if (!hashMap.count(var1)) {
                hashMap[var1] = id;
                ++id;
            }
            if (!hashMap.count(var2)) {
                hashMap[var2] = id;
                ++id;
            }
            // æŠŠåˆ†å­åˆ†æ¯ç”¨æœ‰å‘è¾¹è¿èµ·æ¥
            unionFind.myunion(hashMap[var1], hashMap[var2], values[i]);
        }
        // ç¬¬ 2 æ­¥ï¼šåšæŸ¥è¯¢
        int queriesSize = queries.size();
        vector<double> res(queriesSize, -1.00000);
        for (int i = 0; i < queriesSize; ++i) {
            string var1 = queries[i][0];
            string var2 = queries[i][1];
            int id1, id2;
            // å¦‚æœä¸¤ä¸ªå€¼æœ‰è‡³å°‘ä¸€ä¸ªä¸åœ¨equationsä¸­ï¼Œç»“æœä¸º-1ï¼Œå¦åˆ™åšé™¤æ³•
            if (hashMap.count(var1) && hashMap.count(var2)) {
                id1 = hashMap[var1];
                id2 = hashMap[var2];
                res[i] = unionFind.isConected(id1, id2);
            }
        }
        return res;
    }
};
```



å½“è§£å†³è¿™ä¸ªé—®é¢˜æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ‹“æ‰‘æ’åºçš„æ€è·¯æ¥åˆ¤æ–­æ˜¯å¦å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ã€‚

æ‹“æ‰‘æ’åºæ˜¯ä¸€ç§å¯¹æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰è¿›è¡Œæ’åºçš„ç®—æ³•ã€‚åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œè¯¾ç¨‹ä¹‹é—´çš„ä¾èµ–å…³ç³»å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªæœ‰å‘å›¾ï¼Œå…¶ä¸­è¯¾ç¨‹è¡¨ç¤ºå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œå…ˆä¿®è¯¾ç¨‹å…³ç³»è¡¨ç¤ºèŠ‚ç‚¹ä¹‹é—´çš„æœ‰å‘è¾¹ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸€ç§æ‹“æ‰‘æ’åºï¼Œå³æ˜¯å¦å­˜åœ¨ä¸€ç§å­¦ä¹ è¯¾ç¨‹çš„é¡ºåºï¼Œæ»¡è¶³æ‰€æœ‰çš„ä¾èµ–å…³ç³»ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å…¥åº¦ï¼ˆin-degreeï¼‰æ•°ç»„å’Œé‚»æ¥è¡¨æ¥è¡¨ç¤ºæœ‰å‘å›¾ã€‚**å…¥åº¦æ•°ç»„è®°å½•æ¯é—¨è¯¾ç¨‹çš„å…¥åº¦ï¼Œå³æœ‰å¤šå°‘é—¨è¯¾ç¨‹ä¾èµ–äºå®ƒ**ï¼›**é‚»æ¥è¡¨è®°å½•æ¯é—¨è¯¾ç¨‹çš„åç»­è¯¾ç¨‹ï¼Œå³å®ƒä¾èµ–çš„å…¶ä»–è¯¾ç¨‹**ã€‚

å…·ä½“çš„è§£å†³æ€è·¯å¦‚ä¸‹ï¼š

1. æ ¹æ®è¾“å…¥çš„å…ˆä¿®è¯¾ç¨‹å…³ç³»ï¼Œæ„å»ºæœ‰å‘å›¾çš„é‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„ã€‚éå†å…ˆä¿®è¯¾ç¨‹å…³ç³»åˆ—è¡¨ï¼Œå¯¹äºæ¯ä¸ªå…³ç³» `[ai, bi]`ï¼Œè¡¨ç¤ºè¯¾ç¨‹ `ai` ä¾èµ–äºè¯¾ç¨‹ `bi`ï¼Œæˆ‘ä»¬åœ¨é‚»æ¥è¡¨ä¸­å°† `bi` æ·»åŠ åˆ° `ai` çš„åç»­è¯¾ç¨‹åˆ—è¡¨ä¸­ï¼Œå¹¶å°† `ai` çš„å…¥åº¦åŠ  1ã€‚

2. åˆå§‹åŒ–ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå°†å…¥åº¦ä¸º 0 çš„è¯¾ç¨‹å…¥é˜Ÿã€‚è¿™äº›è¯¾ç¨‹æ²¡æœ‰ä»»ä½•å…ˆä¿®è¯¾ç¨‹è¦æ±‚ï¼Œå¯ä»¥ç›´æ¥å­¦ä¹ ã€‚

3. ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰çš„æ–¹å¼è¿›è¡Œæ‹“æ‰‘æ’åºã€‚ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªè¯¾ç¨‹ï¼Œè¡¨ç¤ºå­¦ä¹ äº†è¯¥è¯¾ç¨‹ï¼Œå°†å­¦ä¹ çš„è¯¾ç¨‹æ•°é‡åŠ  1ã€‚ç„¶åéå†è¯¥è¯¾ç¨‹çš„åç»­è¯¾ç¨‹åˆ—è¡¨ï¼Œåœ¨å…¥åº¦æ•°ç»„ä¸­å°†åç»­è¯¾ç¨‹çš„å…¥åº¦å‡ 1ã€‚å¦‚æœæŸä¸ªåç»­è¯¾ç¨‹çš„å…¥åº¦å‡ä¸º 0ï¼Œè¡¨ç¤ºå®ƒçš„æ‰€æœ‰å…ˆä¿®è¯¾ç¨‹éƒ½å·²å­¦ä¹ å®Œæ¯•ï¼Œå°†è¯¥è¯¾ç¨‹å…¥é˜Ÿã€‚

4. é‡å¤æ­¥éª¤ 3ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºã€‚å¦‚æœå­¦ä¹ çš„è¯¾ç¨‹æ•°é‡ç­‰äºæ€»è¯¾ç¨‹æ•°é‡ï¼Œè¯´æ˜å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Œè¿”å› trueï¼›å¦åˆ™ï¼Œè¿”å› falseã€‚

ä»¥ä¸Šæ˜¯è§£å†³è¯¥é—®é¢˜çš„æ€è·¯ã€‚ä¸‹é¢æ˜¯ç›¸åº”çš„ä»£ç å®ç°ï¼š

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> inDegree(numCourses, 0); // å…¥åº¦æ•°ç»„
    vector<vector<int>> adjacencyList(numCourses, vector<int>()); // é‚»æ¥è¡¨

    // æ„å»ºæœ‰å‘å›¾çš„é‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    for (const auto& prerequisite : prerequisites) {
        int course = prerequisite[0];
        int prerequisiteCourse = prerequisite[1];
        adjacencyList[prerequisiteCourse].push_back(course); // å°†è¯¾ç¨‹ course æ·»åŠ åˆ° prerequisiteCourse çš„åç»­è¯¾ç¨‹åˆ—è¡¨ä¸­
        inDegree[course]++; // course çš„å…¥åº¦åŠ  1
    }

    queue<int> q;

    // å°†å…¥åº¦ä¸º 0 çš„è¯¾ç¨‹å…¥é˜Ÿ
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    int count = 0; // è®°å½•å·²å­¦ä¹ çš„è¯¾ç¨‹æ•°é‡

    while (!q.empty()) {
        int course = q.front();
        q.pop();
        count++;

        // éå†å½“å‰è¯¾ç¨‹çš„åç»­è¯¾ç¨‹
        for (int nextCourse : adjacencyList[course]) {
            inDegree[nextCourse]--; // å°†åç»­è¯¾ç¨‹çš„å…¥åº¦å‡ 1
            if (inDegree[nextCourse] == 0) {
                q.push(nextCourse); // å…¥åº¦ä¸º 0 çš„è¯¾ç¨‹å…¥é˜Ÿ
            }
        }
    }

    return count == numCourses; // å¦‚æœå·²å­¦ä¹ çš„è¯¾ç¨‹æ•°é‡ç­‰äºæ€»è¯¾ç¨‹æ•°é‡ï¼Œåˆ™å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹å­¦ä¹ 
}

int main() {
    int numCourses;
    cout << "è¯·è¾“å…¥è¯¾ç¨‹æ•°é‡ï¼š";
    cin >> numCourses;

    int numPrerequisites;
    cout << "è¯·è¾“å…¥å…ˆä¿®è¯¾ç¨‹æ•°é‡ï¼š";
    cin >> numPrerequisites;

    vector<vector<int>> prerequisites(numPrerequisites, vector<int>(2));

    cout << "è¯·è¾“å…¥å…ˆä¿®è¯¾ç¨‹çš„ä¾èµ–å…³ç³»ï¼š\n";
    for (int i = 0; i < numPrerequisites; i++) {
        cin >> prerequisites[i][0] >> prerequisites[i][1];
    }

    bool canFinishAllCourses = canFinish(numCourses, prerequisites);

    cout << "æ˜¯å¦å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿ" << (canFinishAllCourses ? "æ˜¯" : "å¦") << endl;

    return 0;
}
```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆæ ¹æ®è¾“å…¥çš„å…ˆä¿®è¯¾ç¨‹å…³ç³»æ„å»ºäº†æœ‰å‘å›¾çš„é‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„ã€‚ç„¶åä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ã€‚æœ€åæ ¹æ®ç»“æœè¾“å‡ºç›¸åº”çš„ä¿¡æ¯ã€‚

å¸Œæœ›è¿™æ¬¡çš„è§£é‡Šæ›´åŠ è¯¦ç»†ï¼Œå¦‚æœè¿˜æœ‰å…¶ä»–é—®é¢˜ï¼Œè¯·éšæ—¶æé—®ã€‚



### 4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°

#### æ–¹æ³•1ï¼šåˆå¹¶åæ±‚ä¸­ä½æ•°

```cpp
class Solution {
public:
    vector<int> helper(vector<int>& nums1, vector<int>& nums2){
        int m=nums1.size(), n=nums2.size();
        vector<int> nums(m+n);
        int count=0;
        int i=0, j=0;
        while(i<m && j<n){
            if(nums1[i]<=nums2[j]){
                nums[count]=nums1[i];
                count++;
                i++;
            }
            else{
                nums[count]=nums2[j];
                count++;
                j++;
            }
        }
        if(i!=nums1.size()){
            while(i!=m){
                nums[count]=nums1[i];
                count++;
                i++;
            }
        }
        else{
            while(j!=n){
                nums[count]=nums2[j];
                count++;
                j++;
            }
        }
        return nums;
    }


    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nums=helper(nums1, nums2);
        double res;
        int len=nums.size();
        if(len%2==0){
            res=(nums[len/2-1]+nums[len/2])/2.0;
        }
        else{
            res=(double)nums[len/2];
        }
        return res;
    }
};
```



### 54. èºæ—‹çŸ©é˜µ

#### æ–¹æ³•1ï¼šå››ä¸ªæŒ‡é’ˆ

è§£å†³æ€è·¯ï¼š

1. å®šä¹‰å››ä¸ªå˜é‡ `top`, `bottom`, `left`, `right` åˆ†åˆ«è¡¨ç¤ºå½“å‰èºæ—‹éå†çš„ä¸Šè¾¹ç•Œã€ä¸‹è¾¹ç•Œã€å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œã€‚
2. åˆå§‹åŒ–è¿™äº›å˜é‡ï¼š`top = 0`, `bottom = m - 1`, `left = 0`, `right = n - 1`ã€‚
3. åˆ›å»ºä¸€ä¸ªç»“æœæ•°ç»„ `result`ï¼Œç”¨äºå­˜å‚¨èºæ—‹éå†çš„å…ƒç´ ã€‚
4. ä½¿ç”¨ä¸€ä¸ªå¾ªç¯è¿›è¡Œèºæ—‹éå†ï¼Œå¾ªç¯æ¡ä»¶æ˜¯ `top <= bottom` ä¸” `left <= right`ã€‚
5. åœ¨æ¯ä¸€æ¬¡å¾ªç¯ä¸­ï¼ŒæŒ‰ç…§é¡ºæ—¶é’ˆèºæ—‹çš„é¡ºåºéå†çŸ©é˜µçš„å¤–åœˆå…ƒç´ ï¼Œä¾æ¬¡å°†å…ƒç´ æ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­ã€‚
   - éå†ä¸Šè¾¹ç•Œï¼šä» `left` åˆ° `right`ï¼Œè¡Œå·ä¸º `top`ã€‚
   - éå†å³è¾¹ç•Œï¼šä» `top + 1` åˆ° `bottom`ï¼Œåˆ—å·ä¸º `right`ã€‚
   - éå†ä¸‹è¾¹ç•Œï¼šä» `right - 1` åˆ° `left`ï¼Œè¡Œå·ä¸º `bottom`ã€‚
   - éå†å·¦è¾¹ç•Œï¼šä» `bottom - 1` åˆ° `top + 1`ï¼Œåˆ—å·ä¸º `left`ã€‚
6. æ¯æ¬¡éå†å®Œä¸€æ¡è¾¹ç•Œåï¼Œæ›´æ–°è¾¹ç•Œå€¼ï¼Œå³ `top++`, `bottom--`, `left++`, `right--`ã€‚
7. å¾ªç¯ç»“æŸåï¼Œè¿”å›ç»“æœæ•°ç»„ `result`ã€‚

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result; // å­˜å‚¨èºæ—‹éå†çš„ç»“æœ
        
        if (matrix.empty()) {
            return result;
        }
        
        int m = matrix.size(); // çŸ©é˜µçš„è¡Œæ•°
        int n = matrix[0].size(); // çŸ©é˜µçš„åˆ—æ•°
        
        int top = 0; // ä¸Šè¾¹ç•Œ
        int bottom = m - 1; // ä¸‹è¾¹ç•Œ
        int left = 0; // å·¦è¾¹ç•Œ
        int right = n - 1; // å³è¾¹ç•Œ
        
        while (top <= bottom && left <= right) {
            // éå†ä¸Šè¾¹ç•Œ
            for (int i = left; i <= right; i++) {
                result.push_back(matrix[top][i]);
            }
            top++;
            
            // éå†å³è¾¹ç•Œ
            for (int i = top; i <= bottom; i++) {
                result.push_back(matrix[i][right]);
            }
            right--;
            
            // éå†ä¸‹è¾¹ç•Œ 
            if (top <= bottom) { //å› ä¸ºå‰é¢++ï¼Œå¿…é¡»è¦å†åˆ¤æ–­ä¸€ä¸‹æ˜¯ä¸æ˜¯è¿˜æ»¡è¶³è¾¹ç•Œæ¡ä»¶ï¼Œä¸ç„¶ä¼šé‡å¤éå†
                for (int i = right; i >= left; i--) {
                    result.push_back(matrix[bottom][i]);
                }
                bottom--;
            }
            
            // éå†å·¦è¾¹ç•Œ
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    result.push_back(matrix[i][left]);
                }
                left++;
            }
        }
        
        return result;
    }
};
```





### 179. æœ€å¤§æ•°

#### æ–¹æ³•1ï¼šæ¨¡æ¿ç‰¹åŒ–

```cpp
class Solution {
public:
    static bool compare(int a, int b) {
        string str1 = to_string(a);
        string str2 = to_string(b);

        // å°†ä¸¤ä¸ªå­—ç¬¦ä¸²æ‹¼æ¥èµ·æ¥ï¼Œæ¯”è¾ƒæ‹¼æ¥åçš„ç»“æœå¤§å°
        return str1 + str2 > str2 + str1;
    }

    string largestNumber(vector<int>& nums) {
        // å¯¹ nums ä¸­çš„æ•°å­—è¿›è¡Œæ’åºï¼Œæ’åºè§„åˆ™ä¸º compare å‡½æ•°
        sort(nums.begin(), nums.end(), compare);

        // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼Œå¦‚æœæœ€å¤§çš„æ•°å­—æ˜¯ 0ï¼Œåˆ™ç›´æ¥è¿”å› "0"
        if (nums[0] == 0) {
            return "0";
        }

        // å°†æ’åºåçš„æ•°å­—æ‹¼æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²
        string result;
        for (int num : nums) {
            result += to_string(num);
        }

        return result;
    }
};
```





### 440. å­—å…¸åºçš„ç¬¬Kå°æ•°å­—

`findKthNumber` å‡½æ•°æ˜¯ä¸»è¦çš„è§£å†³é—®é¢˜çš„å‡½æ•°ã€‚å®ƒé€šè¿‡æ¨¡æ‹Ÿå­—å…¸åºçš„ç”Ÿæˆè¿‡ç¨‹æ¥æ‰¾åˆ°å­—å…¸åºç¬¬ k å°çš„æ•°å­—ã€‚åœ¨æ¯ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬è®¡ç®—å½“å‰æ•°å­—åˆ°ä¸‹ä¸€ä¸ªæ•°å­—çš„æ­¥æ•°ï¼Œç„¶åæ ¹æ®æ­¥æ•°å†³å®šæ˜¯è¿›å…¥ä¸‹ä¸€ä¸ªæ•°å­—è¿˜æ˜¯è¿›å…¥ä¸‹ä¸€å±‚ã€‚é€šè¿‡å¾ªç¯è¿­ä»£ï¼Œç›´åˆ°æ‰¾åˆ°å­—å…¸åºç¬¬ k å°çš„æ•°å­—ã€‚

```cpp
class Solution {
public:
    int findKthNumber(int n, int k) {
        int curr = 1; // å½“å‰æ‰€åœ¨çš„æ•°å­—
        k--; // å‡å»ç¬¬ä¸€ä¸ªæ•°å­— 1
        while (k > 0) {
            long long steps = 0; // å½“å‰æ•°å­—åˆ°ä¸‹ä¸€ä¸ªæ•°å­—çš„æ­¥æ•°
            long long first = curr; // å½“å‰æ‰€åœ¨çš„æ•°å­—
            long long last = curr + 1; // ä¸‹ä¸€ä¸ªæ•°å­—
            // è®¡ç®—å½“å‰æ‰€åœ¨çš„æ•°å­—åˆ°ä¸‹ä¸€ä¸ªæ•°å­—çš„æ­¥æ•°
            while (first <= n) {
                steps += min(static_cast<long long>(n + 1), last) - first; // ä½¿ç”¨ static_cast è¿›è¡Œç±»å‹è½¬æ¢
                first *= 10; // å‘ä¸‹ä¸€å±‚è¿›ä¸€ä½
                last *= 10; // å‘ä¸‹ä¸€å±‚è¿›ä¸€ä½
            }
            if (steps <= k) {
                curr++; // è¿›å…¥ä¸‹ä¸€ä¸ªæ•°å­—
                k -= steps; // å‡å»å·²ç»è·³è¿‡çš„æ­¥æ•°
            } else {
                curr *= 10; // è¿›å…¥ä¸‹ä¸€å±‚
                k--; // è¿›å…¥ä¸‹ä¸€ä¸ªæ•°å­—
            }
        }
        return curr;
    }
};
```







### 498 å¯¹è§’çº¿éå†

![1689911611506](assets/1689911611506.png)

![1689911653443](assets/1689911653443.png)

```cpp
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) 
    {
        vector<int> nums;
        int m = matrix.size();
        if (m == 0) return nums;
        int n = matrix[0].size();
        if (n == 0) return nums;

        bool bXFlag = true;
        for (int i = 0; i < m + n; i++)
        {
            int pm = bXFlag ? m : n;
            int pn = bXFlag ? n : m;

            int x = (i < pm) ? i : pm - 1;
            int y = i - x;                

            while (x >= 0 && y < pn)
            {
                nums.push_back(bXFlag ? matrix[x][y] : matrix[y][x]);
                x--;
                y++;
            }

            bXFlag = !bXFlag;
        }
        return nums;
    }


};
```













### 224. åŸºæœ¬è®¡ç®—å™¨

![1689912013301](assets/1689912013301.png)

```
class Solution {
public:
    int calculate(string s) {
        stack<int> ops;
        ops.push(1);
        int sign = 1;

        int ret = 0;
        int n = s.length();
        int i = 0;
        while (i < n) {
            if (s[i] == ' ') {
                i++;
            } else if (s[i] == '+') {
                sign = ops.top();
                i++;
            } else if (s[i] == '-') {
                sign = -ops.top();
                i++;
            } else if (s[i] == '(') {
                ops.push(sign);
                i++;
            } else if (s[i] == ')') {
                ops.pop();
                i++;
            } else {
                long num = 0;
                while (i < n && s[i] >= '0' && s[i] <= '9') {
                    num = num * 10 + s[i] - '0';
                    i++;
                }
                ret += sign * num;
            }
        }
        return ret;
    }
};


```



### 7 æ•´æ•°åè½¬

```cpp
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while(x!=0) {
            //æ¯æ¬¡å–æœ«å°¾æ•°å­—
            int tmp = x%10;
            //åˆ¤æ–­æ˜¯å¦ å¤§äº æœ€å¤§32ä½æ•´æ•°
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //åˆ¤æ–­æ˜¯å¦ å°äº æœ€å°32ä½æ•´æ•°
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
    }
};
```





### 85. æœ€å¤§çŸ©å½¢

[æœ€å¤§çŸ©å½¢ - æœ€å¤§çŸ©å½¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode-solution-bjlu/)

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> left(m, vector<int>(n, 0));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;
                }
            }
        }

        int ret = 0;
        for (int j = 0; j < n; j++) { // å¯¹äºæ¯ä¸€åˆ—ï¼Œä½¿ç”¨åŸºäºæŸ±çŠ¶å›¾çš„æ–¹æ³•
            vector<int> up(m, 0), down(m, 0);

            stack<int> stk;
            for (int i = 0; i < m; i++) {
                while (!stk.empty() && left[stk.top()][j] >= left[i][j]) {
                    stk.pop();
                }
                up[i] = stk.empty() ? -1 : stk.top();
                stk.push(i);
            }
            stk = stack<int>();
            for (int i = m - 1; i >= 0; i--) {
                while (!stk.empty() && left[stk.top()][j] >= left[i][j]) {
                    stk.pop();
                }
                down[i] = stk.empty() ? m : stk.top();
                stk.push(i);
            }

            for (int i = 0; i < m; i++) {
                int height = down[i] - up[i] - 1;
                int area = height * left[i][j];
                ret = max(ret, area);
            }
        }
        return ret;
    }
};

```



### 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

#### æ–¹æ³•1ï¼šä¸€æ¬¡éå†

å¾ˆå–œæ¬¢çš„ä¸€ç§åšæ³•

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice=INT_MAX, maxProfit=0;
        for(auto price:prices){
            maxProfit=max(maxProfit, price-minPrice);
            minPrice=min(minPrice, price);
        }
        return maxProfit;
    } 
};

```

