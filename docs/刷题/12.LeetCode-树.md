## æ ‘

### 144 äºŒå‰æ ‘çš„å‰åºéå†

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& result) {
        if (cur == nullptr)  return;
        result.push_back(cur->val);
        traversal(cur->left,result);
        traversal(cur->right, result);

    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### æ–¹æ³•2ï¼šè¿­ä»£æ³•

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // ä¸­
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // å³ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            if (node->left) st.push(node->left);             // å·¦ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
        }
        return result;
    }
};
```

### 145 äºŒå‰æ ‘çš„ååºéå†

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    void helper(TreeNode* cur, vector<int>& result) {
        if (cur == nullptr) return;
        helper(cur->left, result);
        helper(cur->right, result);
        result.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        helper(root, result);
        return result;
    }
};
```

#### æ–¹æ³•2ï¼šååºéå†

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // ç›¸å¯¹äºå‰åºéå†ï¼Œè¿™æ›´æ”¹ä¸€ä¸‹å…¥æ ˆé¡ºåº ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            if (node->right) st.push(node->right); // ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆ
        }
        reverse(result.begin(), result.end()); // å°†ç»“æœåè½¬ä¹‹åå°±æ˜¯å·¦å³ä¸­çš„é¡ºåºäº†
        return result;
    }
};
```



### 94 äºŒå‰æ ‘çš„ä¸­åºéå†

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    void helper(TreeNode* cur, vector<int>& result) {
        if (cur == nullptr) return;
        helper(cur->left, result);
        result.push_back(cur->val);
        helper(cur->right, result);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>result;
        helper(root, result);
        return result;
    }
};
```

#### æ–¹æ³•2ï¼šè¿­ä»£æ³•

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
                st.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ
                cur = cur->left;                // å·¦
            } else {
                cur = st.top(); // ä»æ ˆé‡Œå¼¹å‡ºçš„æ•°æ®ï¼Œå°±æ˜¯è¦å¤„ç†çš„æ•°æ®ï¼ˆæ”¾è¿›resultæ•°ç»„é‡Œçš„æ•°æ®ï¼‰
                st.pop();
                result.push_back(cur->val);     // ä¸­
                cur = cur->right;               // å³
            }
        }
        return result;
    }
};
```



### 102 äºŒå‰æ ‘çš„å±‚åºéå†

#### æ–¹æ³•1ï¼šé˜Ÿåˆ—

![102äºŒå‰æ ‘çš„å±‚åºéå†](assets/kfw83421jkasfweaefwf.gif)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr) return result;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // è¿™é‡Œä¸€å®šè¦ä½¿ç”¨å›ºå®šå¤§å°sizeï¼Œä¸è¦ä½¿ç”¨que.size()ï¼Œå› ä¸ºque.sizeæ˜¯ä¸æ–­å˜åŒ–çš„
            // æ¯æ¬¡sizeå®Œï¼Œè¡¨ç¤ºä¸€å±‚
            for (int i = 0; i < size; ++i) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};

```







### 104 æ±‚äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

#### æ–¹æ³•ä¸€ï¼šé€’å½’è°ƒç”¨

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <queue>

// Definition for a binary tree node.
 struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 };
 
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        int m = maxDepth(root->left);
        int n = maxDepth(root->right);
        if (m > n) {
            return m + 1;
        }
        else {
            return n + 1;
        }
    }
};



//æ ¹æ®æ•°ç»„ï¼Œå±‚æ¬¡æ³•åˆ›å»ºäºŒå‰æ ‘
TreeNode* createTree(vector<int>& l_nums, int i) //å±‚æ¬¡æ³•åˆ›å»ºäºŒå‰æ ‘
{
    if (i >= l_nums.size() || l_nums[i] == 0) //æ•°å€¼ä¸º0æˆ–è¶…å‡ºæ•°ç»„èŒƒå›´
        return nullptr;
    TreeNode* root = new TreeNode(l_nums[i]);
    root->left = createTree(l_nums, i * 2 + 1);
    root->right = createTree(l_nums, i * 2 + 2);
    return root;
}


int main()
{
    vector<int> nums = { 3,9,20,0,0,15,7 };
    TreeNode* root = createTree(nums, 0);
    
    Solution ss;
    cout << ss.maxDepth(root) << endl;

    system("pause");
    return 0;
}
```



### 111 äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

#### æ–¹æ³•1ï¼šé€’å½’ï¼Œååºéå†

![111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](assets/20210203155800503.png)

- å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œå³å­æ ‘ä¸ä¸ºç©ºï¼Œè¯´æ˜æœ€å°æ·±åº¦æ˜¯ 1 + å³å­æ ‘çš„æ·±åº¦ã€‚
- å³å­æ ‘ä¸ºç©ºï¼Œå·¦å­æ ‘ä¸ä¸ºç©ºï¼Œæœ€å°æ·±åº¦æ˜¯ 1 + å·¦å­æ ‘çš„æ·±åº¦ã€‚ 
- æœ€åå¦‚æœå·¦å³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›å·¦å³å­æ ‘æ·±åº¦æœ€å°å€¼ + 1 ã€‚

```cpp
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == nullptr) return 0;
        int leftDepth = getDepth(node->left); // å·¦
        int rightDepth = getDepth(node->right); // å³

        // å·¦å­æ ‘ä¸ºç©ºï¼Œå³å­æ ‘ä¸ä¸ºç©ºï¼Œè¯´æ˜æœ€å°æ·±åº¦æ˜¯ 1 + å³å­æ ‘çš„æ·±åº¦
        if (node->left == nullptr && node->right != nullptr) {
            return 1 + rightDepth;
        }
        // å³å­æ ‘ä¸ºç©ºï¼Œå·¦å­æ ‘ä¸ä¸ºç©ºï¼Œæœ€å°æ·±åº¦æ˜¯ 1 + å·¦å­æ ‘çš„æ·±åº¦
        if (node->left != nullptr && node->right == nullptr) {
            return 1 + leftDepth;
        }
        // å¦‚æœå·¦å³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›å·¦å³å­æ ‘æ·±åº¦æœ€å°å€¼ + 1
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```



### 226 ç¿»è½¬äºŒå‰æ ‘

#### æ–¹æ³•1ï¼šå‰åºéå†é€’å½’

```cpp
class Solution {
public:
    // 1.ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼
    // è¿”å›å€¼çš„è¯å…¶å®ä¹Ÿä¸éœ€è¦ï¼Œä½†æ˜¯é¢˜ç›®ä¸­ç»™å‡ºçš„è¦è¿”å›rootèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨é¢˜ç›®å®šä¹‰å¥½çš„å‡½æ•°ï¼Œæ‰€ä»¥å°±å‡½æ•°çš„è¿”å›ç±»å‹ä¸ºTreeNode*ã€‚
    TreeNode* invertTree(TreeNode* root) {
        // 2.ç¡®å®šç»ˆæ­¢æ¡ä»¶
        // å½“å‰èŠ‚ç‚¹ä¸ºç©ºçš„æ—¶å€™ï¼Œå°±è¿”å›
        if (root == nullptr) return nullptr;
        // 3.ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘
        // å› ä¸ºæ˜¯å…ˆå‰åºéå†ï¼Œæ‰€ä»¥å…ˆè¿›è¡Œäº¤æ¢å·¦å³å­©å­èŠ‚ç‚¹ï¼Œç„¶ååè½¬å·¦å­æ ‘ï¼Œåè½¬å³å­æ ‘ã€‚
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

### 222 å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
private:
    // ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼šå‚æ•°å°±æ˜¯ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›å°±è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°é‡ï¼Œæ‰€ä»¥è¿”å›å€¼ä¸ºintç±»å‹ã€‚
    int getNodesNum(TreeNode* cur) {
        // ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼šå¦‚æœä¸ºç©ºèŠ‚ç‚¹çš„è¯ï¼Œå°±è¿”å›0ï¼Œè¡¨ç¤ºèŠ‚ç‚¹æ•°ä¸º0ã€‚
        if (cur == NULL) return 0;
        // ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘ï¼šå…ˆæ±‚å®ƒçš„å·¦å­æ ‘çš„èŠ‚ç‚¹æ•°é‡ï¼Œå†æ±‚å³å­æ ‘çš„èŠ‚ç‚¹æ•°é‡ï¼Œæœ€åå–æ€»å’Œå†åŠ ä¸€ ï¼ˆåŠ 1æ˜¯å› ä¸ºç®—ä¸Šå½“å‰ä¸­é—´èŠ‚ç‚¹ï¼‰å°±æ˜¯ç›®å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„èŠ‚ç‚¹æ•°é‡ã€‚
        int leftNum = getNodesNum(cur->left);      // å·¦
        int rightNum = getNodesNum(cur->right);    // å³
        int treeNum = leftNum + rightNum + 1;      // ä¸­
        return treeNum;
    }
public:
    int countNodes(TreeNode* root) {
        return getNodesNum(root);
    }
};
```



### 110 å¹³è¡¡äºŒå‰æ ‘

#### æ–¹æ³•ä¸€ï¼šè‡ªé¡¶å‘ä¸‹é€’å½’

```cpp
class Solution {
public:
	int height(TreeNode* root) {
		if (root == NULL) {
			return 0;
		}
		else {
			//è·å–å½“å‰å­æ ‘çš„æ·±åº¦
			return max(height(root->left), height(root->right)) + 1;
		}
	}

	bool isBalanced(TreeNode* root) {
		if (root == NULL) {
			return true;
		}
		else {
			//å·¦å³å­æ ‘çš„æ·±åº¦å·®çš†æ»¡è¶³æ¡ä»¶
			return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
		}
	}
};
```

### 543 äºŒå‰æ ‘çš„ç›´å¾„

#### æ–¹æ³•ä¸€ï¼šé€’å½’

```cpp
class Solution {
public:
	int maxDepth = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		depth(root);
		return maxDepth;
    }

	int depth(TreeNode* node) {
		if (!node) {
			return 0;
		}
		int left = depth(node->left);
		int right = depth(node->right);
		//å°†æ¯ä¸ªèŠ‚ç‚¹æœ€å¤§ç›´å¾„ï¼ˆå·¦å­æ ‘æ·±åº¦+å³å­æ ‘æ·±åº¦ï¼‰ä¸å½“å‰æœ€å¤§å€¼æ¯”è¾ƒå¹¶å–è¾ƒå¤§è€…
		maxDepth = max(left + right, maxDepth);
		//è¿”å›èŠ‚ç‚¹æ·±åº¦
		return max(left, right) + 1;
	}
};
```

### 437 è·¯å¾„æ€»å’ŒIII

#### æ–¹æ³•ä¸€ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé€’å½’

```C++
class Solution {
public:
	int pathSum(TreeNode* root, int targetSum) {
		if (root) {
			return pathSumStartWithRoot(root, targetSum) + 
				pathSum(root->left, targetSum) + pathSum(root->right, targetSum);
		}
		else {
			return 0;
		}
	}

	long long pathSumStartWithRoot(TreeNode* root, long long sum) {
		if (!root) {
			return 0;
		}

		long long count;
		if (root->val == sum) {
			count = 1;
		}
		else {
			count = 0;
		}

		count += pathSumStartWithRoot(root->left, sum - root->val);
		count += pathSumStartWithRoot(root->right, sum - root->val);
		return count;
	}
};
```

#### ç¬¬2æ¬¡ï¼šæ ‘çš„éå†+DFS

å®«æ°´ä¸‰å¶

[437. è·¯å¾„æ€»å’Œ III - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/path-sum-iii/solutions/1021490/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/)

![1693640782368](assets/1693640782368.png)

```cpp
class Solution {
    int ans, t;
public:
    int pathSum(TreeNode* root, int targetSum) {
        t = targetSum;
        dfs1(root);
        return ans;
    }
    
    void dfs1(TreeNode* root) {
        if (root == nullptr) return;
        dfs2(root, root->val);
        dfs1(root->left);
        dfs1(root->right);
    }
    
    void dfs2(TreeNode* root, long long val) {
        if (val == t) ans++;
        if (root->left != nullptr) dfs2(root->left, val + root->left->val);
        if (root->right != nullptr) dfs2(root->right, val + root->right->val);
    }
};
```





### 101 å¯¹ç§°äºŒå‰æ ‘

#### æ–¹æ³•ä¸€ï¼šé€’å½’

æ¯”è¾ƒçš„æ˜¯æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸å³å­æ ‘æ˜¯ä¸æ˜¯ç›¸äº’ç¿»è½¬çš„ï¼Œç†è§£è¿™ä¸€ç‚¹å°±çŸ¥é“äº†**å…¶å®æˆ‘ä»¬è¦æ¯”è¾ƒçš„æ˜¯ä¸¤ä¸ªæ ‘ï¼ˆè¿™ä¸¤ä¸ªæ ‘æ˜¯æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼‰**ï¼Œæ‰€ä»¥åœ¨é€’å½’éå†çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿæ˜¯è¦åŒæ—¶éå†ä¸¤æ£µæ ‘ã€‚

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <queue>

// Definition for a binary tree node.
struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};


class Solution {
public:
	bool isSymmetric(TreeNode* root) {
		if (root) {
			return isSymmetric(root->left, root->right);
		}
		else{
			return true;
		}
	}

	bool isSymmetric(TreeNode* left, TreeNode* right) {
		//å¦‚æœä¸¤ä¸ªå­æ ‘éƒ½ä¸ºç©ºæŒ‡é’ˆï¼Œåˆ™å®ƒä»¬ç›¸ç­‰æˆ–å¯¹ç§°
		if (!left && !right) {
			return true;
		}
		//å¦‚æœä¸¤ä¸ªå­æ ‘åªæœ‰ä¸€ä¸ªä¸ºç©ºæŒ‡é’ˆï¼Œåˆ™å®ƒä»¬ä¸ç›¸ç­‰æˆ–ä¸å¯¹ç§°
		if (!left || !right) {
			return false;
		}
		//å¦‚æœä¸¤ä¸ªå­æ ‘æ ¹ç»“ç‚¹çš„å€¼ä¸ç›¸ç­‰ï¼Œåˆ™å®ƒä»¬ä¸ç›¸ç­‰æˆ–ä¸å¯¹ç§°
		if (left->val != right->val) {
			return false;
		}
		return isSymmetric(left->left, right->right) && isSymmetric(left->right, right->left);
	}
};


//æ ¹æ®æ•°ç»„ï¼Œå±‚æ¬¡æ³•åˆ›å»ºäºŒå‰æ ‘
TreeNode* createTree(vector<int>& l_nums, int i) //å±‚æ¬¡æ³•åˆ›å»ºäºŒå‰æ ‘
{
	if (i >= l_nums.size() || l_nums[i] == 0) //æ•°å€¼ä¸º0æˆ–è¶…å‡ºæ•°ç»„èŒƒå›´
		return nullptr;
	TreeNode* root = new TreeNode(l_nums[i]);
	root->left = createTree(l_nums, i * 2 + 1);
	root->right = createTree(l_nums, i * 2 + 2);
	return root;
}

//å±‚æ¬¡éå†ï¼Œè¿­ä»£æ³•
void levelOrderIter(TreeNode* root) {
	queue<TreeNode*> que;
	que.push(root);
	while (!que.empty()) {
		cout << que.front()->val << " ";
		if (que.front()->left != nullptr) {
			que.push(que.front()->left);
		}
		if (que.front()->right != nullptr) {
			que.push(que.front()->right);
		}
		que.pop();
	}
	cout << endl;
}


int main()
{
	vector<int> nums = { 1,2,2,0,3,0,3 };
	TreeNode* root = createTree(nums, 0);
	levelOrderIter(root);

	Solution ss;
	cout << boolalpha << ss.isSymmetric(root) << endl;


	system("pause");
	return 0;
}
```

### 257 äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

#### æ–¹æ³•1ï¼šé€’å½’

![257.äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](assets/20210204151702443.png)

```cpp
class Solution {
public:
    // é€’å½’å‡½æ•°å‚æ•°ä»¥åŠè¿”å›å€¼,è¦ä¼ å…¥æ ¹èŠ‚ç‚¹ï¼Œè®°å½•æ¯ä¸€æ¡è·¯å¾„çš„pathï¼Œå’Œå­˜æ”¾ç»“æœé›†çš„resultï¼Œè¿™é‡Œé€’å½’ä¸éœ€è¦è¿”å›å€¼
    void helper(TreeNode* cur, vector<int>& path, vector<string>& result) {
        // å› ä¸ºæ˜¯å‰åºéå†ï¼Œéœ€è¦å…ˆå¤„ç†ä¸­é—´èŠ‚ç‚¹ï¼Œä¸­é—´èŠ‚ç‚¹å°±æ˜¯æˆ‘ä»¬è¦è®°å½•è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ï¼Œå…ˆæ”¾è¿›pathä¸­ã€‚
        path.push_back(cur->val);
        // å½“ curä¸ä¸ºç©ºï¼Œå…¶å·¦å³å­©å­éƒ½ä¸ºç©ºçš„æ—¶å€™ï¼Œå°±æ‰¾åˆ°å¶å­èŠ‚ç‚¹ã€‚æ˜¯æœ¬é¢˜çš„ç»ˆæ­¢æ¡ä»¶
        if (cur->left == nullptr && cur->right == nullptr) { // é‡åˆ°å¶å­èŠ‚ç‚¹
            string sPath;
            for (int i = 0; i < path.size()-1; ++i) { // å°†pathé‡Œè®°å½•çš„è·¯å¾„è½¬ä¸ºstringæ ¼å¼
                sPath += to_string(path[i]);
                sPath += "->";
            }
            // è®°å½•æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå¶å­èŠ‚ç‚¹ï¼‰
            // æ”¾åœ¨forå¾ªç¯å¤–é¢æ˜¯å› ä¸ºä¸éœ€è¦å†åŠ ä¸€ä¸ª"->"
            sPath += to_string(path[path.size() - 1]); 
            result.push_back(sPath); // æ”¶é›†ä¸€ä¸ªè·¯å¾„
            return;
        }

        // é€’å½’å‰è¦åŠ ä¸Šåˆ¤æ–­è¯­å¥ï¼Œåˆ¤æ–­ä¸‹é¢è¦é€’å½’çš„èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
        // é€’å½’å®Œï¼Œè¦åšå›æº¯å•Šï¼Œå› ä¸ºpath ä¸èƒ½ä¸€ç›´åŠ å…¥èŠ‚ç‚¹ï¼Œå®ƒè¿˜è¦åˆ èŠ‚ç‚¹ï¼Œç„¶åæ‰èƒ½åŠ å…¥æ–°çš„èŠ‚ç‚¹ã€‚
        if (cur->left) { // å·¦
            helper(cur->left, path, result);
            path.pop_back(); // å›æº¯
        }

        if (cur->right) { // å³
            helper(cur->right, path, result);
            path.pop_back(); // å›æº¯
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if (root == nullptr) return result;
        helper(root, path, result);
        return result;
    }
};
```

### 404 å·¦å¶å­ä¹‹å’Œ

#### æ–¹æ³•1ï¼šé€’å½’

**èŠ‚ç‚¹Açš„å·¦å­©å­ä¸ä¸ºç©ºï¼Œä¸”å·¦å­©å­çš„å·¦å³å­©å­éƒ½ä¸ºç©ºï¼ˆè¯´æ˜æ˜¯å¶å­èŠ‚ç‚¹ï¼‰ï¼Œé‚£ä¹ˆAèŠ‚ç‚¹çš„å·¦å­©å­ä¸ºå·¦å¶å­èŠ‚ç‚¹**

```cpp
class Solution {
public:
    // ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼Œåˆ¤æ–­ä¸€ä¸ªæ ‘çš„å·¦å¶å­èŠ‚ç‚¹ä¹‹å’Œï¼Œé‚£ä¹ˆä¸€å®šè¦ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’å‡½æ•°çš„è¿”å›å€¼ä¸ºæ•°å€¼ä¹‹å’Œï¼Œæ‰€ä»¥ä¸ºint
    int sumOfLeftLeaves(TreeNode* root) {
        // ç¡®å®šç»ˆæ­¢æ¡ä»¶
		// å¦‚æœéå†åˆ°ç©ºèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå·¦å¶å­å€¼ä¸€å®šæ˜¯0
        if (root == NULL) return 0;
        // åªæœ‰å½“å‰éå†çš„èŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œæ‰èƒ½åˆ¤æ–­å…¶å­èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚ æ‰€ä»¥å¦‚æœå½“å‰éå†çš„èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£å…¶å·¦å¶å­ä¹Ÿå¿…å®šæ˜¯0ï¼Œé‚£ä¹ˆç»ˆæ­¢æ¡ä»¶ä¸ºï¼š
        if (root->left == NULL && root->right== NULL) return 0;

        // ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘
		// å½“é‡åˆ°å·¦å¶å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè®°å½•æ•°å€¼ï¼Œç„¶åé€šè¿‡é€’å½’æ±‚å–å·¦å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œå’Œ å³å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œç›¸åŠ ä¾¿æ˜¯æ•´ä¸ªæ ‘çš„å·¦å¶å­ä¹‹å’Œã€‚
        int leftValue = sumOfLeftLeaves(root->left);    // å·¦
        if (root->left && !root->left->left && !root->left->right) { // å·¦å­æ ‘å°±æ˜¯ä¸€ä¸ªå·¦å¶å­çš„æƒ…å†µ
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // å³

        int sum = leftValue + rightValue;               // ä¸­
        return sum;
    }
};
```

### 513 æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

#### æ–¹æ³•1ï¼šè¿­ä»£æ³•ï¼Œå±‚åºéå†

ä½¿ç”¨å±‚åºéå†å†åˆé€‚ä¸è¿‡äº†ï¼Œåªéœ€è¦è®°å½•æœ€åä¸€è¡Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æ•°å€¼å°±å¯ä»¥äº†

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // è®°å½•æœ€åä¸€è¡Œç¬¬ä¸€ä¸ªå…ƒç´ 
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;  
    }
};
```

### 112 è·¯å¾„æ€»å’Œ

#### æ–¹æ³•1ï¼šé€’å½’

![112.è·¯å¾„æ€»å’Œ](assets/2021020316051216.png)

å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œéå†çš„è·¯çº¿ï¼Œå¹¶ä¸è¦éå†æ•´æ£µæ ‘ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°éœ€è¦è¿”å›å€¼ï¼Œå¯ä»¥ç”¨boolç±»å‹è¡¨ç¤ºã€‚



```cpp
class Solution {
private:
    // ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›ç±»å‹
 	// å‚æ•°ï¼šéœ€è¦äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿˜éœ€è¦ä¸€ä¸ªè®¡æ•°å™¨ï¼Œè¿™ä¸ªè®¡æ•°å™¨ç”¨æ¥è®¡ç®—äºŒå‰æ ‘çš„ä¸€æ¡è¾¹ä¹‹å’Œæ˜¯å¦æ­£å¥½æ˜¯ç›®æ ‡å’Œï¼Œè®¡æ•°å™¨ä¸ºintå‹ã€‚
    // æœ¬é¢˜æˆ‘ä»¬è¦æ‰¾ä¸€æ¡ç¬¦åˆæ¡ä»¶çš„è·¯å¾„ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°éœ€è¦è¿”å›å€¼ï¼ŒåŠæ—¶è¿”å›ï¼Œé‚£ä¹ˆè¿”å›ç±»å‹æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ
    bool traversal(TreeNode* cur, int count) {
        
		// ç¡®å®šç»ˆæ­¢æ¡ä»¶
        // è®¡æ•°å™¨å¦‚ä½•ç»Ÿè®¡è¿™ä¸€æ¡è·¯å¾„çš„å’Œå‘¢ï¼Ÿ
		// ä¸è¦å»ç´¯åŠ ç„¶ååˆ¤æ–­æ˜¯å¦ç­‰äºç›®æ ‡å’Œï¼Œé‚£ä¹ˆä»£ç æ¯”è¾ƒéº»çƒ¦ï¼Œå¯ä»¥ç”¨é€’å‡ï¼Œè®©è®¡æ•°å™¨countåˆå§‹ä¸ºç›®æ ‡å’Œï¼Œç„¶åæ¯æ¬¡å‡å»éå†è·¯å¾„èŠ‚ç‚¹ä¸Šçš„æ•°å€¼ã€‚
		// å¦‚æœæœ€åcount == 0ï¼ŒåŒæ—¶åˆ°äº†å¶å­èŠ‚ç‚¹çš„è¯ï¼Œè¯´æ˜æ‰¾åˆ°äº†ç›®æ ‡å’Œã€‚
		// å¦‚æœéå†åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œcountä¸ä¸º0ï¼Œå°±æ˜¯æ²¡æ‰¾åˆ°ã€‚
        if (!cur->left && !cur->right && count == 0) return true; // é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œå¹¶ä¸”è®¡æ•°ä¸º0
        if (!cur->left && !cur->right) return false; // é‡åˆ°å¶å­èŠ‚ç‚¹è€Œæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è¾¹ï¼Œç›´æ¥è¿”å›

        // ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘
   		// å› ä¸ºç»ˆæ­¢æ¡ä»¶æ˜¯åˆ¤æ–­å¶å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥é€’å½’çš„è¿‡ç¨‹ä¸­å°±ä¸è¦è®©ç©ºèŠ‚ç‚¹è¿›å…¥é€’å½’äº†ã€‚
		// é€’å½’å‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œå¦‚æœé€’å½’å‡½æ•°è¿”å›trueï¼Œè¯´æ˜æ‰¾åˆ°äº†åˆé€‚çš„è·¯å¾„ï¼Œåº”è¯¥ç«‹åˆ»è¿”å›ã€‚
        if (cur->left) { // å·¦ ï¼ˆç©ºèŠ‚ç‚¹ä¸éå†ï¼‰
            count -= cur->left->val; // é€’å½’ï¼Œå¤„ç†èŠ‚ç‚¹;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
        }
        if (cur->right) { // å³ ï¼ˆç©ºèŠ‚ç‚¹ä¸éå†ï¼‰
            count -= cur->right->val; // é€’å½’ï¼Œå¤„ç†èŠ‚ç‚¹;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```

### 1110 åˆ ç‚¹æˆæ—

#### æ–¹æ³•ä¸€ï¼šé€’å½’

![1669348588878](assets/1669348588878.png)

æ„é€ ä¸€ä¸ªhelperè¾…åŠ©å‡½æ•°ï¼šå¯¹äºä¸€ä¸ªrootç»“ç‚¹ï¼Œå¦‚æœæ˜¯å®ƒæ˜¯è¦è¢«åˆ é™¤çš„ç»“ç‚¹ï¼Œåˆ™å‘forestä¸­æ·»åŠ å…¶å·¦å³å­©å­ï¼Œå¹¶å°†å…¶ç½®ä¸ºnullåè¿”å›ï¼Œä½¿å…¶æ–­å¼€ä¸å…¶çˆ¶ç»“ç‚¹ä¹‹å‰çš„è¿æ¥

```cpp
class Solution {
public:
	vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
		vector<TreeNode*> forest;
		//å®¹å™¨å…ƒç´ éƒ½äº’ä¸ç›¸ç­‰
		unordered_set<int> dict(to_delete.begin(), to_delete.end());
		root = helper(root, dict, forest);
		if (root) {
			//æœ€åå†å°†åˆ é™¤ç»“ç‚¹åçš„æ ‘æ”¾å…¥forestä¸­
			forest.push_back(root);
		}
		return forest;
	}

	TreeNode* helper(TreeNode* root, unordered_set<int>& dict, vector<TreeNode*>& forest) {
		if (!root) {
			return root;
		}
		root->left = helper(root->left, dict, forest);
		root->right = helper(root->right, dict, forest);
		if (dict.count(root->val)) {
			//è¢«åˆ é™¤ç»“ç‚¹å¦‚æœæœ‰å·¦å³å­æ ‘å°±æ”¾å…¥forestä¸­
			if (root->left) {
				forest.push_back(root->left);
			}
			if (root->right) {
				forest.push_back(root->right);
			}
			//è¢«åˆ é™¤çš„ç»“ç‚¹ç½®ä¸ºç©º
			root = NULL;
		}
		return root;
	}
};
```

### 637 äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼

#### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå±‚æ¬¡éå†æ³•

```cpp
class Solution {
public:
	vector<double> averageOfLevels(TreeNode* root) {
		vector<double> ans;
		if (!root) {
			return ans;
		}
		queue<TreeNode*> q;
		q.push(root);
		while (!q.empty()) {
			//qçš„å¤§å°ä¸ºä¸Šä¸€æ¬¡å¾ªç¯å‹å…¥çš„æŸä¸€å±‚çš„ç»“ç‚¹æ€»ä¸ªæ•°
			int count = q.size();
			double sum = 0;
			for (int i = 0; i < count; ++i) {
				TreeNode* node = q.front();
				q.pop();
				//q.size()æ¬¡å¾ªç¯ï¼Œè·å–åˆ°æŸä¸€å±‚ç»“ç‚¹å€¼çš„æ€»å’Œ
				sum += node->val;
				if (node->left) {
					q.push(node->left);
				}
				if (node->right) {
					q.push(node->right);
				}
			}
			ans.push_back(sum / count);
		}
		return ans;
	}
};
```

### 106 ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

å˜é‡åŒºé—´éƒ½é‡‡å–å·¦é—­å³å¼€

```cpp
class Solution {
private:
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        // 1.å¦‚æœæ•°ç»„å¤§å°ä¸ºé›¶çš„è¯ï¼Œè¯´æ˜æ˜¯ç©ºèŠ‚ç‚¹äº†ã€‚
        if (postorder.size() == 0) return NULL;

        // 2.å¦‚æœä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå–ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºèŠ‚ç‚¹å…ƒç´ ã€‚
        int rootValue = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rootValue);

        // å¶å­èŠ‚ç‚¹
        if (postorder.size() == 1) return root;

        // 3.æ‰¾åˆ°ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œä½œä¸ºåˆ‡å‰²ç‚¹
        int delimiterIndex;
        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }

        // 4.åˆ‡å‰²ä¸­åºæ•°ç»„ï¼Œåˆ‡æˆä¸­åºå·¦æ•°ç»„å’Œä¸­åºå³æ•°ç»„ ï¼ˆé¡ºåºåˆ«æåäº†ï¼Œä¸€å®šæ˜¯å…ˆåˆ‡ä¸­åºæ•°ç»„ï¼‰
        // å·¦é—­å³å¼€åŒºé—´ï¼š[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

        // postorder èˆå¼ƒæœ«å°¾å…ƒç´ 
        postorder.resize(postorder.size() - 1);

        // 5.åˆ‡å‰²ååºæ•°ç»„ï¼Œåˆ‡æˆååºå·¦æ•°ç»„å’Œååºå³æ•°ç»„
        // ä¾ç„¶å·¦é—­å³å¼€ï¼Œæ³¨æ„è¿™é‡Œä½¿ç”¨äº†å·¦ä¸­åºæ•°ç»„å¤§å°ä½œä¸ºåˆ‡å‰²ç‚¹
        // [0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        // 7.ï¼šé€’å½’å¤„ç†å·¦åŒºé—´å’Œå³åŒºé—´s
        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInorder, rightPostorder);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};
```



### 654 æœ€å¤§äºŒå‰æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
private:
    // åœ¨å·¦é—­å³å¼€åŒºé—´[left, right)ï¼Œæ„é€ äºŒå‰æ ‘
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // æ‰¾åˆ†å‰²ç‚¹ï¼Œåˆ†å‰²å·¦å³å­æ ‘
        // åˆ†å‰²ç‚¹ä¸‹æ ‡ï¼šmaxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // æ„é€ å·¦å­æ ‘
        // å·¦é—­å³å¼€ï¼š[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // æ„é€ å³å­æ ‘
        // å·¦é—­å³å¼€ï¼š[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```



### 617 åˆå¹¶äºŒå‰æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

å‰åºéå†

```cpp
class Solution {
public:
    // è¦åˆå…¥ä¸¤ä¸ªäºŒå‰æ ‘ï¼Œé‚£ä¹ˆå‚æ•°è‡³å°‘æ˜¯è¦ä¼ å…¥ä¸¤ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›å€¼å°±æ˜¯åˆå¹¶ä¹‹åäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // å¦‚æœt1ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t2
        if (t2 == NULL) return t1; // å¦‚æœt2ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t1
        // ä¿®æ”¹äº†t1çš„æ•°å€¼å’Œç»“æ„
        t1->val += t2->val;                             // ä¸­
        t1->left = mergeTrees(t1->left, t2->left);      // å·¦
        t1->right = mergeTrees(t1->right, t2->right);   // å³
        return t1;
    }
}
```



### 700 äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        // å¦‚æœrootä¸ºç©ºï¼Œæˆ–è€…æ‰¾åˆ°è¿™ä¸ªæ•°å€¼äº†ï¼Œå°±è¿”å›rootèŠ‚ç‚¹ã€‚
        if (root == NULL || root->val == val) return root;
        TreeNode* result = NULL;
        // å¦‚æœroot->val > valï¼Œæœç´¢å·¦å­æ ‘ï¼Œå¦‚æœroot->val < valï¼Œå°±æœç´¢å³å­æ ‘ï¼Œæœ€åå¦‚æœéƒ½æ²¡æœ‰æœç´¢åˆ°ï¼Œå°±è¿”å›NULLã€‚
        if (root->val > val) result = searchBST(root->left, val);
        if (root->val < val) result = searchBST(root->right, val);
        return result;
    }
};
```



### 98 éªŒè¯äºŒå‰æœç´¢æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

- å°†äºŒå‰æœç´¢æ ‘è½¬å˜æˆä¸€ä¸ªæ•°ç»„ï¼Œåˆ¤æ–­æ•°ç»„æ˜¯å¦æ˜¯æœ‰åºçš„ï¼ŒäºŒå‰æœç´¢æ ‘ä¸­ä¸èƒ½æœ‰é‡å¤å…ƒç´ 

```cpp
class Solution {
public:
    vector<int> vec;
    void helper(TreeNode* root) {
        if (root == nullptr) return;
        helper(root->left);
        vec.push_back(root->val);
        helper(root->right);
    }

    bool isValidBST(TreeNode* root) {
        vec.clear();
        helper(root);
        for (int i = 1; i < vec.size(); i++) {
            if (vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
```



### 530 äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

#### æ–¹æ³•1ï¼šé€’å½’

éœ€è¦ç”¨ä¸€ä¸ªpreèŠ‚ç‚¹è®°å½•ä¸€ä¸‹curèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹

![530.äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](assets/20210204153247458.png)

```cpp
class Solution {
	private:
	int result = INT_MAX;
	TreeNode* pre = NULL;
	void traversal(TreeNode* cur) {
    	if (cur == NULL) return;
    	traversal(cur->left);   // å·¦
    	if (pre != NULL){       // ä¸­
        	result = min(result, cur->val - pre->val);
    	}
    	pre = cur; // è®°å½•å‰ä¸€ä¸ª
    	traversal(cur->right);  // å³
	}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```



### 501 äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

#### æ–¹æ³•1ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†å°±æ˜¯æœ‰åºçš„

```cpp
class Solution {
private:
    int maxCount = 0; // æœ€å¤§é¢‘ç‡
    int count = 0; // ç»Ÿè®¡é¢‘ç‡
    // å¼„ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·æ¯æ¬¡curï¼ˆå½“å‰èŠ‚ç‚¹ï¼‰æ‰èƒ½å’Œpreï¼ˆå‰ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ä½œæ¯”è¾ƒã€‚
	// è€Œä¸”åˆå§‹åŒ–çš„æ—¶å€™pre = NULLï¼Œè¿™æ ·å½“preä¸ºNULLæ—¶å€™ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æ˜¯æ¯”è¾ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚
    TreeNode* pre = NULL;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // å·¦
                                    // ä¸­
        if (pre == NULL) { // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            count = 1;
        } else if (pre->val == cur->val) { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸åŒ
            count++;
        } else { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ä¸åŒ
            count = 1;
        }
        pre = cur; // æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹

        if (count == maxCount) { // å¦‚æœå’Œæœ€å¤§å€¼ç›¸åŒï¼Œæ”¾è¿›resultä¸­
            result.push_back(cur->val);
        }

        if (count > maxCount) { // å¦‚æœè®¡æ•°å¤§äºæœ€å¤§å€¼é¢‘ç‡
            maxCount = count;   // æ›´æ–°æœ€å¤§é¢‘ç‡
            result.clear();     // å¾ˆå…³é”®çš„ä¸€æ­¥ï¼Œä¸è¦å¿˜è®°æ¸…ç©ºresultï¼Œä¹‹å‰resulté‡Œçš„å…ƒç´ éƒ½å¤±æ•ˆäº†
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // å³
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        result.clear();

        searchBST(root);
        return result;
    }
};
```



### 236 äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

#### æ–¹æ³•1ï¼šé€’å½’ï¼Œå›æº¯ï¼Œååºéå†

ååºéå†ï¼ˆå·¦ä¸­å³ï¼‰å°±æ˜¯å¤©ç„¶çš„å›æº¯è¿‡ç¨‹ï¼Œå¯ä»¥æ ¹æ®å·¦å³å­æ ‘çš„è¿”å›å€¼ï¼Œæ¥å¤„ç†ä¸­é—´èŠ‚ç‚¹çš„é€»è¾‘ã€‚å¦‚æœé€’å½’éå†é‡åˆ°qï¼Œå°±å°†qè¿”å›ï¼Œé‡åˆ°p å°±å°†pè¿”å›ï¼Œé‚£ä¹ˆå¦‚æœ å·¦å³å­æ ‘çš„è¿”å›å€¼éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶çš„ä¸­èŠ‚ç‚¹ï¼Œä¸€å®šæ˜¯q å’Œp çš„æœ€è¿‘ç¥–å…ˆã€‚

æœ¬é¢˜å‡½æ•°æœ‰è¿”å›å€¼ï¼Œæ˜¯å› ä¸ºå›æº¯çš„è¿‡ç¨‹éœ€è¦é€’å½’å‡½æ•°çš„è¿”å›å€¼åšåˆ¤æ–­ï¼Œä½†æœ¬é¢˜æˆ‘ä»¬ä¾ç„¶è¦éå†æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚

é€’å½’å‡½æ•°æœ‰è¿”å›å€¼å°±æ˜¯è¦éå†æŸä¸€æ¡è¾¹ï¼Œä½†æœ‰è¿”å›å€¼ä¹Ÿè¦çœ‹å¦‚ä½•å¤„ç†è¿”å›å€¼ï¼å¦‚æœé€’å½’å‡½æ•°æœ‰è¿”å›å€¼ï¼Œå¦‚ä½•åŒºåˆ†è¦æœç´¢ä¸€æ¡è¾¹ï¼Œè¿˜æ˜¯æœç´¢æ•´ä¸ªæ ‘å‘¢ï¼Ÿ

æœç´¢ä¸€æ¡è¾¹çš„å†™æ³•ï¼š

```cpp
// é€’å½’å‡½æ•°è¿”å›å€¼ä¸ä¸ºç©ºçš„æ—¶å€™ï¼Œç«‹åˆ»è¿”å›
if (é€’å½’å‡½æ•°(root->left)) return ;

if (é€’å½’å‡½æ•°(root->right)) return ;
```

æœç´¢æ•´ä¸ªæ ‘å†™æ³•ï¼š

```cpp
// å¦‚æœæœç´¢æ•´ä¸ªæ ‘ï¼Œç›´æ¥ç”¨ä¸€ä¸ªå˜é‡leftã€rightæ¥ä½è¿”å›å€¼ï¼Œè¿™ä¸ªleftã€rightååºè¿˜æœ‰é€»è¾‘å¤„ç†çš„éœ€è¦ï¼Œä¹Ÿå°±æ˜¯ååºéå†ä¸­å¤„ç†ä¸­é—´èŠ‚ç‚¹çš„é€»è¾‘ï¼ˆä¹Ÿæ˜¯å›æº¯ï¼‰
left = é€’å½’å‡½æ•°(root->left);  // å·¦
right = é€’å½’å‡½æ•°(root->right); // å³
leftä¸rightçš„é€»è¾‘å¤„ç†;         // ä¸­ 
```

çœ‹å‡ºåŒºåˆ«äº†æ²¡ï¼Ÿ

**åœ¨é€’å½’å‡½æ•°æœ‰è¿”å›å€¼çš„æƒ…å†µä¸‹ï¼šå¦‚æœè¦æœç´¢ä¸€æ¡è¾¹ï¼Œé€’å½’å‡½æ•°è¿”å›å€¼ä¸ä¸ºç©ºçš„æ—¶å€™ï¼Œç«‹åˆ»è¿”å›ï¼Œå¦‚æœæœç´¢æ•´ä¸ªæ ‘ï¼Œç›´æ¥ç”¨ä¸€ä¸ªå˜é‡leftã€rightæ¥ä½è¿”å›å€¼ï¼Œè¿™ä¸ªleftã€rightååºè¿˜æœ‰é€»è¾‘å¤„ç†çš„éœ€è¦ï¼Œä¹Ÿå°±æ˜¯ååºéå†ä¸­å¤„ç†ä¸­é—´èŠ‚ç‚¹çš„é€»è¾‘ï¼ˆä¹Ÿæ˜¯å›æº¯ï¼‰**ã€‚

![236.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](assets/2021020415105872.png)

ä¸æ˜¯ç›´æ¥è¿”å›7ã€‚

äº‹å®ä¸Šè¿˜è¦éå†æ ¹èŠ‚ç‚¹å³å­æ ‘ï¼ˆå³ä½¿æ­¤æ—¶å·²ç»æ‰¾åˆ°äº†ç›®æ ‡èŠ‚ç‚¹äº†ï¼‰ï¼Œä¹Ÿå°±æ˜¯å›¾ä¸­çš„èŠ‚ç‚¹4ã€15ã€20ã€‚å› ä¸ºåœ¨å¦‚ä¸‹ä»£ç çš„ååºéå†ä¸­ï¼Œå¦‚æœæƒ³åˆ©ç”¨leftå’Œrightåšé€»è¾‘å¤„ç†ï¼Œ ä¸èƒ½ç«‹åˆ»è¿”å›ï¼Œè€Œæ˜¯è¦ç­‰leftä¸righté€»è¾‘å¤„ç†å®Œä¹‹åæ‰èƒ½è¿”å›ã€‚

```cpp
left = é€’å½’å‡½æ•°(root->left);  // å·¦
right = é€’å½’å‡½æ•°(root->right); // å³
leftä¸rightçš„é€»è¾‘å¤„ç†;         // ä¸­ 
```

ä¸ºä»€ä¹ˆleftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºï¼Œç›®æ ‡èŠ‚ç‚¹é€šè¿‡rightè¿”å›å‘¢ï¼Ÿ

![236.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ1](assets/20210204151125844.png)

å›¾ä¸­èŠ‚ç‚¹10çš„å·¦å­æ ‘è¿”å›nullï¼Œå³å­æ ‘è¿”å›ç›®æ ‡å€¼7ï¼Œé‚£ä¹ˆæ­¤æ—¶èŠ‚ç‚¹10çš„å¤„ç†é€»è¾‘å°±æ˜¯æŠŠå³å­æ ‘çš„è¿”å›å€¼ï¼ˆæœ€è¿‘å…¬å…±ç¥–å…ˆ7ï¼‰è¿”å›ä¸Šå»ï¼

![236.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ2](assets/202102041512582.png)



```cpp
class Solution {
public:
    // ç¡®å®šçš„è¿”å›å€¼æ˜¯æœ€è¿‘å…¬å…±èŠ‚ç‚¹ï¼Œå¯ä»¥åˆ©ç”¨ä¸Šé¢˜ç›®ä¸­è¿”å›å€¼æ˜¯TreeNode * 
    // å¦‚æœé‡åˆ°pæˆ–è€…qï¼Œå°±æŠŠqæˆ–è€…pè¿”å›ï¼Œè¿”å›å€¼ä¸ä¸ºç©ºï¼Œå°±è¯´æ˜æ‰¾åˆ°äº†qæˆ–è€…p
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // å¦‚æœ root == pï¼Œæˆ–è€… root == 1ï¼Œè¯´æ˜æ‰¾åˆ° p q ï¼Œåˆ™å°†å…¶è¿”å›
        if (root == p || root == q || root == nullptr) return root;
        
        // æœ¬é¢˜å‡½æ•°æœ‰è¿”å›å€¼ï¼Œæ˜¯å› ä¸ºå›æº¯çš„è¿‡ç¨‹éœ€è¦é€’å½’å‡½æ•°çš„è¿”å›å€¼åšåˆ¤æ–­ï¼Œä½†æœ¬é¢˜æˆ‘ä»¬ä¾ç„¶è¦éå†æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹
        // å…ˆç”¨leftå’Œrightæ¥ä½å·¦å­æ ‘å’Œå³å­æ ‘çš„è¿”å›å€¼
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        // å¦‚æœé€’å½’éå†é‡åˆ°qï¼Œå°±å°†qè¿”å›ï¼Œé‡åˆ°p å°±å°†pè¿”å›ï¼Œé‚£ä¹ˆå¦‚æœ å·¦å³å­æ ‘çš„è¿”å›å€¼éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶çš„ä¸­èŠ‚ç‚¹ï¼Œä¸€å®šæ˜¯q å’Œp çš„æœ€è¿‘ç¥–å…ˆã€‚
        // å¦‚æœleft å’Œ rightéƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶rootå°±æ˜¯æœ€è¿‘å…¬å…±èŠ‚ç‚¹ã€‚è¿™ä¸ªæ¯”è¾ƒå¥½ç†è§£
		// å¦‚æœleftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºï¼Œå°±è¿”å›rightï¼Œè¯´æ˜ç›®æ ‡èŠ‚ç‚¹æ˜¯é€šè¿‡rightè¿”å›çš„ï¼Œåä¹‹ä¾ç„¶ã€‚
        if (left != nullptr && right != nullptr) {
            // å¦‚æœ å·¦å³å­æ ‘çš„è¿”å›å€¼éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶çš„ä¸­èŠ‚ç‚¹ï¼Œä¸€å®šæ˜¯q å’Œp çš„æœ€è¿‘ç¥–å…ˆã€‚
            return root;
        }
        else if (left == nullptr && right != nullptr) {
            // leftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºï¼Œç›®æ ‡èŠ‚ç‚¹é€šè¿‡rightè¿”å›
            return right;
        }
        else if (left != nullptr && right == nullptr) {
            // leftä¸ä¸ºç©ºï¼Œrightä¸ºç©ºï¼Œç›®æ ‡èŠ‚ç‚¹é€šè¿‡left è¿”å›
            return left;
        }
        else {
            // å¦‚æœleftå’Œrightéƒ½ä¸ºç©ºï¼Œåˆ™è¿”å›leftæˆ–è€…rightéƒ½æ˜¯å¯ä»¥çš„ï¼Œä¹Ÿå°±æ˜¯è¿”å›ç©º
            return nullptr;
        }
    }
};
```



#### ç¬¬2æ¬¡

![1690885803681](assets/1690885803681.png)

![1690885835596](assets/1690885835596.png)

![1690885865132](assets/1690885865132.png)



```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            //åªè¦å½“å‰æ ¹èŠ‚ç‚¹æ˜¯på’Œqä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œå°±è¿”å›ï¼ˆå› ä¸ºä¸èƒ½æ¯”è¿™ä¸ªæ›´æ·±äº†ï¼Œå†æ·±på’Œqä¸­çš„ä¸€ä¸ªå°±æ²¡äº†ï¼‰
            return root;
        }
        //æ ¹èŠ‚ç‚¹ä¸æ˜¯på’Œqä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œé‚£ä¹ˆå°±ç»§ç»­åˆ†åˆ«å¾€å·¦å­æ ‘å’Œå³å­æ ‘æ‰¾på’Œq
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        //på’Œqéƒ½æ²¡æ‰¾åˆ°ï¼Œé‚£å°±æ²¡æœ‰
        if(left == null && right == null) {
            return null;
        }
        //å·¦å­æ ‘æ²¡æœ‰pä¹Ÿæ²¡æœ‰qï¼Œå°±è¿”å›å³å­æ ‘çš„ç»“æœ
        if (left == null) {
            return right;
        }
        //å³å­æ ‘æ²¡æœ‰pä¹Ÿæ²¡æœ‰qå°±è¿”å›å·¦å­æ ‘çš„ç»“æœ
        if (right == null) {
            return left;
        }
        //å·¦å³å­æ ‘éƒ½æ‰¾åˆ°på’Œqäº†ï¼Œé‚£å°±è¯´æ˜på’Œqåˆ†åˆ«åœ¨å·¦å³ä¸¤ä¸ªå­æ ‘ä¸Šï¼Œæ‰€ä»¥æ­¤æ—¶çš„æœ€è¿‘å…¬å…±ç¥–å…ˆå°±æ˜¯root
        return root;
    }
}

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==p || root==q || root==nullptr){
            return root;
        }

        TreeNode* left=lowestCommonAncestor(root->left, p, q);
        TreeNode* right=lowestCommonAncestor(root->right, p, q);

        if(left==nullptr && right==nullptr){
            return nullptr;
        }

        if(left==nullptr){
            return right;
        }

        if(right==nullptr){
            return left;
        }

        return root;


    }
};
```





### 701 äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    // æœ‰è¿”å›å€¼çš„è¯ï¼Œå¯ä»¥åˆ©ç”¨è¿”å›å€¼å®Œæˆæ–°åŠ å…¥çš„èŠ‚ç‚¹ä¸å…¶çˆ¶èŠ‚ç‚¹çš„èµ‹å€¼æ“ä½œ
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // ç»ˆæ­¢æ¡ä»¶ï¼šå°±æ˜¯æ‰¾åˆ°éå†çš„èŠ‚ç‚¹ä¸ºnullçš„æ—¶å€™ï¼Œå°±æ˜¯è¦æ’å…¥èŠ‚ç‚¹çš„ä½ç½®äº†ï¼Œå¹¶æŠŠæ’å…¥çš„èŠ‚ç‚¹è¿”å›
        if (root == nullptr) {
            TreeNode* node = new TreeNode(val);
            // æŠŠè¦æ·»åŠ çš„èŠ‚ç‚¹è¿”å›ç»™ä¸Šä¸€å±‚ï¼Œå®Œæˆçˆ¶å­èŠ‚ç‚¹çš„èµ‹å€¼æ“ä½œ
            return node;
        }
	
        // é€šè¿‡é€’å½’å‡½æ•°è¿”å›å€¼å®Œæˆæ–°åŠ å…¥èŠ‚ç‚¹çš„çˆ¶å­å…³ç³»èµ‹å€¼æ“ä½œäº†
        // ä¹Ÿå°±æ˜¯ä¸‹ä¸€å±‚å°†åŠ å…¥èŠ‚ç‚¹è¿”å›ï¼Œæœ¬å±‚ç”¨root->leftæˆ–è€…root->rightå°†å…¶æ¥ä½ã€‚
        if (root->val > val) {
            root->left = insertIntoBST(root->left, val);
        }
        if (root->val < val) {
            root->right = insertIntoBST(root->right, val);
        }
        return root;
    }
};
```



### 108 å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    // å·¦é—­å³é—­åŒºé—´[left, right]ï¼Œå¾ªç¯ä¸å˜é‡ï¼Œæ¥ä¸‹æ¥ä¸€ç›´åšæŒå·¦é—­å³é—­çš„åŒºé—´
    TreeNode* helper(vector<int>& nums,int left, int right) {
        // è¿™é‡Œå®šä¹‰çš„æ˜¯å·¦é—­å³é—­çš„åŒºé—´ï¼Œæ‰€ä»¥å½“åŒºé—´ left > rightçš„æ—¶å€™ï¼Œå°±æ˜¯ç©ºèŠ‚ç‚¹äº†
        if (left > right) return nullptr;
        // è¿™æ ·å¯ä»¥é˜²æ­¢leftå’Œrightéƒ½æ˜¯æœ€å¤§intæ—¶ï¼Œå¯¼è‡´çš„è¶Šç•Œ
        int mid = left + (right - left) / 2;

        // å–äº†ä¸­é—´ä½ç½®ï¼Œå°±å¼€å§‹ä»¥ä¸­é—´ä½ç½®çš„å…ƒç´ æ„é€ èŠ‚ç‚¹
        TreeNode* root = new TreeNode(nums[mid
                                           
        // åˆ’åˆ†åŒºé—´ï¼Œrootçš„å·¦å­©å­æ¥ä½ä¸‹ä¸€å±‚å·¦åŒºé—´çš„æ„é€ èŠ‚ç‚¹ï¼Œå³å­©å­æ¥ä½ä¸‹ä¸€å±‚å³åŒºé—´æ„é€ çš„èŠ‚ç‚¹ 
        root->left = helper(nums, left, mid - 1);
        root->right = helper(nums, mid + 1, right-1);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        // ä¼ å…¥çš„leftå’Œrightæ˜¯0å’Œnums.size()-1ï¼Œå› ä¸ºå®šä¹‰çš„åŒºé—´ä¸ºå·¦é—­å³é—­
        TreeNode* root = helper(nums, 0, nums.size()-1);
        return root;
    }
};

```



### 450 åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

#### æ–¹æ³•1ï¼šé€’å½’

```cpp
class Solution {
public:
    // å¯ä»¥é€šè¿‡é€’å½’è¿”å›å€¼æ¥åŠ å…¥æ–°èŠ‚ç‚¹ï¼Œä¹Ÿå¯ä»¥é€šè¿‡é€’å½’è¿”å›å€¼åˆ é™¤èŠ‚ç‚¹
    TreeNode* deleteNode(TreeNode* root, int key) {
        // ç¬¬ä¸€ç§æƒ…å†µï¼šæ²¡æ‰¾åˆ°åˆ é™¤çš„èŠ‚ç‚¹ï¼Œéå†åˆ°ç©ºèŠ‚ç‚¹ç›´æ¥è¿”å›
        if (root == nullptr) return root;
        if (root->val == key) {
            
            // ç¬¬äºŒç§æƒ…å†µï¼šå·¦å³å­©å­éƒ½ä¸ºç©ºï¼ˆå¶å­èŠ‚ç‚¹ï¼‰ï¼Œç›´æ¥åˆ é™¤èŠ‚ç‚¹ï¼Œ è¿”å›NULLä¸ºæ ¹èŠ‚ç‚¹
            if (root->left == nullptr && root->right == nullptr) {
                ///! å†…å­˜é‡Šæ”¾
                delete root;
                return nullptr;
            }
            
            // ç¬¬ä¸‰ç§æƒ…å†µï¼šå…¶å·¦å­©å­ä¸ºç©ºï¼Œå³å­©å­ä¸ä¸ºç©ºï¼Œåˆ é™¤èŠ‚ç‚¹ï¼Œå³å­©å­è¡¥ä½ ï¼Œè¿”å›å³å­©å­ä¸ºæ ¹èŠ‚ç‚¹
            else if (root->left == nullptr) {
                auto retNode = root->right;
                delete root;
                return retNode;
            }
            
            // ç¬¬å››ç§æƒ…å†µï¼šå…¶å³å­©å­ä¸ºç©ºï¼Œå·¦å­©å­ä¸ä¸ºç©ºï¼Œåˆ é™¤èŠ‚ç‚¹ï¼Œå·¦å­©å­è¡¥ä½ï¼Œè¿”å›å·¦å­©å­ä¸ºæ ¹èŠ‚ç‚¹
            else if (root->right == nullptr) {
                auto retNode = root->left;
                delete root;
                return retNode;
            }
            // ç¬¬äº”ç§æƒ…å†µï¼šå·¦å³å­©å­èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œåˆ™å°†åˆ é™¤èŠ‚ç‚¹çš„å·¦å­æ ‘æ”¾åˆ°åˆ é™¤èŠ‚ç‚¹çš„å³å­æ ‘çš„æœ€å·¦é¢èŠ‚ç‚¹çš„å·¦å­©å­çš„ä½ç½®
            // å¹¶è¿”å›åˆ é™¤èŠ‚ç‚¹å³å­©å­ä¸ºæ–°çš„æ ¹èŠ‚ç‚¹
            else {
                TreeNode* cur = root->right; // æ‰¾å³å­æ ‘æœ€å·¦é¢çš„èŠ‚ç‚¹
                while (cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // æŠŠè¦åˆ é™¤çš„èŠ‚ç‚¹ï¼ˆrootï¼‰å·¦å­æ ‘æ”¾åœ¨curçš„å·¦å­©å­çš„ä½ç½®
                TreeNode* tmp = root; // æŠŠrootèŠ‚ç‚¹ä¿å­˜ä¸€ä¸‹ï¼Œä¸‹é¢æ¥åˆ é™¤
                root = root->right;  // è¿”å›æ—§rootçš„å³å­©å­ä½œä¸ºæ–°root
                delete tmp;  // é‡Šæ”¾èŠ‚ç‚¹å†…å­˜ï¼ˆè¿™é‡Œä¸å†™ä¹Ÿå¯ä»¥ï¼Œä½†C++æœ€å¥½æ‰‹åŠ¨é‡Šæ”¾ä¸€ä¸‹å§ï¼‰
                return root;
            }
        }

        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);

        return root;
    }
};
```



### 669 ä¿®å‰ªäºŒå‰æœç´¢æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

![669.ä¿®å‰ªäºŒå‰æœç´¢æ ‘1](assets/20210204155327203.png)



```cpp
// å¦‚ä¸‹ä»£ç ç›¸å½“äºæŠŠèŠ‚ç‚¹0çš„å³å­©å­ï¼ˆèŠ‚ç‚¹2ï¼‰è¿”å›ç»™ä¸Šä¸€å±‚ï¼Œ
if (root->val < low) {
    TreeNode* right = trimBST(root->right, low, high); // å¯»æ‰¾ç¬¦åˆåŒºé—´[low, high]çš„èŠ‚ç‚¹
    return right;
}


// ç„¶åå¦‚ä¸‹ä»£ç ç›¸å½“äºç”¨èŠ‚ç‚¹3çš„å·¦å­©å­ æŠŠä¸‹ä¸€å±‚è¿”å›çš„ èŠ‚ç‚¹0çš„å³å­©å­ï¼ˆèŠ‚ç‚¹2ï¼‰ æ¥ä½ã€‚
root->left = trimBST(root->left, low, high);

```

é¢˜è§£ï¼š

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        // ä¿®å‰ªçš„æ“ä½œå¹¶ä¸æ˜¯åœ¨ç»ˆæ­¢æ¡ä»¶ä¸Šè¿›è¡Œçš„ï¼Œæ‰€æœ‰é‡åˆ°ç©ºèŠ‚ç‚¹è¿”å›å°±å¯ä»¥äº†
        if (root == nullptr) return nullptr;
        
        // å¦‚æœrootï¼ˆå½“å‰èŠ‚ç‚¹ï¼‰çš„å…ƒç´ å°äºlowçš„æ•°å€¼ï¼Œé‚£ä¹ˆåº”è¯¥é€’å½’å³å­æ ‘ï¼Œå¹¶è¿”å›å³å­æ ‘ç¬¦åˆæ¡ä»¶çš„å¤´ç»“ç‚¹ã€‚
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high);
            return right;
        }
       
        // å¦‚æœroot(å½“å‰èŠ‚ç‚¹)çš„å…ƒç´ å¤§äºhighçš„ï¼Œé‚£ä¹ˆåº”è¯¥é€’å½’å·¦å­æ ‘ï¼Œå¹¶è¿”å›å·¦å­æ ‘ç¬¦åˆæ¡ä»¶çš„å¤´ç»“ç‚¹ã€‚
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high);
            return left;
        }

        // è¦å°†ä¸‹ä¸€å±‚å¤„ç†å®Œå·¦å­æ ‘çš„ç»“æœèµ‹ç»™root->leftï¼Œå¤„ç†å®Œå³å­æ ‘çš„ç»“æœèµ‹ç»™root->right
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```



### 538 æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢æˆç´¯åŠ æ ‘

#### æ–¹æ³•1ï¼šé€’å½’

**ä»æ ‘ä¸­å¯ä»¥çœ‹å‡ºç´¯åŠ çš„é¡ºåºæ˜¯å³ä¸­å·¦ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åä¸­åºéå†è¿™ä¸ªäºŒå‰æ ‘ï¼Œç„¶åé¡ºåºç´¯åŠ å°±å¯ä»¥äº†**

![1693623193264](assets/1693623193264.png)

```cpp
class Solution {
public:
    // å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡preï¼Œç”¨æ¥ä¿å­˜curèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ•°å€¼
    int pre = 0;
    // ä¸éœ€è¦é€’å½’å‡½æ•°çš„è¿”å›å€¼åšä»€ä¹ˆæ“ä½œï¼Œè¦éå†æ•´æ£µæ ‘
    void helper(TreeNode* cur) {
        // é‡ç©ºå°±ç»ˆæ­¢
        if (cur == nullptr) return;
        helper(cur->right); // å³ä¸­å·¦éå†
        cur->val += pre;
        pre = cur->val;
        helper(cur->left);
    }

    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        helper(root);
        return root;
    }
};
```



### 114 å°†äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

#### æ–¹æ³•1ï¼šå‰åºéå†

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        vector<TreeNode*> help;
        preorderTraversal(root, help);
        // å±•å¼€ä¸ºå•é“¾è¡¨åï¼Œå•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹é¡ºåºå³ä¸ºäºŒå‰æ ‘çš„å‰åºéå†è®¿é—®å„èŠ‚ç‚¹çš„é¡ºåº
        for (int i = 1; i < help.size(); i++) {
            TreeNode* pre = help[i - 1], *cur = help[i];
            pre->left = nullptr;
            pre->right = cur;
        }
    }

    // å‰åºéå†
    void preorderTraversal(TreeNode* root, vector<TreeNode*>& help) {
        if (root != nullptr) {
            help.push_back(root);
            preorderTraversal(root->left, help);
            preorderTraversal(root->right, help);
        }
    }
};
```



### é¢è¯•é¢˜04.02. æœ€å°é«˜åº¦æ ‘

#### æ–¹æ³•1ï¼šæ•°ç»„åˆ‡å‰²+é€’å½’

```cpp
class Solution {
public:
    /* åœ¨å·¦é—­å³å¼€åŒºé—´[left, right)ï¼Œæ„é€ äºŒå‰æ ‘ */
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        /* é€’å½’æˆªæ­¢æ¡ä»¶ */
        if (left >= right) return nullptr;
        /* æ±‚å–åˆ†å‰²ç‚¹ä¸‹æ ‡ï¼šmidValueIndex */
        int midValueIndex = left + (right-left)/2;// èµ‹å€¼å¾ˆå·§å¦™å¯ä»¥æ›´æ–° æ–°æ•°ç»„çš„èµ·ç‚¹
        /* æ›´æ–°èŠ‚ç‚¹å€¼ */
        TreeNode* root = new TreeNode(nums[midValueIndex]);
        /* å·¦é—­å³å¼€ï¼š[left, midValueIndex) */
        root->left = traversal(nums, left, midValueIndex);
        /* å·¦é—­å³å¼€ï¼š[midValueIndex + 1, right)*/
        root->right = traversal(nums, midValueIndex + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.size() == 0) return nullptr;
        return traversal(nums, 0, nums.size());
    }
};

```





### 662. äºŒå‰æ ‘æœ€å¤§å®½åº¦

#### æ–¹æ³•1ï¼šä¸¤ä¸ªé˜Ÿåˆ—

è¦è®¡ç®—äºŒå‰æ ‘çš„æœ€å¤§å®½åº¦ï¼Œå¯ä»¥ä½¿ç”¨å±‚åºéå†çš„æ–¹æ³•ï¼Œå¹¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹åœ¨å½“å‰å±‚çš„ä½ç½®ã€‚å…·ä½“æ€è·¯å¦‚ä¸‹ï¼š

1. åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ— `queue` ç”¨äºå±‚åºéå†äºŒå‰æ ‘ã€‚
2. åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ— `indexQueue` ç”¨äºè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„ä½ç½®ã€‚åˆå§‹æ—¶ï¼Œå°†æ ¹èŠ‚ç‚¹çš„ä½ç½® 0 å…¥é˜Ÿã€‚
3. åˆå§‹åŒ–å˜é‡ `maxWidth` ä¸º 0ï¼Œç”¨äºè®°å½•æœ€å¤§å®½åº¦ã€‚
4. è¿›è¡Œå±‚åºéå†çš„å¾ªç¯ï¼Œç›´åˆ°é˜Ÿåˆ— `queue` ä¸ºç©ºï¼š
   - è·å–å½“å‰å±‚çš„èŠ‚ç‚¹ä¸ªæ•° `size`ã€‚
   - åˆå§‹åŒ–å˜é‡ `left` å’Œ `right`ï¼Œåˆ†åˆ«ç”¨äºè®°å½•å½“å‰å±‚çš„æœ€å·¦å’Œæœ€å³èŠ‚ç‚¹çš„ä½ç½®ã€‚
   - è¿›è¡Œ `size` æ¬¡å¾ªç¯ï¼Œä¾æ¬¡å–å‡ºé˜Ÿåˆ— `queue` çš„èŠ‚ç‚¹å’Œ `indexQueue` çš„ä½ç½®ï¼š
     - å¦‚æœæ˜¯å½“å‰å±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å…¶ä½ç½®èµ‹å€¼ç»™ `left`ã€‚
     - å¦‚æœæ˜¯å½“å‰å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å…¶ä½ç½®èµ‹å€¼ç»™ `right`ã€‚
     - å°†å½“å‰èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹çš„ä½ç½®ï¼ˆç›¸å¯¹äºå½“å‰èŠ‚ç‚¹çš„ä½ç½®ï¼‰å…¥é˜Ÿ `indexQueue`ã€‚
   - è®¡ç®—å½“å‰å±‚çš„å®½åº¦ `width`ï¼Œå³ `right - left + 1`ã€‚
   - æ›´æ–° `maxWidth` ä¸º `max(maxWidth, width)`ã€‚
5. è¿”å›æœ€å¤§å®½åº¦ `maxWidth`ã€‚

ä»¥ä¸‹æ˜¯ä½¿ç”¨ C++ ç¼–å†™çš„ä»£ç ï¼Œå…¶ä¸­åŒ…å«è¯¦ç»†çš„æ³¨é‡Šï¼š

æœ‰ç‚¹æ²¡äº‹æ‰¾äº‹ï¼Œå¿…é¡»è¦ç”¨unsigned long longæ‰è¡Œ

```cpp
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        
        ::queue<TreeNode*> queue;
        queue.push(root);
        
        ::queue<unsigned long long> indexQueue;
        indexQueue.push(0);
        
        int maxWidth = 0;
        
        while (!queue.empty()) {
            int size = queue.size();
            unsigned long long left = 0;
            unsigned long long right = 0;
            
            for (int i = 0; i < size; i++) {
                TreeNode* node = queue.front();
                queue.pop();
                
                unsigned long long index = indexQueue.front();
                indexQueue.pop();
                
                if (i == 0) {
                    left = index;
                }
                
                if (i == size - 1) {
                    right = index;
                }
                
                if (node->left != nullptr) {
                    queue.push(node->left);
                    indexQueue.push(2 * index);
                }
                
                if (node->right != nullptr) {
                    queue.push(node->right);
                    indexQueue.push(2 * index + 1);
                }
            }
            
            int width = right - left + 1;
            maxWidth = max(maxWidth, width);
        }
        
        return maxWidth;
    }
};
```



### 199. äºŒå‰æ ‘çš„å³è§†å›¾

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) {
            return result;  // ç©ºæ ‘ï¼Œç›´æ¥è¿”å›ç©ºç»“æœ
        }
        
        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front();
                q.pop();
                
                if (i == size - 1) {
                    result.push_back(node->val);  // å°†æ¯å±‚çš„æœ€å³èŠ‚ç‚¹å€¼åŠ å…¥ç»“æœ
                }
                
                if (node->left) {
                    q.push(node->left);
                }
                
                if (node->right) {
                    q.push(node->right);
                }
            }
        }
        
        return result;
    }
};
```





### 958. äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ

æ—¶é—´å¤æ‚åº¦ä¸€èˆ¬

```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue<TreeNode*>q;
        q.push(root);
        bool flag=false;
        while(!q.empty()){
            auto node =q.front();
            q.pop();
            if(node==nullptr){
                flag=true;
                continue;
            }
            if(flag) return false;
            q.push(node->left);
            q.push(node->right);
            
        }
        return true;
    }
};
```



### 208. å®ç° Trie (å‰ç¼€æ ‘)

å†™å¾—éå¸¸å¥½

[Trie Tree çš„å®ç° (é€‚åˆåˆå­¦è€…)ğŸŒ³ - å®ç° Trie (å‰ç¼€æ ‘) - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/)

ä»‹ç» TrieğŸŒ³
Trie æ˜¯ä¸€é¢—éå…¸å‹çš„å¤šå‰æ ‘æ¨¡å‹ï¼Œå¤šå‰å¥½ç†è§£ï¼Œå³æ¯ä¸ªç»“ç‚¹çš„åˆ†æ”¯æ•°é‡å¯èƒ½ä¸ºå¤šä¸ªã€‚

ä¸ºä»€ä¹ˆè¯´éå…¸å‹å‘¢ï¼Ÿå› ä¸ºå®ƒå’Œä¸€èˆ¬çš„å¤šå‰æ ‘ä¸ä¸€æ ·ï¼Œå°¤å…¶åœ¨ç»“ç‚¹çš„æ•°æ®ç»“æ„è®¾è®¡ä¸Šï¼Œæ¯”å¦‚ä¸€èˆ¬çš„å¤šå‰æ ‘çš„ç»“ç‚¹æ˜¯è¿™æ ·çš„ï¼š

```cpp
struct TreeNode {
    VALUETYPE value;    //ç»“ç‚¹å€¼
    TreeNode* children[NUM];    //æŒ‡å‘å­©å­ç»“ç‚¹
};
```


è€Œ Trie çš„ç»“ç‚¹æ˜¯è¿™æ ·çš„(å‡è®¾åªåŒ…å«'a'~'z'ä¸­çš„å­—ç¬¦)ï¼š

```cpp
struct TrieNode {
    bool isEnd; //è¯¥ç»“ç‚¹æ˜¯å¦æ˜¯ä¸€ä¸ªä¸²çš„ç»“æŸ
    TrieNode* next[26]; //å­—æ¯æ˜ å°„è¡¨
};
```


è¦æƒ³å­¦ä¼š Trie å°±å¾—å…ˆæ˜ç™½å®ƒçš„ç»“ç‚¹è®¾è®¡ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°TrieNodeç»“ç‚¹ä¸­å¹¶æ²¡æœ‰ç›´æ¥ä¿å­˜å­—ç¬¦å€¼çš„æ•°æ®æˆå‘˜ï¼Œé‚£å®ƒæ˜¯æ€ä¹ˆä¿å­˜å­—ç¬¦çš„å‘¢ï¼Ÿ

è¿™æ—¶å­—æ¯æ˜ å°„è¡¨next çš„å¦™ç”¨å°±ä½“ç°äº†ï¼ŒTrieNode* next[26]ä¸­ä¿å­˜äº†å¯¹å½“å‰ç»“ç‚¹è€Œè¨€ä¸‹ä¸€ä¸ªå¯èƒ½å‡ºç°çš„æ‰€æœ‰å­—ç¬¦çš„é“¾æ¥ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªçˆ¶ç»“ç‚¹æ¥é¢„çŸ¥å®ƒæ‰€æœ‰å­ç»“ç‚¹çš„å€¼ï¼š

```cpp
for (int i = 0; i < 26; i++) {
    char ch = 'a' + i;
    if (parentNode->next[i] == NULL) {
        è¯´æ˜çˆ¶ç»“ç‚¹çš„åä¸€ä¸ªå­—æ¯ä¸å¯ä¸º ch
    } else {
        è¯´æ˜çˆ¶ç»“ç‚¹çš„åä¸€ä¸ªå­—æ¯å¯ä»¥æ˜¯ ch
    }
}
```


æˆ‘ä»¬æ¥çœ‹ä¸ªä¾‹å­å§ã€‚

æƒ³è±¡ä»¥ä¸‹ï¼ŒåŒ…å«ä¸‰ä¸ªå•è¯ "sea","sells","she" çš„ Trie ä¼šé•¿å•¥æ ·å‘¢ï¼Ÿ

å®ƒçš„çœŸå®æƒ…å†µæ˜¯è¿™æ ·çš„ï¼š

Trie ä¸­ä¸€èˆ¬éƒ½å«æœ‰å¤§é‡çš„ç©ºé“¾æ¥ï¼Œå› æ­¤åœ¨ç»˜åˆ¶ä¸€æ£µå•è¯æŸ¥æ‰¾æ ‘æ—¶ä¸€èˆ¬ä¼šå¿½ç•¥ç©ºé“¾æ¥ï¼ŒåŒæ—¶ä¸ºäº†æ–¹ä¾¿ç†è§£æˆ‘ä»¬å¯ä»¥ç”»æˆè¿™æ ·ï¼š



æ¥ä¸‹æ¥æˆ‘ä»¬ä¸€èµ·æ¥å®ç°å¯¹ Trie çš„ä¸€äº›å¸¸ç”¨æ“ä½œæ–¹æ³•ã€‚

å®šä¹‰ç±» Trie

```cpp
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    //æ–¹æ³•å°†åœ¨ä¸‹æ–‡å®ç°...
};
```

**æ’å…¥**

æè¿°ï¼šå‘ Trie ä¸­æ’å…¥ä¸€ä¸ªå•è¯ word

å®ç°ï¼šè¿™ä¸ªæ“ä½œå’Œæ„å»ºé“¾è¡¨å¾ˆåƒã€‚é¦–å…ˆä»æ ¹ç»“ç‚¹çš„å­ç»“ç‚¹å¼€å§‹ä¸ word ç¬¬ä¸€ä¸ªå­—ç¬¦è¿›è¡ŒåŒ¹é…ï¼Œä¸€ç›´åŒ¹é…åˆ°å‰ç¼€é“¾ä¸Šæ²¡æœ‰å¯¹åº”çš„å­—ç¬¦ï¼Œè¿™æ—¶å¼€å§‹ä¸æ–­å¼€è¾Ÿæ–°çš„ç»“ç‚¹ï¼Œç›´åˆ°æ’å…¥å®Œ word çš„æœ€åä¸€ä¸ªå­—ç¬¦ï¼ŒåŒæ—¶è¿˜è¦å°†æœ€åä¸€ä¸ªç»“ç‚¹isEnd = true;ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªå•è¯çš„æœ«å°¾ã€‚

```cpp
void insert(string word) {
    Trie* node = this;
    for (char c : word) {
        if (node->next[c-'a'] == NULL) {
            node->next[c-'a'] = new Trie();
        }
        node = node->next[c-'a'];
    }
    node->isEnd = true;
}
```

æŸ¥æ‰¾
æè¿°ï¼šæŸ¥æ‰¾ Trie ä¸­æ˜¯å¦å­˜åœ¨å•è¯ word

å®ç°ï¼šä»æ ¹ç»“ç‚¹çš„å­ç»“ç‚¹å¼€å§‹ï¼Œä¸€ç›´å‘ä¸‹åŒ¹é…å³å¯ï¼Œå¦‚æœå‡ºç°ç»“ç‚¹å€¼ä¸ºç©ºå°±è¿”å› falseï¼Œå¦‚æœåŒ¹é…åˆ°äº†æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œé‚£æˆ‘ä»¬åªéœ€åˆ¤æ–­ node->isEndå³å¯ã€‚

```cpp
bool search(string word) {
    Trie* node = this;
    for (char c : word) {
        node = node->next[c - 'a'];
        if (node == NULL) {
            return false;
        }
    }
    return node->isEnd;
}
```


å‰ç¼€åŒ¹é…
æè¿°ï¼šåˆ¤æ–­ Trie ä¸­æ˜¯æˆ–æœ‰ä»¥ prefix ä¸ºå‰ç¼€çš„å•è¯

å®ç°ï¼šå’Œ search æ“ä½œç±»ä¼¼ï¼Œåªæ˜¯ä¸éœ€è¦åˆ¤æ–­æœ€åä¸€ä¸ªå­—ç¬¦ç»“ç‚¹çš„isEndï¼Œå› ä¸ºæ—¢ç„¶èƒ½åŒ¹é…åˆ°æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œé‚£åé¢ä¸€å®šæœ‰å•è¯æ˜¯ä»¥å®ƒä¸ºå‰ç¼€çš„ã€‚

```cpp
bool startsWith(string prefix) {
    Trie* node = this;
    for (char c : prefix) {
        node = node->next[c-'a'];
        if (node == NULL) {
            return false;
        }
    }
    return true;
}
```


åˆ°è¿™æˆ‘ä»¬å°±å·²ç»å®ç°äº†å¯¹ Trie çš„ä¸€äº›åŸºæœ¬æ“ä½œï¼Œè¿™æ ·æˆ‘ä»¬å¯¹ Trie å°±æœ‰äº†è¿›ä¸€æ­¥çš„ç†è§£ã€‚å®Œæ•´ä»£ç æˆ‘è´´åœ¨äº†æ–‡æœ«ã€‚

æ€»ç»“
é€šè¿‡ä»¥ä¸Šä»‹ç»å’Œä»£ç å®ç°æˆ‘ä»¬å¯ä»¥æ€»ç»“å‡º Trie çš„å‡ ç‚¹æ€§è´¨ï¼š

Trie çš„å½¢çŠ¶å’Œå•è¯çš„æ’å…¥æˆ–åˆ é™¤é¡ºåºæ— å…³ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹äºä»»æ„ç»™å®šçš„ä¸€ç»„å•è¯ï¼ŒTrie çš„å½¢çŠ¶éƒ½æ˜¯å”¯ä¸€çš„ã€‚

æŸ¥æ‰¾æˆ–æ’å…¥ä¸€ä¸ªé•¿åº¦ä¸º L çš„å•è¯ï¼Œè®¿é—® next æ•°ç»„çš„æ¬¡æ•°æœ€å¤šä¸º L+1ï¼Œå’Œ Trie ä¸­åŒ…å«å¤šå°‘ä¸ªå•è¯æ— å…³ã€‚

Trie çš„æ¯ä¸ªç»“ç‚¹ä¸­éƒ½ä¿ç•™ç€ä¸€ä¸ªå­—æ¯è¡¨ï¼Œè¿™æ˜¯å¾ˆè€—è´¹ç©ºé—´çš„ã€‚å¦‚æœ Trie çš„é«˜åº¦ä¸º nï¼Œå­—æ¯è¡¨çš„å¤§å°ä¸º mï¼Œæœ€åçš„æƒ…å†µæ˜¯ Trie ä¸­è¿˜ä¸å­˜åœ¨å‰ç¼€ç›¸åŒçš„å•è¯ï¼Œé‚£ç©ºé—´å¤æ‚åº¦å°±ä¸º O(m^n^)


æœ€åï¼Œå…³äº Trie çš„åº”ç”¨åœºæ™¯ï¼Œå¸Œæœ›ä½ èƒ½è®°ä½ 8 ä¸ªå­—ï¼šä¸€æ¬¡å»ºæ ‘ï¼Œå¤šæ¬¡æŸ¥è¯¢ã€‚(æ…¢æ…¢é¢†æ‚Ÿå­~~)

```cpp

class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }
    
    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c-'a'] == NULL) {
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            node = node->next[c - 'a'];
            if (node == NULL) {
                return false;
            }
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            node = node->next[c-'a'];
            if (node == NULL) {
                return false;
            }
        }
        return true;
    }
};
```



### 105 ä»å‰åºéå†å’Œååºéå†æ„å»ºäºŒå‰æ ‘

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }

        // å‰åºéå†ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
        int preorder_root = preorder_left;
        // åœ¨ä¸­åºéå†ä¸­å®šä½æ ¹èŠ‚ç‚¹
        int inorder_root = index[preorder[preorder_root]];

        // å…ˆæŠŠæ ¹èŠ‚ç‚¹å»ºç«‹å‡ºæ¥
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // å¾—åˆ°å·¦å­æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ç›®
        int size_left_subtree = inorder_root - inorder_left;
        // é€’å½’åœ°æ„é€ å·¦å­æ ‘ï¼Œå¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
        // å…ˆåºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ+1 å¼€å§‹çš„ size_left_subtreeã€ä¸ªå…ƒç´ å°±å¯¹åº”äº†ä¸­åºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ å¼€å§‹åˆ° æ ¹èŠ‚ç‚¹å®šä½-1ã€çš„å…ƒç´ 
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // é€’å½’åœ°æ„é€ å³å­æ ‘ï¼Œå¹¶è¿æ¥åˆ°æ ¹èŠ‚ç‚¹
        // å…ˆåºéå†ä¸­ã€Œä» å·¦è¾¹ç•Œ+1+å·¦å­æ ‘èŠ‚ç‚¹æ•°ç›® å¼€å§‹åˆ° å³è¾¹ç•Œã€çš„å…ƒç´ å°±å¯¹åº”äº†ä¸­åºéå†ä¸­ã€Œä» æ ¹èŠ‚ç‚¹å®šä½+1 åˆ° å³è¾¹ç•Œã€çš„å…ƒç´ 
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // æ„é€ å“ˆå¸Œæ˜ å°„ï¼Œå¸®åŠ©æˆ‘ä»¬å¿«é€Ÿå®šä½æ ¹èŠ‚ç‚¹
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```





