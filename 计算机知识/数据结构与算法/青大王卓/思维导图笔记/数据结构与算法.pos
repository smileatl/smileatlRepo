{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"e520c01f9a71","children":[{"parent":"428c95d5cace","children":[{"parent":"32e9ce51477b","children":[],"id":"392530bace8c","title":"是指相互之间存在一种或多种特定关系的数据元素的集合"},{"parent":"32e9ce51477b","children":[],"id":"b3eb67f25ca6","title":"或者说，数据结构是带结构的数据元素的集合"}],"id":"32e9ce51477b","title":"1. 什么是数据结构"},{"parent":"428c95d5cace","children":[{"parent":"1b9ffe2a6012","children":[{"parent":"6df175892e71","children":[],"id":"dd264950cb94","title":"描述数据元素之间的逻辑关系"},{"parent":"6df175892e71","children":[],"id":"fe1614626672","title":"与数据的存储无关，独立于计算机"},{"parent":"6df175892e71","children":[],"id":"f46ac65f3b9c","title":"是从具体问题抽象出来的数学模型"}],"id":"6df175892e71","title":"逻辑结构"},{"parent":"1b9ffe2a6012","children":[{"parent":"0c9c79f45401","children":[],"id":"db44f8476252","title":"数据元素及其关系在计算机存储器中的结构（存储方式）"}],"id":"0c9c79f45401","title":"物理结构（存储结构））"}],"id":"1b9ffe2a6012","title":"2. 数据结构的两种层次","summaries":[{"summary":true,"parent":"1b9ffe2a6012","children":[{"parent":"68c8f93b87ae","children":[{"parent":"27165db47d2a","children":[],"id":"6d43bb560e27","title":"有且仅有一个开始和一个终端结点，<br>并且所有结点都最多只有一个直接前趋和一个直接后继"},{"parent":"27165db47d2a","children":[],"id":"5f8bd0989fb2","title":"例如：线性表、栈、队列、串、"}],"id":"27165db47d2a","title":"1. 线性结构"},{"parent":"68c8f93b87ae","children":[{"parent":"80fbbc2a66a8","children":[],"id":"dc90477b1537","title":"一个结点可能有多个直接前趋和直接后继"},{"parent":"80fbbc2a66a8","children":[{"parent":"1a7d1168aa54","children":[],"id":"f23eec1cadce","title":"树：棋盘预测分析，数据像树木一样展开"},{"parent":"1a7d1168aa54","children":[],"id":"7bd58e41a115","title":"图：地图最短路径，数据像一张网格一个错综复杂"}],"id":"1a7d1168aa54","title":"例如：树和图"}],"id":"80fbbc2a66a8","title":"2. 非线性结构"}],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"68c8f93b87ae","title":"逻辑结构的种类"},{"summary":true,"parent":"1b9ffe2a6012","children":[{"parent":"34052472c4ef","children":[{"parent":"9d762c961682","children":[],"id":"8cbc08b39aa4","title":"用一组连续的存储单元依次存放数据"},{"parent":"9d762c961682","children":[],"id":"eacfb0f2e7b6","title":"数据元素之间的逻辑关系由元素的存储位置来表示"},{"parent":"9d762c961682","children":[],"id":"951a707fbf54","title":"C语言中的数组、C++中的vector容器都是顺序存储结构"}],"id":"9d762c961682","title":"1. 顺序存储结构"},{"parent":"34052472c4ef","children":[{"parent":"1e1b59b46f7c","children":[],"id":"09d225e50e5c","title":"存储空间不连续，元素之间的逻辑关系用结点的指针表示"},{"parent":"1e1b59b46f7c","children":[],"id":"0e4ae467a423","title":"List容器应该就是用的链式存储结构"}],"id":"1e1b59b46f7c","title":"2. 链式存储结构"},{"parent":"34052472c4ef","children":[],"id":"cc29624ff047","title":"3. 索引存储结构"},{"parent":"34052472c4ef","children":[],"id":"f2cfdcc25b22","title":"4. 散列存储结构"}],"range":"1,1","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"34052472c4ef","title":"存储结构的种类"}]}],"collapsed":true,"id":"428c95d5cace","title":"1. 数据结构"},{"parent":"e520c01f9a71","children":[{"parent":"7d6f57c4e7de","children":[],"id":"0f76f6ad5f2d","title":"对特定问题求解方法和步骤的一种描述，它是指令的有限序列。<br>对解决问题的方法的描述"},{"parent":"7d6f57c4e7de","children":[{"parent":"0b9396f5f54b","children":[],"id":"e9fa2ea362d9","title":"1. 自然语言：英语、中文"},{"parent":"0b9396f5f54b","children":[],"id":"0654855bc835","title":"2. 流程图：传统流程图、NS流程图"},{"parent":"0b9396f5f54b","children":[],"id":"4be5f82b130f","title":"3. 伪代码：类C语言"},{"parent":"0b9396f5f54b","children":[],"id":"8020a316edad","title":"4. 程序代码：C语言，C++语言程序"}],"id":"0b9396f5f54b","title":"算法的描述方法"},{"parent":"7d6f57c4e7de","children":[{"parent":"e90f460dcbf7","children":[],"id":"918a819f3bc8","title":"1. 有穷性：一个算法总是在执行有穷步骤后结束"},{"parent":"e90f460dcbf7","children":[],"id":"297ab5951a90","title":"2. 确定性：算法中的每一条指令必须有确切的含义，没有二义性"},{"parent":"e90f460dcbf7","children":[],"id":"2862e50364c7","title":"3. 可行性： 算法是可执行的"},{"parent":"e90f460dcbf7","children":[],"id":"b7b3211bbf2d","title":"4. 输入：一个算法有0个或者多个输入"},{"parent":"e90f460dcbf7","children":[],"id":"fc8a4e3e34bd","title":"5. 输出：输出待求结果"}],"id":"e90f460dcbf7","title":"算法的特性"},{"parent":"7d6f57c4e7de","children":[{"parent":"9c88ca3afdbf","children":[{"parent":"f68ccda18d23","children":[],"id":"87a3eb85d7f7","title":"1. 没有语法错误"},{"parent":"f68ccda18d23","children":[],"id":"d68d2d82415d","title":"2. 对于精心选择的，苛刻的刁难的数据也能输出正确的结果"},{"parent":"f68ccda18d23","children":[],"id":"286480a99a61","title":"3. 程序对于一切合法的输入数据都能得到正确的输出结果"}],"id":"f68ccda18d23","title":"1. 正确性："},{"parent":"9c88ca3afdbf","children":[],"id":"bdeeebc2667c","title":"2. 可读性<br>"},{"parent":"9c88ca3afdbf","children":[{"parent":"ed7ab0063f0c","children":[],"id":"9702d71d1c93","title":"1. 指当输入非法数据的时候，算法能够恰当的做出反应或进行相应处理，而不是输出莫名其妙的结果"},{"parent":"ed7ab0063f0c","children":[],"id":"156493f64979","title":"2. 处理出错的方法，不应是中断程序的执行，而应是返回一个表示错误或者错误性质的值，以便在更高抽象层次上进行处理"}],"id":"ed7ab0063f0c","title":"3. 健壮性"},{"parent":"9c88ca3afdbf","children":[{"parent":"dcda09d30ee7","children":[{"parent":"0e4eb8336ee1","children":[{"parent":"75db358ac057","children":[{"parent":"2269e23f19a7","children":[{"parent":"83e6a5145350","children":[],"id":"4e2b2e600215","title":"缺点：<br>1. 将算法转换为实际能够运行的程序需要花费大量的时间<br>2. 所得到的测试结果依赖于计算的软硬件等环境因素<br>因此——不常用"}],"id":"83e6a5145350","title":"1. 事后统计：将算法实现运行，测算其时间和空间的开销"},{"parent":"2269e23f19a7","children":[{"parent":"4ae31d413607","children":[{"parent":"4342bae72042","children":[],"id":"76def241b747","title":"王卓老师视频截图"},{"parent":"4342bae72042","children":[],"style":{"font-weight":"bold"},"id":"4cd76ec82e50","title":"为了便于比较不同算法的时间效率，简化我们分析算法的时间耗度，我们一般仅比较他们的数量级"},{"parent":"4342bae72042","children":[{"parent":"7ec60b15b714","children":[{"parent":"6541c7304c83","children":[],"id":"fea326c275b7","title":"1. 加法规则 O(f(n))=O(f1+f2)"},{"parent":"6541c7304c83","children":[],"id":"5cedfe6d4f49","title":"2. 乘法规则 O(f(n))=O(f1xf2)"}],"id":"6541c7304c83","title":"对于复杂的算法，我们可以将算法分成容易估算的几个部分<br>然后利用加法规则和乘法规则计算算法总的时间复杂度"}],"id":"7ec60b15b714","title":"时间复杂度的概念：若有某个辅助函数f（n），使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度<br>"}],"collapsed":false,"id":"4342bae72042","title":"事前分析方法：<br>算法运行时间 =一个简单操作所需的时间（如赋值、移动、比较）*简单操作次数<br>简单来说，就是算法中每条语句执行时间之和<br>更进一步，将单条语句的执行之间设定为单位执行时间，不考虑硬件和语言特性<br>则算法的耗费时间定义为<b>该算法中每条语句的频度之和</b>"}],"style":{"border-radius":"20px","background-color":"rgb(255, 255, 255)","color":"rgb(242, 154, 102)","border-color":"rgb(242, 154, 102)","border-width":"2px","border-style":"solid"},"id":"4ae31d413607","title":"2. 事前分析：对算法所耗时间和空间资源的一种估计"}],"id":"2269e23f19a7","title":"算法时间效率的度量"}],"id":"75db358ac057","title":"时间效率：指的是算法所耗费的时间"},{"parent":"0e4eb8336ee1","children":[],"id":"1c21225c6f37","title":"空间效率：指的是算法执行过程中所耗费的存储空间"}],"collapsed":false,"id":"0e4eb8336ee1","title":"要求花费尽量少的时间和尽量低的存储需求"}],"collapsed":true,"id":"dcda09d30ee7","title":"4. 高效性"},{"parent":"9c88ca3afdbf","children":[],"id":"fcaaa3f19e31","title":"5. 鲁棒性？"}],"id":"9c88ca3afdbf","title":"算法设计的要求"}],"collapsed":true,"id":"7d6f57c4e7de","title":"2. 算法"}],"collapsed":false,"id":"e520c01f9a71","title":"1. 基本概念","summaries":[]},{"parent":"root","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"0e704fdaa4e4","children":[{"parent":"25a74480057b","children":[{"parent":"f5565eb3c0c6","children":[],"id":"e79d9805052f","title":"线性表只有一个表头和一个表尾"},{"parent":"f5565eb3c0c6","children":[],"id":"896b6b9c019e","title":"线性表中每一个元素最多只有一个前趋和一个后继"}],"collapsed":false,"id":"f5565eb3c0c6","title":"线性表的定义：零个或多个元素的有限序列<br>"},{"parent":"25a74480057b","children":[{"parent":"f287cd61ea3e","children":[{"parent":"563ae58f2519","children":[],"id":"eb48c6e6a722","title":"1. 顺序线性表初始化算法实现"},{"parent":"563ae58f2519","children":[],"id":"a4d95b3499d6","title":"2. 顺序线性表清空、销毁算法实现"},{"parent":"563ae58f2519","children":[],"id":"f7bf0c23b6bf","title":"3. 顺序线性表查找算法实现（时间复杂度O(n)）"},{"parent":"563ae58f2519","children":[],"id":"ab335f4f5e16","title":"4. 顺序线性表插入、删除算法实现（时间复杂度为O(n)）"}],"collapsed":true,"id":"563ae58f2519","title":"1. 顺序存储：必须是占用一片连续的存储空间。中间有空出来的地址，都不能叫做线性表的顺序存储<br>利用数据元素的存储位置表示线性表中相邻元素的前后关系；<br>顺序存储的线性表其逻辑关系和存储关系是一致的"},{"parent":"f287cd61ea3e","children":[{"parent":"a43bdf5d810a","children":[{"parent":"a5785ebb6831","children":[{"parent":"71af578c1d5c","children":[],"id":"1b65143139ea","title":"每个结点只有一个数据域和一个指针域"}],"id":"71af578c1d5c","title":"1. 单链表"},{"parent":"a5785ebb6831","children":[{"parent":"fbd146a92da0","children":[],"id":"79d96a8734c6","title":"每个结点有一个数据域和两个指针域"}],"id":"fbd146a92da0","title":"2. 双链表"},{"parent":"a5785ebb6831","children":[{"parent":"5a1a7023ec3e","children":[],"id":"57a684ba2b14","title":"首尾相接的链表成为循环链表"}],"id":"5a1a7023ec3e","title":"3. 循环链表"}],"id":"a5785ebb6831","title":"链式存储，由一个个结点相互链接形成的数据存储结构；<br>每一个结点由数据域和指针域组成；<br>数据域负责存储元素的数值数据；<br>指针域负责存储直接后继（以及前趋）结点的存储位置；"}],"id":"a43bdf5d810a","title":"2. 链式存储<br>","summaries":[{"summary":true,"parent":"a43bdf5d810a","children":[{"parent":"aedbd8210dd1","children":[],"id":"786a9f882efb","title":"1. 结点在存储器中的位置是任意的，即逻辑上相邻的元素在物理上不一定相邻"},{"parent":"aedbd8210dd1","children":[],"id":"c96bc7db49df","title":"2. 不支持随机访问。访问时只能通过头指针进入链表，通过结点的指针域挨个访问元素"},{"parent":"aedbd8210dd1","children":[{"parent":"00444a70b035","children":[{"parent":"801f4e450e6c","children":[],"id":"463d1a260c35","title":"1. 单链表：O(1)"},{"parent":"801f4e450e6c","children":[],"id":"5c8817e95b17","title":"2. 头指针循环链表：O(1)"},{"parent":"801f4e450e6c","children":[],"id":"ac3e1d0ba424","title":"3. 带尾指针的循环链表：O(1)、"},{"parent":"801f4e450e6c","children":[],"id":"fbfda23b2fdf","title":"4. 双向链表：O(1)"}],"id":"801f4e450e6c","title":"1. 查找链表首元素"},{"parent":"00444a70b035","children":[{"parent":"5822f422e42a","children":[],"id":"0387d67193ff","title":"1. 单链表：O(n)"},{"parent":"5822f422e42a","children":[],"id":"02eaeb7d91d7","title":"2. 头指针循环链表：O(n)"},{"parent":"5822f422e42a","children":[],"id":"ab4e090ffecc","title":"3. 带尾指针的循环链表：O(1)"},{"parent":"5822f422e42a","children":[],"id":"ded9a5b89f8b","title":"4. 双向链表：O(1)"}],"id":"5822f422e42a","title":"2. 查找链表尾元素"}],"id":"00444a70b035","title":"3. 算法时间复杂度分析"}],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"aedbd8210dd1","title":"链表存储结构的特点"}]}],"collapsed":false,"id":"f287cd61ea3e","title":"存储结构方式","summaries":[{"summary":true,"parent":"f287cd61ea3e","children":[{"parent":"0b749144c53a","children":[],"id":"90dfee05e89e","title":"优点：<br>1 - 存储密度大（结点本身所占存储量/结点结构所占存储量）<br>2 - 可以随机存取表中任一元素"},{"parent":"0b749144c53a","children":[],"id":"f4d13c0c37f2","title":"缺点：<br>1 - 在表头或者中间插入元素，由于需要移动大量的元素，操作效率低<br>2 - 由于实现方式是数组的基本思想，其实会浪费很多空间<br>3 - 还是底层是数组的弊端，属于静态存储形式，数据元素的个数并不能自由扩充"}],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"0b749144c53a","title":"优缺点："}]}],"collapsed":true,"style":{"font-weight":"bold"},"id":"25a74480057b","title":"1. 线性表","summaries":[{"summary":true,"parent":"25a74480057b","children":[{"parent":"c18dc439487d","children":[],"id":"8dbdda8f8a5f","title":"1. 一元多项式的运算<br>"},{"parent":"c18dc439487d","children":[],"id":"d19e37864f73","title":"2. 稀疏多项式的运算"},{"parent":"c18dc439487d","children":[],"id":"cbb64a61df8f","title":"3. 图书馆管理系统"}],"range":"1,1","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"c18dc439487d","title":"三个案例说明线性表不同的存储结构使用场景"}]},{"parent":"0e704fdaa4e4","children":[{"parent":"6da251609dca","children":[{"parent":"dfc9aa940b21","children":[{"parent":"42cbbe7cfce6","children":[{"parent":"a3e5550fe50d","children":[],"id":"9682ccb7a02d","title":"常用，因为比较简单，清空和销毁都比较方便"}],"id":"a3e5550fe50d","title":"1. 顺序结构栈"},{"parent":"42cbbe7cfce6","children":[],"id":"67aa15322f06","title":"2. 链式结构栈"},{"parent":"42cbbe7cfce6","children":[{"parent":"61ecb718c782","children":[],"id":"c6947ae3397f","title":"我们熟知的递归函数就是使用了栈的一种方法。每一次函数的调用，变量和返回地址都会被保存在栈里<br>最先调用的，最后拿出来。"}],"id":"61ecb718c782","title":"3. 栈和递归"}],"id":"42cbbe7cfce6","title":"栈"},{"parent":"dfc9aa940b21","children":[{"parent":"ae0bb7288c71","children":[{"parent":"ac0db752e258","children":[{"parent":"0bf85e15d9c1","children":[],"id":"2840904ec774","title":"常用循环顺序队列"},{"parent":"0bf85e15d9c1","children":[{"parent":"e10c3a5feec1","children":[],"id":"02564d8069e6","title":"1. 设置一个标志flag"},{"parent":"e10c3a5feec1","children":[],"id":"d145929a5277","title":"2. 增加了一个变量对元素个数计数"},{"parent":"e10c3a5feec1","children":[{"image":{"w":290,"h":193,"url":"http://cdn.processon.com/60169e611e085334847279c9?e=1612098673&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-1GunY6_3vyuo4ksdTjRRAW5t_s="},"parent":"ea07413525f9","children":[],"id":"c1cadf7d831b","title":""}],"collapsed":false,"id":"ea07413525f9","title":"3. 少使用一个空间，让空队的判断条件是front==rear<br>满队的判断条件为front == rear_next"}],"id":"e10c3a5feec1","title":"循环顺序队列如何判断空队和满队？"}],"id":"0bf85e15d9c1","title":"1. 顺序队列"},{"parent":"ac0db752e258","children":[{"parent":"7d6381f3c7b6","children":[{"parent":"cec681db4a0b","children":[{"parent":"ee26ea3b4242","children":[],"id":"26c74ea64502","title":"初始化、添加、删除元素用的是同一种逻辑"}],"id":"ee26ea3b4242","title":"与链表的相同的地方"},{"parent":"cec681db4a0b","children":[{"parent":"6a7742c2eb16","children":[],"id":"7fbb7251c2f0","title":"插入元素只能在表尾插，删除元素只能删除表头的元素"},{"parent":"6a7742c2eb16","children":[{"parent":"7b4ebfa54d36","children":[],"id":"eadd068e16f8","title":"struct Qnode<br>{<br>    ELemType data;<br>    Qnode *next;<br>};<br>struct LinkQueue //再定义一个抽象数据类型，一次性建立两个Qnode指针<br>{<br>    Qnode *front; //头指针<br>    Qnode *rear;  //尾指针<br>};"}],"id":"7b4ebfa54d36","title":"定义的方式有些许不一样，导致后面函数的访问就不一样"}],"id":"6a7742c2eb16","title":"与链表不同的地方"}],"id":"cec681db4a0b","title":"链式队列其实就是一种简化版的链表"}],"id":"7d6381f3c7b6","title":"2. 链式队列"}],"id":"ac0db752e258","title":"表尾插入、表头删除<br>"}],"id":"ae0bb7288c71","title":"队列"}],"collapsed":false,"id":"dfc9aa940b21","title":"栈和队列是一种特殊的线性表<br>栈只能从表尾插入元素，删除元素只能删除最后一个元素，秉持着先进后出的原则<br>队列只能从表尾插入元素，删除元素只能删除第一个元素，秉持着先进先出的原则"}],"collapsed":true,"style":{"font-weight":"bold"},"id":"6da251609dca","title":"2. 栈和队列","summaries":[]},{"parent":"0e704fdaa4e4","children":[{"parent":"80f3966044ee","children":[{"parent":"0399eb7719f3","children":[{"parent":"ae22f256b04e","children":[],"id":"3dfcdd441760","title":"1. 子串：串中任意个连续字符组成的子序列成为该串的子串<br>"},{"parent":"ae22f256b04e","children":[],"id":"e2740263116d","title":"2. 主串：包含子串的串相应地称为主串"},{"parent":"ae22f256b04e","children":[],"id":"16d74bee2ece","title":"3. 字符位置：字符在序列中的序号为该字符在串中的位置"},{"parent":"ae22f256b04e","children":[],"id":"05bb82d9dcb1","title":"4. 子串位置：子串第一个字符在主串中的位置"},{"parent":"ae22f256b04e","children":[],"id":"6c9d04b33891","title":"5. 空格串：由一个或多个空格组成的串，与空串是不一样的"},{"parent":"ae22f256b04e","children":[],"id":"80bbbcd4c0a4","title":"6. 串相等：当且仅当两个串的长度一样，且对应的字符都一一相等才能叫做串相等"}],"id":"ae22f256b04e","title":"串的一些术语"},{"parent":"0399eb7719f3","children":[{"parent":"41094baf579b","children":[],"id":"b95035de0403","title":"1. 顺序存储：简单，灵活。常用"},{"parent":"41094baf579b","children":[],"id":"29a90ff64a78","title":"2. 链式存储：插入和删除比较方便，但是存储效率只有20%，太低了"}],"id":"41094baf579b","title":"串的存储结构"}],"id":"0399eb7719f3","title":"1. 串：字符串的简称"},{"parent":"80f3966044ee","children":[{"parent":"75b1db652140","children":[{"parent":"84cd83af47ea","children":[],"id":"a4d2706b82f6","title":"1. 可以看做是非线性结构：一个在二维数组的元素，可能不止有一个前趋和一个后继，因此不是一个线性结构<br>"},{"parent":"84cd83af47ea","children":[],"id":"a727543fd829","title":"2. 也可以看作是线性的。因为其实没有二维数组的概念，二维数组本质上是数组的数组，一维数组中每一个元素又是一维数组罢了"}],"id":"84cd83af47ea","title":"1. 二维数组的逻辑结构"},{"parent":"75b1db652140","children":[{"parent":"eca439af9972","children":[{"parent":"39c46ab2df24","children":[],"id":"a25feb19a532","title":"压缩存储方法：一般只存储下三角矩阵的元素（包括对角线），<br>下三角矩阵是一个递增的等差数列：元素个数=n*(n+1)/2<br>把这么多个数存在一行里。如果要解压缩，还是比较好推的<br>"}],"id":"39c46ab2df24","title":"1. 对称矩阵"},{"parent":"eca439af9972","children":[{"parent":"cbfd33e9fbee","children":[],"id":"7912af557887","title":"压缩存储方式：用一个三元组表示稀疏矩阵中的非零元素<br>三元组的前两个元素是表示元素的坐标，第三个元素是值本身"}],"id":"cbfd33e9fbee","title":"2. 稀疏矩阵（矩阵中超过95%的元素都是0）"},{"parent":"eca439af9972","children":[{"parent":"faae70daae6e","children":[],"id":"19414691f3c8","title":"压缩存储方法：1. 每一条带（对角线）存一行<br>2. 带状矩阵每一行非零的存一行（最前面几行和最后面几行要补0）"}],"id":"faae70daae6e","title":"3. 带状矩阵（对角矩阵）"}],"id":"eca439af9972","title":"2. 二维数据的压缩存储方法"}],"id":"75b1db652140","title":"2.数组"},{"parent":"80f3966044ee","children":[{"parent":"aa6d5953b44a","children":[{"parent":"70598f1b93d4","children":[{"parent":"1233f3baa5d4","image":{"w":367,"h":227,"url":"http://cdn.processon.com/6018e0bfe0b34d6520d2f3a3?e=1612246735&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:vmkDRKIjxAllQsVu9CdP2WfLUVo="},"children":[],"id":"cff89d49c022","title":"广义表的表头是第一个元素，表尾是除开第一个元素的剩余元素集合<br>广义表的递归有些类似于链表"}],"collapsed":false,"id":"1233f3baa5d4","title":"广义表的几种定义"},{"parent":"70598f1b93d4","children":[{"parent":"bccc956cdeef","children":[],"id":"f8ff9f5b80d6","title":"1. 广义表的长度：最外层括号所包含的元素个数"},{"parent":"bccc956cdeef","children":[],"id":"c6898637863b","title":"2. 广义表的深度：把广义表展开，括号对的重数<br>空表是深度为1，原子深度为0"},{"image":{"w":351,"h":202,"url":"http://cdn.processon.com/6018e2fb637689536e1491fb?e=1612247307&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Uf6JIrDaX8yZ3qU7ackvy0EJIig="},"parent":"bccc956cdeef","children":[],"id":"94469cf981e1","title":""},{"parent":"bccc956cdeef","children":[],"id":"7076b85b9845","title":"4. 一个非空广义表的表头可以是一个原子，也可以是一个广义表<br>但是广义表的表尾一定是一个表尾"}],"id":"bccc956cdeef","title":"广义表的一些术语"}],"id":"70598f1b93d4","title":"广义表是线性表的推广<br>线性表中的元素是单一的，<br>而广义表中的元素可以是一种普通的数据类型<br>也可以是广义表本身，有一种递归的潜质"}],"id":"aa6d5953b44a","title":"3. 广义表"}],"collapsed":true,"id":"80f3966044ee","title":"3. 串、数组、广义表"},{"parent":"0e704fdaa4e4","children":[{"parent":"589bfe5396cc","children":[{"parent":"058adfafb8fb","children":[{"parent":"5333d636bd86","children":[{"parent":"7ff7eb416795","children":[],"id":"6dc7463976fe","title":"1. n=0时称为空树"},{"parent":"7ff7eb416795","children":[],"id":"877efdaaa79b","title":"2. n&gt;=1时<br>有且仅有一个结点称为树的根（root）<br>其余结点可分为m(m&gt;=0)个互不相交的有限集合，T1,T2...<br>其中每一个有限集合又可以看作是一个树，称为子树（sub-tree）"}],"id":"7ff7eb416795","title":"n（n&gt;=0）个结点的有限集"},{"parent":"5333d636bd86","children":[],"id":"8f242a6f376b","title":"常见的，我们写文章标题的分类，就是树的结构"}],"collapsed":false,"id":"5333d636bd86","title":"1. 树的定义"},{"parent":"058adfafb8fb","children":[{"parent":"319d4bef0353","children":[],"id":"c4f3f07df8ae","title":"1. 根结点：非空树表中，没有直接前趋的结点就是根节点"},{"parent":"319d4bef0353","children":[],"id":"58fb4b378bf5","title":"2. 结点的度：结点所包含的子树的个数"},{"parent":"319d4bef0353","children":[],"id":"f10aec79f86b","title":"3. 树的度：树内各结点的度的最大值"},{"image":{"w":424,"h":186,"url":"http://cdn.processon.com/6019647cf346fb1a6b84e307?e=1612280461&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:daNck6QxdbPhcObblGjGNoBewao="},"parent":"319d4bef0353","children":[],"id":"5798dc19048f","title":""},{"parent":"319d4bef0353","children":[],"id":"0d7e304506c0","title":"4. 树的深度：树种结点层次的最大数，有时也叫树的高度"},{"parent":"319d4bef0353","children":[],"id":"21ecc165d538","title":"5. 森林：m（m&gt;=0）互不相交的树的集合"}],"collapsed":false,"id":"319d4bef0353","title":"2. 树的术语"},{"parent":"058adfafb8fb","children":[{"parent":"59f396566c3c","children":[],"id":"9a1aa0f5f53e","title":"1. 线性表的表头元素无前趋<br>树的根节点无双亲<br>"},{"parent":"59f396566c3c","children":[],"id":"1b25adce9764","title":"2. 线性表的表尾元素无后继<br>树的叶子无孩子"},{"parent":"59f396566c3c","children":[],"id":"263731712f4b","title":"3. 线性表中的元素只有一个前趋和一个后继：一对一的关系<br>树中的结点是有一个双亲和多个孩子：一对多的关系"}],"collapsed":true,"id":"59f396566c3c","title":"3. 树和线性表之间的区别："}],"collapsed":true,"id":"058adfafb8fb","title":"1. 树的定义"},{"parent":"589bfe5396cc","children":[{"parent":"458cd983fe2c","children":[],"id":"8f056fed66c5","title":"二叉树的存在意义：普通的树因为太复杂了，用计算机实现的话非常麻烦<br>因此我们常用二叉树来使用树"},{"parent":"458cd983fe2c","children":[{"parent":"c1dbaba5a544","children":[{"parent":"3819e05f21e8","children":[],"id":"2d4fd5cc3c02","title":"1. 二叉树的结点最多只有两个度，也即只有两个孩子"},{"parent":"3819e05f21e8","children":[],"id":"ce8e40310acd","title":"2. 二叉树的子树是有左右之分的"},{"parent":"3819e05f21e8","children":[],"id":"ca1716ab3665","title":"严格来说，二叉树不是树的特殊情况<br>这是因为二叉树对子树的左右次序进行了严格的要求，即使只有一个子树，也要说明是左还是右|<br>这是二叉树和树之间最大的差别"}],"id":"3819e05f21e8","title":"由一个根节点和两个互不相交的左子树和右子树构成的集合"}],"collapsed":true,"id":"c1dbaba5a544","title":"1. 二叉树的定义："},{"parent":"458cd983fe2c","children":[{"parent":"a5c1b6bd3940","children":[],"id":"f4f284af1f1b","title":"1. 二叉树的第i层中最多有2^(i-1)个结点<br>最少也得有1个结点"},{"parent":"a5c1b6bd3940","children":[],"id":"2626ab928751","title":"2. 深度为k的二叉树的结点总数最多为2^k - 1<br>最少结点数为k"},{"parent":"a5c1b6bd3940","children":[],"id":"d235d0e2b841","title":"3. 在一个二叉树中，设叶子数（没有分支）的个数为n0，度为2（有两个分支）的个数为n2<br>则有n0 = n2 + 1<br>证明：设二叉树的边线总数为 B<br>B = n - 1<br>B = 2*n2 + n1<br>n = n0 + n1 + n2<br>则有：<br>n0 + n1 + n2 -1 = 2*n2 + n1<br>n0 = n2 +1"},{"parent":"a5c1b6bd3940","children":[{"parent":"1ca5a2673233","children":[{"parent":"dad4d010f043","children":[],"id":"f23c3ea25520","title":"满二叉树的叶子数是同深度最多的，2^(k-1)"},{"parent":"dad4d010f043","children":[],"id":"e93fe2a6dace","title":"满二叉树在同样深度的二叉树中，结点数是最多的"}],"id":"dad4d010f043","title":"1. 满二叉树：深度为k，结点总数为2^k-1(max)"},{"parent":"1ca5a2673233","children":[{"parent":"098b356e4c72","children":[],"id":"8aa183950271","title":"完全二叉树和满二叉树的编号是一一对应的"},{"parent":"098b356e4c72","children":[],"id":"6e6af6e3ba86","title":"完全二叉树的叶子结点只能分布在第i层和第i-1层"},{"parent":"098b356e4c72","children":[],"id":"3555301af6e1","title":"完全二叉树的某个结点的左子树的层数一定是右子树的同级后者下一级"}],"id":"098b356e4c72","title":"2. 完全二叉树：从满二叉树的最后一个结点（二叉树顺序：从上到下，从左到右），依次连续的去掉结点的二叉树，才能叫完全二叉树"},{"parent":"1ca5a2673233","children":[],"id":"9ab44ff0c118","title":"3. 具有n个结点的二叉树，有n+1个空指针域"}],"id":"1ca5a2673233","title":"补充知识点"},{"parent":"a5c1b6bd3940","children":[],"id":"52048e396cbc","title":"4. 具有n个结点的完全二叉树的深度k为：k = 向上取整（log2 n）"},{"parent":"a5c1b6bd3940","children":[{"parent":"d7e733306d9a","children":[],"id":"e66f38cdaf4f","title":"1. i= 1：该结点是根节点"},{"parent":"d7e733306d9a","children":[],"id":"96fda7120b26","title":"2. i的双亲结点是 向下取整（i/2）"},{"parent":"d7e733306d9a","children":[],"id":"d9ec831ea181","title":"3. 如果2*i &gt; n。那么该结点为叶子结点<br>"},{"parent":"d7e733306d9a","children":[],"id":"f7ed8f752c5f","title":"4. 如果2*i +1&gt;n。那么该节点没有右孩子"}],"id":"d7e733306d9a","title":"5. 具有n个结点的完全二叉树，其结点i有如下性质"}],"collapsed":true,"id":"a5c1b6bd3940","title":"2. 二叉树的性质"},{"parent":"458cd983fe2c","children":[{"parent":"a665dc4eb3d9","children":[{"parent":"aee89e252fe0","children":[],"id":"bd6aa0cde23f","title":"不常用，缺点如下：<br>1. 顺序结构不能改变长度，插入和删除很慢<br>2. 顺序结构表示非完全二叉树的时候，非常浪费空间"}],"id":"aee89e252fe0","title":"1. 顺序存储方式"},{"parent":"a665dc4eb3d9","children":[{"parent":"93a26d58f05a","children":[],"id":"1d9031590fdd","title":"记一条性质：有n个结点的二叉树，其结点的链域为空的个数为n+1"}],"id":"93a26d58f05a","title":"2. 链式存储方式"}],"collapsed":true,"id":"a665dc4eb3d9","title":"3. 二叉树的存储方式"},{"parent":"458cd983fe2c","children":[{"image":{"w":390,"h":151,"url":"http://cdn.processon.com/601b66630791290172275d9a?e=1612412019&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:fxnuN-yZ_0khoNwMY-2vdmrTcQ8="},"parent":"d310908feea4","children":[],"id":"df5ec4cb6328","title":"遍历二叉树时，我们选定一种遍历方式，比如说LDR中序遍历<br>在遍历时，对每一个结点（子树）都采用该遍历方式"},{"parent":"d310908feea4","children":[{"parent":"3197b09d24e0","children":[{"parent":"fecef3b8b9b8","children":[],"id":"80d110becbf2","title":"先序的首元素一定是根结点<br>那么，在中序中找到根结点，位于根结点之前的都是根结点的左子树，之后的都是右子树的<br>再反复根据先序和中序确定每一个元素的位置"}],"id":"fecef3b8b9b8","title":"1. 一种先序和中序可以反推"},{"parent":"3197b09d24e0","children":[{"parent":"352bf7735fa7","children":[],"id":"ec5e1a835993","title":"后序（LRD）的尾元素一定是根结点<br>那么，在中序中找到根结点，位于根结点之前的都是根结点的左子树，之后的都是右子树的<br>再反复根据后序和中序确定每一个元素的位置<br>"}],"id":"352bf7735fa7","title":"2. 已知中序和后序可以反推"}],"id":"3197b09d24e0","title":"已知遍历结果，能否反推二叉树的形状？"}],"collapsed":true,"id":"d310908feea4","title":"4. 二叉树的遍历方式"},{"parent":"458cd983fe2c","children":[{"parent":"9bde85ff532f","children":[{"parent":"461aa43499d8","children":[],"id":"2253fc0e6555","title":"1. 先序遍历DLR"},{"parent":"461aa43499d8","children":[],"id":"d38451dd9238","title":"2. 中序遍历LDR"},{"parent":"461aa43499d8","children":[],"id":"3e5c4f30f3fe","title":"3. 后序遍历LRD"},{"parent":"461aa43499d8","children":[],"id":"9276e944d8dc","title":"4. 中序遍历的非递归算法——使用栈保存结点信息"},{"parent":"461aa43499d8","children":[{"parent":"fc2990c1a6f8","children":[],"id":"e078cd3ae1e4","title":"BFS广度优先算法"},{"parent":"fc2990c1a6f8","children":[],"id":"6ade5bbf5109","title":"算法设计思路：<br>    1.将根结点入队<br>    2.队列不为空时循环，从队列中出列一个元素，访问它，并作以下步骤：<br>        2.1 如果该元素的左孩子不为空，让该元素的左孩子入队<br>        2.2 如果该元素的右孩子不为空，让该元素的右孩子入队<br>"}],"id":"fc2990c1a6f8","title":"5. 二叉树的层次遍历算法"}],"id":"461aa43499d8","title":"1. 二叉树的遍历"},{"parent":"9bde85ff532f","children":[{"parent":"e7baaf598114","children":[],"id":"3951a6b5771e","title":"1. 选定一个遍历方式。常用先序遍历DLR"},{"parent":"e7baaf598114","children":[],"id":"85742a91c4bc","title":"2. 使用递归函数，创建一个二叉树"},{"parent":"e7baaf598114","children":[],"id":"2d90190c2a7f","title":"3. 设定一个输入的特定字符，用于判定当前创建的结点没有左右孩子"}],"id":"e7baaf598114","title":"2. 二叉树的创建"},{"parent":"9bde85ff532f","children":[{"parent":"ec50cba3866b","children":[],"id":"ce4eb222ac32","title":"同二叉树的创建操作基本一致"}],"id":"ec50cba3866b","title":"3. 二叉树的复制"},{"parent":"9bde85ff532f","children":[{"parent":"6fabd7eef2d0","children":[],"id":"929376626a15","title":"算法非常巧妙，还是递归函数的方式，只不过在函数内部有两个变量，用于保存当前的深度值，通过比较输出双亲的左或右孩子的深度值"}],"id":"6fabd7eef2d0","title":"4. 求二叉树的深度"},{"parent":"9bde85ff532f","children":[],"id":"473a3a01d362","title":"5. 求二叉树的结点数"},{"parent":"9bde85ff532f","children":[],"id":"7b34a014c5f4","title":"6. 求二叉树的叶子数"}],"collapsed":true,"id":"9bde85ff532f","title":"5. 二叉树的操作"},{"parent":"458cd983fe2c","children":[{"parent":"127d01a0fb6e","children":[{"parent":"a56f7f9adacc","children":[],"id":"7da5c30fb548","title":"如果一个二叉树的的结点的左指针域为空，那么我们将左指针指向这个结点的前驱<br>如果结点的右指针为空，那么将右指针指向这个结点的后继<br>这里的前驱和后继指的是输出序列中结点的前后关系哈"}],"id":"a56f7f9adacc","title":"1. 线索二叉树的定义"}],"collapsed":true,"id":"127d01a0fb6e","title":"6. 线索二叉树"}],"collapsed":true,"style":{"font-weight":"bold"},"id":"458cd983fe2c","title":"2. 二叉树"},{"parent":"589bfe5396cc","children":[{"parent":"016aeeb9f7d3","children":[{"parent":"5a0828402f30","children":[{"parent":"eaca2196e70c","image":{"w":394,"h":197,"url":"http://cdn.processon.com/601d3e5af346fb6c348bc381?e=1612532842&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ip9L3bIDjRLrW3U6YRdBVKj---8="},"children":[],"id":"2a9e97c7dc43","title":"用一个数组存放一棵树，数组的元素是结构体，结构体的内容是树结点的内容，以及当前结点的双亲在数组中的下标"}],"id":"eaca2196e70c","title":"1. 双亲表示法"},{"parent":"5a0828402f30","children":[{"image":{"w":390,"h":233,"url":"http://cdn.processon.com/601d4087e401fd66249915c2?e=1612533399&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:_NrmWBbOiO-MpN3gK6Ec3WSPP90="},"parent":"110d27cd8455","children":[],"id":"aa0dd0a8e457","title":"把每一层的每一个结点的孩子们看作是一个链表，然后用数组存储树的每一个结点（从上到下，从左到右）<br>每个结点的孩子链表的数据域内容是孩子结点在数组中的位置"},{"parent":"110d27cd8455","image":{"w":391,"h":235,"url":"http://cdn.processon.com/601d425a5653bb053e33dd9e?e=1612533866&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:mWQkAcw0M2j28KdluAziGlN4CSY="},"children":[],"style":{"font-weight":"bold"},"id":"8b0f47779c6e","title":"这种存储方式，比较容易找到一个结点的孩子，但是不容易找到结点的双亲，那怎么样可以又快速找到双亲，又找孩子呢？<br>答案就是将孩子链表和双亲表示法结合起来，得到一个双亲孩子链表表示方法"}],"id":"110d27cd8455","title":"2. 孩子链表法"},{"parent":"5a0828402f30","children":[{"image":{"w":373,"h":210,"url":"http://cdn.processon.com/601d4366e0b34d41a740d551?e=1612534134&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:GPEB5TAz0h36uJH23_FOogXwmzk="},"parent":"985dd55deb50","children":[],"id":"520f3c9466d0","title":"同二叉树的定义方式相似，定义一个数据域，两个指针域。左指针指向当前结点的孩子，右指针呢，指向当前结点的兄弟结点，没有就为空。"}],"id":"985dd55deb50","title":"3. 孩子兄弟表示法"}],"collapsed":true,"id":"5a0828402f30","title":"1. 树的存储方式"},{"parent":"016aeeb9f7d3","children":[{"parent":"5e58759835ad","children":[{"parent":"163133c51123","children":[],"style":{"font-weight":"bold"},"id":"5d4548786c27","title":"借助与树的孩子兄弟链表表示法<br>我们将树转换为二叉树<br>几个字概括其转换方式：兄弟相连留长子"},{"image":{"w":371,"h":206,"url":"http://cdn.processon.com/601d48a15653bb053e33efac?e=1612535473&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:T92O-LukdPSXqAcKdUps7rQ1ZtI="},"parent":"163133c51123","children":[],"id":"e180cb868652","title":""}],"id":"163133c51123","title":"树转换成二叉树"},{"parent":"5e58759835ad","children":[{"parent":"fd975030b235","children":[],"id":"83000531c605","title":"口诀：左孩右右连双亲<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 去掉原来右孩线"},{"image":{"w":367,"h":179,"url":"http://cdn.processon.com/601d4a4b7d9c0830de4922ef?e=1612535899&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:7BR-5ZBNu9C-XgJzA2dTejdDH6Q="},"parent":"fd975030b235","children":[],"id":"c5a948134482","title":""}],"id":"fd975030b235","title":"二叉树转换成树"}],"collapsed":true,"id":"5e58759835ad","title":"2. 树和二叉树的转换方式"},{"parent":"016aeeb9f7d3","children":[{"parent":"278b7884b795","children":[],"id":"2f35058bebf0","title":"1. 先根（序）遍历：先访问树的根节点，再访问子树"},{"parent":"278b7884b795","children":[],"id":"4fe76d3cbb22","title":"2. 后根（序）遍历：先访问树的子树，最后访问根结点"},{"parent":"278b7884b795","children":[],"id":"4ce88b6d3a28","title":"3. 层次遍历"}],"collapsed":true,"id":"278b7884b795","title":"3. 树的遍历方式"},{"parent":"016aeeb9f7d3","children":[{"parent":"d075fcd15636","children":[{"parent":"82fb8087d568","children":[],"id":"78f081e740ce","title":"把森林拆分成一个个树，对树进行先根遍历"}],"id":"82fb8087d568","title":"1. 先序遍历"},{"parent":"d075fcd15636","children":[{"parent":"a866ec9603e6","children":[],"id":"1f61d31b21ed","title":"把森林拆分成一个个树，对树进行后根遍历"}],"id":"a866ec9603e6","title":"2. 中序遍历"}],"collapsed":true,"id":"d075fcd15636","title":"4. 森林的遍历方式"}],"collapsed":true,"id":"016aeeb9f7d3","title":"3. 树和森林"},{"parent":"589bfe5396cc","children":[{"parent":"12357f4cf0ed","children":[{"parent":"7dec72fbaf7d","children":[{"parent":"a919dc2777d0","children":[],"id":"365278dc57ca","title":"1. 路径：树的结点与结点之间的连线就是路径"},{"parent":"a919dc2777d0","children":[],"id":"a8e4956925c0","title":"2. 树的路径长度：从树的根节点到树的每个结点的路径长度之和"},{"parent":"a919dc2777d0","children":[],"id":"171294bf3800","title":"3. 权重：叶子结点的权重系数"},{"parent":"a919dc2777d0","children":[],"id":"80497f31ee32","title":"4. 树的带权路径长度之和：从根节点到叶子结点的路径之和再乘以对应的叶子结点的权重系数"}],"id":"a919dc2777d0","title":"1. 先补充点知识"},{"parent":"7dec72fbaf7d","children":[],"id":"51c9adace46f","title":"2. 哈夫曼树就是带权路径长度之和最小的树，也即最优树"},{"parent":"7dec72fbaf7d","children":[],"id":"e59476ec1ae9","title":"3. 哈夫曼树不唯一，同一带权路径长度之和可以有多种二叉树形式"},{"parent":"7dec72fbaf7d","children":[],"id":"0f96080918ae","title":"4. 满二叉树不一定是哈夫曼树"},{"parent":"7dec72fbaf7d","children":[],"id":"f5309250cfa6","title":"5. 哈夫曼树中权重越大的结点离根结点越近"}],"id":"7dec72fbaf7d","title":"1. 最优哈夫曼树的概念"},{"parent":"12357f4cf0ed","children":[{"parent":"b95b45121644","children":[{"parent":"f99ea7f95302","children":[],"id":"7ce8cfaf966e","title":"1. 删除两小造新人：<br>把权重结点设定为只有根结点的一颗颗树，把这些树组成一个森林<br>从树里面找到权重最小的两棵树，组成一颗新树，新树的权重是两小树的和<br>在森林中删除这两个小树，保留新的合成树<br>重复以上过程，直到森林变成一棵树"}],"id":"f99ea7f95302","title":"1. 构造思路"}],"id":"b95b45121644","title":"2. 哈夫曼树的构造"},{"parent":"12357f4cf0ed","children":[{"parent":"9c6053780e2e","children":[{"parent":"f699ae3c45fc","children":[],"id":"5eb3cfea9e03","title":"1. 由结点的权重构造一颗哈夫曼树（调用哈夫曼树构造函数）"},{"parent":"f699ae3c45fc","children":[],"id":"dab45320e5c4","title":"2. 从哈夫曼树的根节点开始，左边的路径是0，右边的路径是1，每一个的叶子结点的哈夫曼编码就此产生"}],"id":"f699ae3c45fc","title":"构造思路"}],"id":"9c6053780e2e","title":"3. 哈夫曼编码"},{"parent":"12357f4cf0ed","children":[{"parent":"6fe6578aaa2e","children":[{"parent":"d976fc2c7a1e","children":[],"id":"2a6a5d02da71","title":"1. 要通过哈夫曼编码算法得到哈夫曼的编码HC"},{"parent":"d976fc2c7a1e","children":[{"parent":"79558a284291","children":[],"id":"e46a071ca152","title":"1. 不查表：用暗文的二进制码，代入到哈夫曼树中，根据哈夫曼编码的原则，从哈夫曼树的根节点开始<br>向下，直到到达叶子结点，该叶子结点的就是对应的明文"},{"parent":"79558a284291","children":[],"id":"f5784edd7071","title":"2. 查表：我们通过哈夫曼编码算法都已经得到一个明文-暗文的对照表了，那我们就可以使用BF或者KMP匹配算法<br>在暗文中一点点的匹配对应的解码暗文，最终翻译整个暗文（我感觉这个速度应该有点慢、）"}],"id":"79558a284291","title":"2. 有了字母对应的哈夫曼编码表，我们可以使用两种方式进行解码"}],"id":"d976fc2c7a1e","title":"解码思路"}],"id":"6fe6578aaa2e","title":"4. 哈夫曼解码"}],"collapsed":true,"id":"12357f4cf0ed","title":"4. 哈夫曼树"}],"collapsed":true,"style":{"font-weight":"bold"},"id":"589bfe5396cc","title":"4. 树"},{"parent":"0e704fdaa4e4","children":[{"parent":"c7fb1158cc82","children":[{"parent":"837c078f9d24","children":[{"parent":"196f1cd0957b","children":[],"id":"8ea3b7a88b0f","title":"1. 有向图，图的边是有方向的"},{"parent":"196f1cd0957b","children":[],"id":"ae481122caff","title":"2. 无向图，图的边没有方向"},{"parent":"196f1cd0957b","children":[{"parent":"5b6b02531d37","children":[],"id":"bdee987d89e9","title":"无向图边的条数：n*(n-1)/2"},{"parent":"5b6b02531d37","children":[],"id":"a94a9e04824e","title":"有向图边的条数：n*(n-1)"}],"id":"5b6b02531d37","title":"3. 完全图：图的任意两个点都有边相连"},{"parent":"196f1cd0957b","children":[{"parent":"1b82896c27c0","children":[],"id":"b39d4a93c26c","title":"稀疏图：图的边数量很少&lt;nlogn"},{"parent":"1b82896c27c0","children":[],"id":"a111b5330f64","title":"稠密图：图的边数量很多"}],"id":"1b82896c27c0","title":"4.稀疏图和稠密图"},{"parent":"196f1cd0957b","children":[],"id":"6fc9e7b4e348","title":"5. 图的度：图的顶点相关联的边的数目<br>无向图中，一个顶点有几条边就是度多少<br>有向图中，分为出度和入度，出度和入度加起来是度"},{"parent":"196f1cd0957b","children":[],"id":"9562c4bd0220","title":"6. 图的路径：接续（连续的）边构成的顶点序列"},{"parent":"196f1cd0957b","children":[],"id":"986855a99cce","title":"7.连通图：在一个图中，任意两个顶点V,U都能找到连接他们的路径，那么这个图就是一个连通图，如果图是有向图的话，那称为强连通图"},{"parent":"196f1cd0957b","children":[],"id":"24aba6857754","title":"8. 子图：有如下G1和G两个图，如果有V1属于V，E1属于E，那么可以说G1属于G，G1是G的子图"}],"collapsed":true,"id":"196f1cd0957b","title":"1. G=（V,E）<br>V：顶点（数据元素）组成的有限非空集合<br>E：边的有限集合"}],"collapsed":true,"id":"837c078f9d24","title":"1. 图的定义"},{"parent":"c7fb1158cc82","children":[{"parent":"b31b8441f5c8","children":[{"parent":"19310ee4e5bb","children":[],"id":"048d1be03de3","title":"用一个二维数组，数组大小等于图的顶点个数的方阵。两个顶点之间有邻接关系，数组相应位置记为1，否则记为0<br>无向完全图的矩阵对角线为0，其余位置元素为1。无向图的邻接矩阵是一个对称矩阵<br>无向图的每一行或者每一列就代表对应元素的度"},{"parent":"19310ee4e5bb","children":[],"id":"7aae22780384","title":"在有向图中，邻接矩阵不是对称矩阵了<br>每一行表示的是从这个顶点发出的边（出度）<br>每一列表示的是这个顶点接收的边（入度）<br>行的非0元素和+列的非0元素和=度"},{"parent":"19310ee4e5bb","children":[{"parent":"e6c1ff12cfee","children":[],"id":"c11d6a3bf6c7","title":"优点：简单、直观、便于理解<br>计算某个顶点的度十分的方便<br>便于判断两个顶点v1和v2之间是否有边"},{"parent":"e6c1ff12cfee","children":[],"id":"f8da01b4aa6e","title":"缺点：对图进行增加或者删除顶点的操作很麻烦<br>存储效率低，尤其是稀疏图，顶点多边少，很浪费计算机资源<br>创建图的算法时间复杂度高：O(n^2)"}],"id":"e6c1ff12cfee","title":"优缺点："}],"collapsed":false,"id":"19310ee4e5bb","title":"1. 邻接矩阵表示法"},{"parent":"b31b8441f5c8","children":[{"parent":"106c81b69f64","children":[],"id":"24211d4363a4","title":"类似于树的孩子链表表示法<br>首先需要一个数组，数组的元素是顶点和指针域<br>指针域指向与顶点相连的边结点<br>在邻接表中每个顶点后面带的链表，就是与该顶点相连的边"},{"parent":"106c81b69f64","children":[],"id":"1b3dfe8aeef2","title":"在无向图中，邻接表的空间复杂度为O(n+2*e)<br>在有向图中，邻接表的空间复杂度为O(n+e)。其中表示表示有向图的出度的叫邻接表<br>表示有向图入度的叫逆邻接表。"},{"parent":"106c81b69f64","children":[{"parent":"d40efbfe3458","children":[],"id":"4a5fed2b0a5c","title":"优点：空间复杂度低，适合于稀疏图<br>便于图的增加和删除顶点<br>在无向图中便于查看每个顶点的度"},{"parent":"d40efbfe3458","children":[],"id":"ca76d5006761","title":"缺点：不便于查看两个顶点v1和v2之间是否有边<br>对于有向图，不便于统计每一个顶点的度。因为需要构造逆邻接表"}],"id":"d40efbfe3458","title":"优缺点："}],"id":"106c81b69f64","title":"2. 邻接表表示法"},{"parent":"b31b8441f5c8","children":[{"parent":"ae61220798ba","children":[],"id":"b7472181d834","title":"解决了有向图在邻接表表示时，顶点度的统计不便问题"}],"id":"ae61220798ba","title":"3. 十字链表表示法"},{"parent":"b31b8441f5c8","children":[{"parent":"17cef6f34ae8","children":[],"id":"81c6723cef8a","title":"解决了无向图在邻接表表示时，每一个边要被保存两次，会带来操作上的不便（例如删除边，要去找到重复的这两个边）"}],"id":"17cef6f34ae8","title":"4. 邻接多重表表示法"}],"collapsed":true,"id":"b31b8441f5c8","title":"2. 图的存储方式"},{"parent":"c7fb1158cc82","children":[{"parent":"ed301f598217","children":[{"parent":"895569353b15","children":[{"parent":"a6f5228eb967","children":[],"id":"f67a3fe8a4e1","title":"时间复杂度：O(n^2)"},{"parent":"a6f5228eb967","children":[],"id":"29605bc11f44","title":"空间复杂度O(n)"}],"id":"a6f5228eb967","title":"邻接矩阵"},{"parent":"895569353b15","children":[{"parent":"896d91f5c59a","children":[],"id":"efe2d2945671","title":"时间复杂度：O(n+e)"},{"parent":"896d91f5c59a","children":[],"id":"6f8265558fb7","title":"空间复杂度O(n)"}],"id":"896d91f5c59a","title":"邻接表"}],"id":"895569353b15","title":"1. 深度优先遍历算法"},{"parent":"ed301f598217","children":[{"parent":"ff8823e6e473","children":[{"parent":"c12fb842d36c","children":[],"id":"6360d4a810f3","title":"时间复杂度：O(n^2)"},{"parent":"c12fb842d36c","children":[],"id":"fc62fecdbcc8","title":"空间复杂度O(n)"}],"id":"c12fb842d36c","title":"邻接矩阵"},{"parent":"ff8823e6e473","children":[{"parent":"0347ab8405a0","children":[],"id":"9b07bf228b3a","title":"时间复杂度：O(n+e)"},{"parent":"0347ab8405a0","children":[],"id":"4dbb89d5135b","title":"空间复杂度O(n)"}],"id":"0347ab8405a0","title":"邻接表"}],"id":"ff8823e6e473","title":"2.广度优先遍历算法"}],"collapsed":true,"id":"ed301f598217","title":"3. 图的遍历方式"},{"parent":"c7fb1158cc82","children":[{"parent":"206e3a3605ee","children":[{"parent":"3cc4445b6c2f","children":[{"parent":"8d03341d6b02","children":[],"id":"3bb58b00a329","title":"算法时间复杂度O(n^2)"},{"parent":"8d03341d6b02","children":[],"id":"548a44484819","title":"适合稠密图"}],"id":"8d03341d6b02","title":"该算法就像是一条蛇一样，每一次都从&lt;已选顶点&gt;和&lt;未选顶点&gt;中选择权重最小的一条边，连接成新的图"}],"id":"3cc4445b6c2f","title":"1. prim算法"},{"parent":"206e3a3605ee","children":[{"parent":"f0fd31da68b6","children":[{"parent":"c5664e4a4e90","children":[],"id":"1ae34fdaff9f","title":"算法时间复杂度O(eloge)"},{"parent":"c5664e4a4e90","children":[],"id":"f7b1ddcdf6e8","title":"适合稀疏图"}],"id":"c5664e4a4e90","title":"该算法是把图的边按照权重大小排序，在保证不会连接成环的情况下，依次选择最小的边，当边数=n-1或者图已经连通了，这个算法就可以终止了"}],"id":"f0fd31da68b6","title":"2. Kruskal算法"}],"collapsed":true,"id":"206e3a3605ee","title":"4. 最小生成树"},{"parent":"c7fb1158cc82","children":[{"parent":"b236d9bf2b76","children":[],"id":"75f973efcf9f","title":"地图线路规划问题，哪一条路时间最短最快"},{"parent":"b236d9bf2b76","children":[],"id":"a4de9fc2d565","title":"1. dijkstra算法"}],"collapsed":true,"id":"b236d9bf2b76","title":"5. 最短路径"},{"parent":"c7fb1158cc82","children":[],"id":"7a7f9a19a170","title":"6. 拓扑排序"},{"parent":"c7fb1158cc82","children":[],"id":"1bae63044687","title":"7. 关键路径"}],"collapsed":true,"id":"c7fb1158cc82","title":"5. 图"}],"collapsed":false,"id":"0e704fdaa4e4","title":"2. 数据结构"},{"parent":"root","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"e937a2f32964","children":[{"parent":"c7d7d875874c","children":[{"parent":"0ee218edf912","children":[{"parent":"d363e159509c","children":[],"id":"2059982091d6","title":"散列表，也叫查找表<br>这是一种新的数据结构，也是数据元素的有限集合，不过各元素之间的关系比较松散，没有太多严格的限制"}],"id":"d363e159509c","title":"1. 查找算法是在什么数据结构上作查找？"},{"parent":"0ee218edf912","children":[{"parent":"e1f5f1aa2525","children":[],"id":"428b060c363c","title":"也就是我们给定一个值，在查找表上找到对应的数据元素内容或者记录"}],"id":"e1f5f1aa2525","title":"2. 什么是查找"},{"parent":"0ee218edf912","children":[{"parent":"3de8c470de2b","children":[{"parent":"2e04a8f03f19","children":[],"id":"cadf0f238d5d","title":"1. 主关键字：通过关键字只能唯一的标识一个数据元素"},{"parent":"2e04a8f03f19","children":[],"id":"981940efa852","title":"2. 次关键字：通过关键字标识的数据元素不止一个"}],"id":"2e04a8f03f19","title":"1. 关键字：用于标识一个数据元素某个数据项的值"},{"parent":"3de8c470de2b","children":[],"id":"3d223ac408c0","title":"2. ASL（平均查找长度））：关键字的平均比较次数"},{"parent":"3de8c470de2b","children":[{"parent":"07d9212d62be","children":[],"id":"0048dbdf799d","title":"1. 静态查找表：只对查找表作查询和遍历操作，不会改变查找表，这时使用静态查找表（const）"},{"parent":"07d9212d62be","children":[],"id":"3b2db853e803","title":"2. 动态查找表：对查找表要进行增删改的操作，会改变查找表"}],"id":"07d9212d62be","title":"3. 查找表的分类"}],"id":"3de8c470de2b","title":"3. 基础概念"}],"id":"0ee218edf912","title":"1. 基础知识"},{"parent":"c7d7d875874c","children":[{"parent":"0b1ebc9ada10","children":[{"parent":"167aacd78785","children":[{"parent":"fcb861d66d0e","children":[],"id":"f3d382a3cd14","title":"1. 查找对象：顺序表（链表也是一个道理）"},{"parent":"fcb861d66d0e","children":[{"parent":"ff4f19be525a","children":[],"id":"e7d1152df00e","title":"1. 优点：算法简单，对数据的逻辑结构没有太多要求，对大多数数据结构都适用"},{"parent":"ff4f19be525a","children":[],"id":"e839439f9682","title":"2. 缺点：ASL过长(n+1)/2，时间效率低"}],"id":"ff4f19be525a","title":"2. 优缺点"}],"id":"fcb861d66d0e","title":"1. 顺序查找法"},{"parent":"167aacd78785","children":[{"parent":"b4b5f8e61dd8","children":[],"id":"5202d95e532e","title":"1. 查找对象：顺序结构"},{"parent":"b4b5f8e61dd8","children":[{"parent":"f8219755f590","children":[],"id":"16838bc5620e","title":"1. 优点：算法简单，时间效率高O(log2(n))，ASL低log2(n+1)-1(n&gt;50)"},{"parent":"f8219755f590","children":[],"id":"39cfa1478f32","title":"2. 缺点：数据结构必须得是顺序结构；表中的元素事前要进行排序"}],"id":"f8219755f590","title":"2. 优缺点"},{"parent":"b4b5f8e61dd8","children":[{"parent":"a9c75450300d","children":[],"id":"3d1634b8af24","title":"用一颗二叉树表示顺序表中每个元素的查找的程序执行次数"}],"id":"a9c75450300d","title":"判定树"}],"id":"b4b5f8e61dd8","title":"2. 二分（折半查找）"},{"parent":"167aacd78785","children":[{"parent":"eec10072085c","children":[],"id":"f960f6f33d10","title":"分块查找的思想类似于小时候使用的新华字典<br>先对关键字进行分块的查找，确定关键在哪一个大致的范围内<br>再从那一个小范围内继续查找<br>第一步确定分块采用的是二分查找，第二步在分块内查找用的是顺序查找"},{"parent":"eec10072085c","children":[{"parent":"15c044a008ba","children":[],"id":"4c5f461b6f98","title":"1. 优点：查找效率还是蛮高的，至少是比顺序查找要高的<br>由于数据本身可以采用链表存储，因为插入和删除比较方便<br>"},{"parent":"15c044a008ba","children":[],"id":"fd55a7856561","title":"2. 缺点：要单独建一个索引的表，并且要对索引表进行排序<br>"}],"id":"15c044a008ba","title":"优缺点："}],"id":"eec10072085c","title":"3. 分块查找算法"}],"id":"167aacd78785","title":"1. 线性表的查找算法"},{"parent":"0b1ebc9ada10","children":[{"parent":"03eefbe17c30","children":[{"parent":"4d8bdaaf8961","children":[{"parent":"dc07e052e3fe","children":[],"id":"3e9da0a1937f","title":"二叉排序树是指：<br>二叉树的左子树的所有元素的值都小于根结点，<br>右子树的元素大于等于根结点<br>左子树和右子树又是一颗二叉树"},{"parent":"dc07e052e3fe","children":[],"id":"7dd582dd9835","title":"对二叉排序树进行中序遍历，便能得到一个按照关键字排序的递增序列"}],"id":"dc07e052e3fe","title":"1. 什么是二叉排序树"}],"id":"4d8bdaaf8961","title":"1. 补充点基础知识"},{"parent":"03eefbe17c30","children":[{"parent":"5c5fb4ec3dd9","children":[],"id":"43ce09f91f47","title":"1. 二叉搜索树本质上还是一个二叉树的遍历，遍历方式是DLR先序遍历"},{"parent":"5c5fb4ec3dd9","children":[],"id":"cb8cf8d6584b","title":"时间复杂度：时间复杂度与二叉树的形态有关？<br>如果二叉搜索树的形态是判定树，即树的深度为log2n+1，那么二叉搜索树的查找时间复杂度O(log2n)<br>但是，如果二叉搜索树根结点的元素是最小的元素，那么二叉树会退化成一个全是右孩子的树，其查找变成了顺序查找O(n)<br>因此，如果二叉排序树形态不好，就会影响我们查找的效率，因此我们要将二叉排序树转化成平衡二叉树"}],"id":"5c5fb4ec3dd9","title":"2. 基于二叉搜索树的查找算法"},{"parent":"03eefbe17c30","children":[{"parent":"68029dc9a199","children":[{"parent":"7313447dccb2","children":[],"id":"aca4c9df72a5","title":"一颗非空具有如下特征的二叉排序树：<br>(1 )左子树和右子树的深度之差的绝对值不超过1;<br>(2)左子树和右子树也是平衡二叉树。<br>就可以称作平衡二叉树"}],"id":"7313447dccb2","title":"1. 平衡二叉树的定义"},{"parent":"68029dc9a199","children":[{"parent":"e43185920e94","children":[],"id":"9b1387dbcbb1","title":"L_L型"},{"parent":"e43185920e94","children":[],"id":"6d1d275674fd","title":"L_R型"},{"parent":"e43185920e94","children":[],"id":"944191f47cd9","title":"R_L型"},{"parent":"e43185920e94","children":[],"id":"998f96fe60b6","title":"R_R型"},{"parent":"e43185920e94","children":[],"id":"dff70f9fb78b","title":"在生成二叉排序树的时候，如果存在某个结点的平衡因子绝对值大于1，那么就需要对该结点的树进行调整，<br>如果有多个结点都出现该情况，我们只需要去调整最小的失衡二叉树即可将整棵树调整好"}],"id":"e43185920e94","title":"2. 4种非平衡二叉树的调整"}],"id":"68029dc9a199","title":"3. AVL平衡二叉树"}],"collapsed":false,"id":"03eefbe17c30","title":"2. 二叉树的查找算法"},{"parent":"0b1ebc9ada10","children":[{"parent":"7cbd0431ebbd","children":[{"parent":"132a818a8521","children":[],"id":"3bc61bb49450","title":"1.散列表是一种存储结构，其元素的存储位置是通过一个散列函数（Hash函数）将元素的关键值与存储位置形成一个映射"},{"parent":"132a818a8521","children":[{"parent":"77d761c8daf6","children":[],"id":"81680f185fbd","title":"1. 除留余数法：用元素的关键值除以一个数m，m通常小于等于要存放的数的元素个数，常记作：H(k)=key mod m"},{"parent":"77d761c8daf6","children":[],"id":"645202590e76","title":"2. 直接定址法：用元素关键值除以一个系数得到除数，常记作 H(k)=key/a+b"},{"parent":"77d761c8daf6","children":[],"id":"096a5714d8b9","title":"3. 数字分析法"},{"parent":"77d761c8daf6","children":[],"id":"c4e39fde8e26","title":"4. 平方取中法"},{"parent":"77d761c8daf6","children":[],"id":"4a4d92f82958","title":"5. 折叠法"}],"id":"77d761c8daf6","title":"2. 常用的Hash函数"}],"id":"132a818a8521","title":"1. 什么是散列表"},{"parent":"7cbd0431ebbd","children":[{"parent":"5a5ef4d18a16","children":[],"id":"13b5354152da","title":"1. 为什么会产生冲突？元素关键字通过哈希函数生成的存储地址有可能会发生重叠，同一位置有多个元素要存放，这便是冲突，如何解决冲突？"},{"parent":"5a5ef4d18a16","children":[{"parent":"b1554a0ffeab","children":[{"parent":"5053d2006f94","children":[],"id":"b995eb8b3064","title":"1. 线性探测法：如果存放位置有冲突，探索该位置的下一个地址，以此类推"},{"parent":"5053d2006f94","children":[],"id":"578084bf9dcb","title":"2. 二次探测法：以1^2, -1^2, 2^2, -2^2依次往下探测"},{"parent":"5053d2006f94","children":[],"id":"658f77e6bb78","title":"3. 伪随机探测法"}],"id":"5053d2006f94","title":"1. 开放地址法<br>开放地址法的基本思想是：把记录都存储在散列表数组中，当某一记录关键字 key的初始散<br>列地址H0=H(key)发生冲突时，以H0为基础 ，采取合适方法计算得到另一个地址H1,, 如果H1仍<br>然发生冲突，以H1为基础再求下一个地址H2，若H2仍然冲突，再求得H3。依次类推，直至Hk<br>不发生冲突为止，则Hk为该记录在表中的散列地址。<br>"},{"parent":"b1554a0ffeab","children":[],"id":"37f139d3fb2e","title":"2. 链地址法<br>链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链<br>表。有 m 个散列地址就有 m 个单链表，同时用数组 HT[O…m-1]存放各个链表的头指针，凡是<br>散列地址为 l 的记录都以结点方式插入到以 HT[i]为头结点的单链表中。<br>"}],"id":"b1554a0ffeab","title":"2. 解决冲突的方式："}],"id":"5a5ef4d18a16","title":"2. 散列表存储时的冲突问题"},{"parent":"7cbd0431ebbd","children":[{"parent":"7303e5897599","children":[{"parent":"44718da6623b","children":[{"parent":"1a1dfea409e2","children":[],"id":"52f0bf7785f6","title":"1. 散列函数（Hash函数）"},{"parent":"1a1dfea409e2","children":[{"parent":"8d8912682411","children":[],"id":"b275cf0223ba","title":"链地址解决冲突要比开放地址法好"}],"id":"8d8912682411","title":"2. 冲突解决方法"},{"parent":"1a1dfea409e2","children":[],"id":"9d362ed21e86","title":"3.装填因子=表中填入元素的个数/散列表的长度。直观的来说，装填因子越小，一般发生冲突的可能性也就越小"}],"id":"1a1dfea409e2","title":"散列表查找性能分析"}],"id":"44718da6623b","title":"散列表的查找其实就是散列表的生成过程"}],"id":"7303e5897599","title":"3. 散列表的查找"}],"id":"7cbd0431ebbd","title":"3. 基于散列表的查找算法"}],"id":"0b1ebc9ada10","title":"2. 查找算法"}],"collapsed":true,"id":"c7d7d875874c","title":"1. 查找"},{"parent":"e937a2f32964","children":[{"parent":"1bf98d715f00","children":[{"parent":"40be85dd6774","children":[{"parent":"75a9c6823556","children":[],"id":"21d95130d540","title":"1. 将第一个还没有排序的元素与它之前已经排好的那部分序列，从有序序列的后面开始，依次比较，直到找到第一个小于该元素的元素，在这个小元素的后面插入"},{"parent":"75a9c6823556","children":[],"id":"56aee9028e8a","title":"2. 时间复杂度：O(n^2)，空间复杂度：O(1)"}],"id":"75a9c6823556","title":"1. 用顺序查找法确定插入位置：直接插入排序"},{"parent":"40be85dd6774","children":[{"parent":"6281a393b31e","children":[],"id":"792147ff3007","title":"1. 将第一个还未排序的元素，在它之前的有序序列中，进行二分查找，二分查找会不断的缩小比较区间，直至缩小到只有一个元素的区间，该元素的位置+1就是未排元素的插入位置"},{"parent":"6281a393b31e","children":[],"id":"fab290c879a5","title":"2. 时间复杂度：O(n^2)，空间复杂度：O(1)"},{"parent":"6281a393b31e","children":[],"id":"627aa252aa2f","title":"3. 二分插入要比直接插入在平均时间效率上好一点。<br>只能比较平均时间效率，因为直接插入排序最好情况是O(n)，最好的ASL=1最差情况是O(n^2)，最坏的ASL=i-1<br>但是二分插入排序的ASL都是||log2i||+1，所以只能比较平均时间效率"}],"id":"6281a393b31e","title":"2. 用二分查找法确定插入位置：二分插入排序"},{"parent":"40be85dd6774","children":[{"parent":"2ad04e4016f8","children":[],"id":"0e0b7d74740b","title":"1. 设置一个增量序列，让待排元素按照一个特定的值分组进行排序，不断减小分组的间隔，最后就能得到一个排好序的序列"},{"parent":"2ad04e4016f8","children":[],"id":"4c231e9d5989","title":"2. 时间复杂度：没有严格的数学证明，但是猜想为O(n^1.25)~1.6O(n^1.25)之间<br>"},{"parent":"2ad04e4016f8","children":[],"id":"ea28b113c9cb","title":"3. 希尔排序是一种不稳定的排序，直接插入排序和二分插入排序都是稳定的排序"}],"id":"2ad04e4016f8","title":"3. 缩小增量，多遍插入排序：希尔排序<br>"}],"id":"40be85dd6774","title":"1. 插入排序"},{"parent":"1bf98d715f00","children":[{"parent":"da9a42120225","children":[{"parent":"4bbc10c79456","children":[],"id":"fe56f5fb560a","title":"冒泡排序不多说了，学C语言的时候就已经学过了"},{"parent":"4bbc10c79456","children":[],"id":"9f01187b3565","title":"时间复杂度：O(n^2)，空间复杂度：O(1)"}],"id":"4bbc10c79456","title":"1. 冒泡排序"},{"parent":"da9a42120225","children":[{"parent":"412af67ca99e","children":[],"id":"854a4eb4aa6a","title":"原理讲起来有些复杂，不过基本思想类似于二叉树的遍历，都是要使用递归函数来解决问题。简单来说，是在无序序列中找一个中枢点，将小于中枢点的放在中枢点左边，大于中枢点的放在中枢点右边，再对中枢点左边的重复刚刚那个步骤，再对右边的重复那个步骤。。。一直持续下去，直到无序序列长度为1，"},{"parent":"412af67ca99e","children":[],"id":"e83f0aa46edb","title":"时间复杂度：O(nlogn)，空间复杂度O(nlogn)"},{"parent":"412af67ca99e","children":[],"id":"ab948c7711e8","title":"快速排序不是一种稳定的排序方式。其次，快速排序不适用于有一定顺序的序列，否则快排将会退化成冒泡排序，因此，序列越乱，使用快速排序的效果越好"}],"id":"412af67ca99e","title":"2. 快速排序"}],"id":"da9a42120225","title":"2. 交换排序"},{"parent":"1bf98d715f00","children":[{"parent":"2fb128d3b8e5","children":[{"parent":"91bc10e92543","children":[],"id":"583e81cb9b4c","title":"算法思路很简单，每次从序列中拿出一个最小值，依次往复，就能排好序"},{"parent":"91bc10e92543","children":[],"id":"c1e05f899ba9","title":"时间复杂度：O(n^2)，空间复杂度：O(1)"},{"parent":"91bc10e92543","children":[],"id":"974be2128cb0","title":"直接选择排序不是一个稳定的算法"}],"id":"91bc10e92543","title":"1. 直接选择排序"},{"parent":"2fb128d3b8e5","children":[{"parent":"af2b2c5b6503","children":[{"parent":"94160a69ec7b","children":[],"id":"733bce872311","title":"堆分为大根堆和小根堆<br>大根堆是指，对于一个完全二叉树，其每一个结点的值大于结点孩子的值<br>小根堆和大根堆的比较相反，结点小于孩子的值"}],"id":"94160a69ec7b","title":"1. 什么是堆"},{"parent":"af2b2c5b6503","children":[{"parent":"185023f08c25","children":[],"id":"c27ab3730b0b","title":"首先，我们是用一个顺序存储结构保存这个完全二叉树，完全二叉树的双亲和孩子是通过下标位置联系再一起的（双亲i，左孩子2i，右孩子2i+1）<br>先把无序序列依次保存在顺序存储结构中<br>然后从完全二叉树的最后一个非叶子结点开始，比较结点的值和孩子的值，让结点值交换成最小的值，每次交换要一直延续到叶子结点<br>重复上面的过程，一直到根结点"}],"id":"185023f08c25","title":"2. 如何由无序序列创建一个堆"},{"parent":"af2b2c5b6503","children":[{"parent":"189c446d6be4","children":[],"id":"e7e03b03ba61","title":"先输出完全二叉树的顶点的值，然后完全二叉树变成了两个树，再将这两个树重新建立成新的堆的完全二叉树，在输出顶点，再建二叉树，循环往复直到最后一个结点"}],"id":"189c446d6be4","title":"3. 有了堆之后，如何输出有序序列"}],"id":"af2b2c5b6503","title":"2. 堆排序"}],"id":"2fb128d3b8e5","title":"3. 选择排序"},{"parent":"1bf98d715f00","children":[{"parent":"c62cef98b10c","children":[],"id":"46c2f6147572","title":"自底向上的归并排序：归并排序的思想：用单个元素的序列开始，两两一对排序形成新序列，再把两个元素的序列两两组成一对，再排序，形成四个有序元素的序列，一直这样循环往复，逐渐得到一个完整的有序序列"},{"parent":"c62cef98b10c","children":[],"id":"c0c7128b4257","title":"自顶而下的归并排序：使用递归思想，分而治之，将大数组的排序分成若干个小数组的排序，再把这些小数组重新合并成一个打的大的有序数组"},{"parent":"c62cef98b10c","children":[],"id":"a2ea6cd95195","title":"自顶而下是把整打撒成零、自底向上是把零归纳成整。两者方向相反，但是还是有共同之处。掌握了一个就能反推另一个。"}],"id":"c62cef98b10c","title":"4. 归并排序"},{"parent":"1bf98d715f00","children":[{"parent":"d3613c3fd480","children":[],"id":"09fb49713b8d","title":"子主题"}],"id":"d3613c3fd480","title":"5. 基数排序（桶排序）"},{"image":{"w":478,"h":273,"url":"http://cdn.processon.com/60274d15e401fd48f2a79daa?e=1613191973&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:PHcQOIgT4re39A1985hItecAKxY="},"parent":"1bf98d715f00","children":[],"id":"ce26c414a5e7","title":""}],"collapsed":true,"id":"1bf98d715f00","title":"2. 排序"}],"collapsed":false,"id":"e937a2f32964","title":"3. 算法"}],"root":true,"theme":"caihong","id":"root","title":"数据结构与算法","lines":{"2ae5da826739":{"realEnd":{"x":10873.406921386719,"y":12078.583984375},"start":{"x":"0.4","index":1,"y":"0.0"},"angle":48.057993389046906,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"1f61d31b21ed","end":{"x":"0.5","index":3,"y":"1.0"},"to":"4fe76d3cbb22","id":"2ae5da826739","realStart":{"x":10947.511108398438,"y":12161.052734375},"points":[]},"4ec6f295cc9d":{"realEnd":{"x":10899.306921386718,"y":12042.094421386719},"start":{"x":"0.4","index":1,"y":"0.0"},"angle":59.693091342763246,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"78f081e740ce","end":{"x":"0.6","index":3,"y":"1.0"},"to":"2f35058bebf0","id":"4ec6f295cc9d","realStart":{"x":10947.511108398438,"y":12124.563171386719},"points":[]},"33d571445ab3":{"realEnd":{"x":10833.90658569336,"y":10548.233343505859},"start":{"x":"0.0","index":4,"y":"1.0"},"angle":351.4644636638073,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"cb8cf8d6584b","end":{"x":"1.0","index":2,"y":"0.2"},"to":"68029dc9a199","id":"33d571445ab3","realStart":{"x":10936.5107421875,"y":10532.833984375},"points":[]}},"structure":"mind_right"}},"meta":{"exportTime":"2021-11-30 17:23:06","member":"5f87ef3b07912906db283f2b","diagramInfo":{"creator":"5f87ef3b07912906db283f2b","created":"2021-01-26 15:48:30","modified":"2021-08-06 10:18:23","title":"数据结构与算法私有版","category":"mind_free"},"id":"600fc94ee401fd0a1f8c3d5a","type":"ProcessOn Schema File","version":"1.0"}}