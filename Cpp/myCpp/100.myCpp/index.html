
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="smileatl 个人知识库，Welcome！在广袤的空间和无限的时间中，能与你共享同一颗行星与同一段时光是我的荣幸。">
      
      
        <meta name="author" content="smileatl">
      
      
        <link rel="canonical" href="https://smileatl.github.io/smileatlRepo/Cpp/myCpp/100.myCpp/">
      
      
      
      
      <link rel="icon" href="../../../assets/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.7">
    
    
      
        <title>myCpp - smileatlRepo</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../css/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#mycpp" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="smileatlRepo" class="md-header__button md-logo" aria-label="smileatlRepo" data-md-component="logo">
      
  <img src="../../../assets/website_icon.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            smileatlRepo
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              myCpp
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/smileatl/smileatlRepo" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    smileatl/smileatlRepo
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../start_learning/" class="md-tabs__link">
          
  
  Get started

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../MyWork/smileatlRepo/10.%E5%88%9D%E8%AF%86smileatlRepo/" class="md-tabs__link">
          
  
  项目

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../C/myC/10.myC/" class="md-tabs__link">
          
  
  工作

        </a>
      </li>
    
  

    
  

    
  

    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E5%AD%A6%E4%B9%A0/Postgraduate/00.publications/" class="md-tabs__link">
          
  
  学习

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E6%94%B6%E8%97%8F/05.%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%97%8F%E5%A4%B9/" class="md-tabs__link">
          
  
  收藏

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E5%88%9D%E8%AF%86%E7%94%9F%E6%B4%BB/" class="md-tabs__link">
          
  
  Blog

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../../message/" class="md-tabs__link">
        
  
    
  
  留言

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="smileatlRepo" class="md-nav__button md-logo" aria-label="smileatlRepo" data-md-component="logo">
      
  <img src="../../../assets/website_icon.png" alt="logo">

    </a>
    smileatlRepo
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/smileatl/smileatlRepo" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    smileatl/smileatlRepo
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Get started
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Get started
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../start_learning/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    网站指引
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../about/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    关于网站
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    项目
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            项目
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    smileatlRepo
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            smileatlRepo
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatlRepo/10.%E5%88%9D%E8%AF%86smileatlRepo/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    初识smileatlRepo
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Interview
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            Interview
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/10.cpp" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cpp
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/15.cpp%E5%85%B3%E9%94%AE%E5%AD%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cpp关键字
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/20.cpp_stl/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cpp_stl
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/30.cpp%E6%96%B0%E7%89%B9%E6%80%A7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cpp新特性
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/40.cpp%E5%85%B6%E4%BB%96/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cpp其他
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/45.gcc_g%2B%2B_gdb/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gcc_g++_gdb
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/50.Linux/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/60.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    操作系统
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/70.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    操作系统-网络系统
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/80.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    操作系统-内存管理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/85.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E5%A4%9A%E8%BF%9B%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    操作系统-多线程_多进程_线程池
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/90.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    计算机网络
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/100.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据结构与算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/110.MySQL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    MySQL
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/115.Redis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Redis
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/130.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    设计模式
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/140.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    系统设计
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/150.%E5%B7%A5%E5%85%B7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    工具
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/190.%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    技术支持
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../MyWork/smileatl_interview/200.HR%E9%9D%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HR面相关问题
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    工作
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            工作
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    编程语言
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            编程语言
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1_1" id="__nav_4_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    C
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_1">
            <span class="md-nav__icon md-icon"></span>
            C
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_1_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1_1_1" id="__nav_4_1_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    myC
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_1_1">
            <span class="md-nav__icon md-icon"></span>
            myC
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../C/myC/10.myC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    myC
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../C/myC/20.gcc/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gcc
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../C/myC/50.%E5%AE%89%E8%A3%85/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    安装
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_1_2" >
        
          
          <label class="md-nav__link" for="__nav_4_1_1_2" id="__nav_4_1_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Book
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_1_2">
            <span class="md-nav__icon md-icon"></span>
            Book
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../C/Book/C%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%89%96/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C语言深度解剖
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_1_3" >
        
          
          <label class="md-nav__link" for="__nav_4_1_1_3" id="__nav_4_1_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Lesson
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_1_3">
            <span class="md-nav__icon md-icon"></span>
            Lesson
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../C/Lesson/%E7%BF%81%E6%81%BAC%E8%AF%AD%E8%A8%80/C_wengkai/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    翁恺C语言
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_2" >
        
          
          <label class="md-nav__link" for="__nav_4_1_2" id="__nav_4_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Cpp
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_2">
            <span class="md-nav__icon md-icon"></span>
            Cpp
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_2_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1_2_1" id="__nav_4_1_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    myCpp
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_2_1">
            <span class="md-nav__icon md-icon"></span>
            myCpp
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../10.myCpp.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    myCpp
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../20.STL.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    STL
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_2_2" >
        
          
          <label class="md-nav__link" for="__nav_4_1_2_2" id="__nav_4_1_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Lesson
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_2_2">
            <span class="md-nav__icon md-icon"></span>
            Lesson
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../02.Cpp基础入门.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Cpp基础入门
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../03.Cpp核心编程.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Cpp核心编程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../04.Cpp提高编程.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Cpp提高编程
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_3" >
        
          
          <label class="md-nav__link" for="__nav_4_1_3" id="__nav_4_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Go
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_3">
            <span class="md-nav__icon md-icon"></span>
            Go
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_3_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1_3_1" id="__nav_4_1_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    myGo
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_3_1">
            <span class="md-nav__icon md-icon"></span>
            myGo
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Go/1.%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    初识Go语言
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_4" >
        
          
          <label class="md-nav__link" for="__nav_4_1_4" id="__nav_4_1_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Python
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_4">
            <span class="md-nav__icon md-icon"></span>
            Python
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1_4_1" id="__nav_4_1_4_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    myPython
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_1_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_4_1">
            <span class="md-nav__icon md-icon"></span>
            myPython
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Python/myPython/Python基础.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python基础
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_5" >
        
          
          <label class="md-nav__link" for="__nav_4_1_5" id="__nav_4_1_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Script_Language
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_5">
            <span class="md-nav__icon md-icon"></span>
            Script_Language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Script_Language/10.shell%E8%84%9A%E6%9C%AC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    shell脚本
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Script_Language/20.slurm%E5%92%8Csbatch/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    slurm和sbatch
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_6" >
        
          
          <label class="md-nav__link" for="__nav_4_1_6" id="__nav_4_1_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    YML
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_6">
            <span class="md-nav__icon md-icon"></span>
            YML
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../YML/yml/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    YML
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算机知识
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2">
            <span class="md-nav__icon md-icon"></span>
            计算机知识
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_1" >
        
          
          <label class="md-nav__link" for="__nav_4_2_1" id="__nav_4_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Linux
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_1">
            <span class="md-nav__icon md-icon"></span>
            Linux
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/Linux/linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    linux系统基础
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2_2" id="__nav_4_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    操作系统
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_2">
            <span class="md-nav__icon md-icon"></span>
            操作系统
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux基础编程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux网络编程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    进程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    线程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E4%BF%A1%E5%8F%B7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    信号
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_3" >
        
          
          <label class="md-nav__link" for="__nav_4_2_3" id="__nav_4_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算机网络
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_3">
            <span class="md-nav__icon md-icon"></span>
            计算机网络
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_3_1" >
        
          
          <label class="md-nav__link" for="__nav_4_2_3_1" id="__nav_4_2_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    ICT技术
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_2_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_3_1">
            <span class="md-nav__icon md-icon"></span>
            ICT技术
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICT%E6%8A%80%E6%9C%AF/%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    通信基础
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../计算机知识/计算机网络/ICT技术/交换机基础.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    交换机基础
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICT%E6%8A%80%E6%9C%AF/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    路由协议
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICT%E6%8A%80%E6%9C%AF/NAT/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NAT
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICT%E6%8A%80%E6%9C%AF/ACL/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ACL
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICT%E6%8A%80%E6%9C%AF/IPV6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    IPV6
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_3_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2_3_2" id="__nav_4_2_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    NetworkProgramming
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_2_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_3_2">
            <span class="md-nav__icon md-icon"></span>
            NetworkProgramming
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NetworkProgramming/%E5%8D%8F%E8%AE%AE/http/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    http
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NetworkProgramming/%E5%8D%8F%E8%AE%AE/http%E8%A1%A5%E5%85%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    http补充问题
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NetworkProgramming/%E5%8D%8F%E8%AE%AE/websocket/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    websocket
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NetworkProgramming/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    网络编程常见概念
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_4" >
        
          
          <label class="md-nav__link" for="__nav_4_2_4" id="__nav_4_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数据结构与算法
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_4">
            <span class="md-nav__icon md-icon"></span>
            数据结构与算法
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../计算机知识/数据结构与算法/数据结构与算法基础.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据结构与算法基础
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2_4_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2_4_2" id="__nav_4_2_4_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    青大王卓
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_4_2_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2_4_2">
            <span class="md-nav__icon md-icon"></span>
            青大王卓
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%92%E5%A4%A7%E7%8E%8B%E5%8D%93/10.%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    线性表
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%92%E5%A4%A7%E7%8E%8B%E5%8D%93/20.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    栈和队列
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%92%E5%A4%A7%E7%8E%8B%E5%8D%93/30.%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二叉树
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%92%E5%A4%A7%E7%8E%8B%E5%8D%93/40.%E5%9B%BE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    图
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%92%E5%A4%A7%E7%8E%8B%E5%8D%93/50.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    查找算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%92%E5%A4%A7%E7%8E%8B%E5%8D%93/60.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    排序算法
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3" >
        
          
          <label class="md-nav__link" for="__nav_4_3" id="__nav_4_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    工具
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3">
            <span class="md-nav__icon md-icon"></span>
            工具
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_1" >
        
          
          <label class="md-nav__link" for="__nav_4_3_1" id="__nav_4_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Git
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_1">
            <span class="md-nav__icon md-icon"></span>
            Git
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Git/01.Git%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Git使用
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Git/05.Git%E8%A1%A5%E5%85%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Git补充问题
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Git/10.tortoiseGit/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    tortoiseGt
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_2" >
        
          
          <label class="md-nav__link" for="__nav_4_3_2" id="__nav_4_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Markdown
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_2">
            <span class="md-nav__icon md-icon"></span>
            Markdown
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Markdown/markdown/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    markdown
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Markdown/markdown常见问题.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    markdown常见问题
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_3" >
        
          
          <label class="md-nav__link" for="__nav_4_3_3" id="__nav_4_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Obsidian
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_3">
            <span class="md-nav__icon md-icon"></span>
            Obsidian
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Obsidian/obsidian/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    obsidian
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_4" >
        
          
          <label class="md-nav__link" for="__nav_4_3_4" id="__nav_4_3_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    SSH
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_4">
            <span class="md-nav__icon md-icon"></span>
            SSH
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/SSH/SSH/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    SSH
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_5" >
        
          
          <label class="md-nav__link" for="__nav_4_3_5" id="__nav_4_3_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Vim
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_5">
            <span class="md-nav__icon md-icon"></span>
            Vim
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Vim/vim/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vim
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Vim/vim_%E9%BB%91%E9%A9%AC%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    vim_黑马
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_6" >
        
          
          <label class="md-nav__link" for="__nav_4_3_6" id="__nav_4_3_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    VisioStudio
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_6">
            <span class="md-nav__icon md-icon"></span>
            VisioStudio
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/VisioStudio/VisioStudio.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    VisioStudio
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_7" >
        
          
          <label class="md-nav__link" for="__nav_4_3_7" id="__nav_4_3_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    VMware
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_7">
            <span class="md-nav__icon md-icon"></span>
            VMware
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/VMware/VMware/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    VMware
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3_8" >
        
          
          <label class="md-nav__link" for="__nav_4_3_8" id="__nav_4_3_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Vscode
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_3_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3_8">
            <span class="md-nav__icon md-icon"></span>
            Vscode
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Vscode/Vscode/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Vscode
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4" >
        
          
          <label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    其他
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_4">
            <span class="md-nav__icon md-icon"></span>
            其他
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_4_1" id="__nav_4_4_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    刷题
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_4_1">
            <span class="md-nav__icon md-icon"></span>
            刷题
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/02.Leetcode-%E6%95%B0%E7%BB%84/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数组
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/04.Leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    字符串
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/06.Leetcode-%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    链表
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/08.Leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    哈希表
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/10.Leetcode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    栈与队列
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../刷题/12.Leetcode-树.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    树
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/14.Leetcode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    贪心算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/15.Leetcode-%E9%80%92%E5%BD%92/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    递归
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/16.Leetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    回溯算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/18.Leetcode-%E5%88%86%E6%B2%BB%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    分治法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/20.Leetcode-%E6%90%9C%E7%B4%A2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    搜索
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/22.Leetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    动态规划
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/24.Leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    二分查找
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/26.Leetcode-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    排序算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/28.Leetcode-%E5%8F%8C%E6%8C%87%E9%92%88/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    双指针
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/30.Leetcode-%E6%95%B0%E5%AD%A6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数学
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%88%B7%E9%A2%98/32.Leetcode-%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    其他算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../刷题/50.Leetcode-剑指offer.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    剑指offer
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../刷题/60.Leetcode-ACM模式输入输出.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ACM模式输入输出
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../刷题/70.Leetcode-排序算法详解.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    排序算法详解
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../刷题/80.Leetcode-面试高频题-自己输入输出.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    面试高频题-自己输入输出
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../刷题/150.Leetcode-复刷还是没记住的题.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    复刷还是没记住的题
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    学习
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            学习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1" >
        
          
          <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Postgraduate
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1">
            <span class="md-nav__icon md-icon"></span>
            Postgraduate
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%AD%A6%E4%B9%A0/Postgraduate/00.publications/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    publications
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%AD%A6%E4%B9%A0/Postgraduate/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    机器学习知识点
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%AD%A6%E4%B9%A0/Postgraduate/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python深度学习
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    阅读
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            阅读
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E5%AD%A6%E4%B9%A0/%E9%98%85%E8%AF%BB/%E4%B9%A6%E6%91%98/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    个人摘抄
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    收藏
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            收藏
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%94%B6%E8%97%8F/05.%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%97%8F%E5%A4%B9/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    个人收藏夹
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E6%94%B6%E8%97%8F/10.%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    资源下载
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blog
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_1" >
        
          
          <label class="md-nav__link" for="__nav_7_1" id="__nav_7_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    生活随笔
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_1">
            <span class="md-nav__icon md-icon"></span>
            生活随笔
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E5%88%9D%E8%AF%86%E7%94%9F%E6%B4%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    初识生活
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2" >
        
          
          <label class="md-nav__link" for="__nav_7_2" id="__nav_7_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    科技随笔
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_2">
            <span class="md-nav__icon md-icon"></span>
            科技随笔
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%9A%8F%E7%AC%94/%E7%A7%91%E6%8A%80%E9%9A%8F%E7%AC%94/%E5%88%9D%E8%AF%86%E7%A7%91%E6%8A%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    初识科技
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../message/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    留言
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      自己的知识点
    </span>
  </a>
  
    <nav class="md-nav" aria-label="自己的知识点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      引用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#new-delete" class="md-nav__link">
    <span class="md-ellipsis">
      new , delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      指针
    </span>
  </a>
  
    <nav class="md-nav" aria-label="指针">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      指针与常量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      指针函数与函数指针
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      指向指针的引用
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      字符串
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      关键字
    </span>
  </a>
  
    <nav class="md-nav" aria-label="关键字">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#auto" class="md-nav__link">
    <span class="md-ellipsis">
      auto
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constexpr" class="md-nav__link">
    <span class="md-ellipsis">
      constexpr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explict" class="md-nav__link">
    <span class="md-ellipsis">
      explict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extern" class="md-nav__link">
    <span class="md-ellipsis">
      extern
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#final" class="md-nav__link">
    <span class="md-ellipsis">
      final
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#friend" class="md-nav__link">
    <span class="md-ellipsis">
      friend
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inline" class="md-nav__link">
    <span class="md-ellipsis">
      inline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutable" class="md-nav__link">
    <span class="md-ellipsis">
      mutable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#namespace" class="md-nav__link">
    <span class="md-ellipsis">
      namespace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#noexcept" class="md-nav__link">
    <span class="md-ellipsis">
      noexcept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#override" class="md-nav__link">
    <span class="md-ellipsis">
      override
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static" class="md-nav__link">
    <span class="md-ellipsis">
      static
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static_assert" class="md-nav__link">
    <span class="md-ellipsis">
      static_assert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typename" class="md-nav__link">
    <span class="md-ellipsis">
      typename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typedefusingtypename" class="md-nav__link">
    <span class="md-ellipsis">
      typedef、using、typename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#volatile" class="md-nav__link">
    <span class="md-ellipsis">
      volatile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__thread" class="md-nav__link">
    <span class="md-ellipsis">
      __thread
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      内置函数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="内置函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#__builtin_expect" class="md-nav__link">
    <span class="md-ellipsis">
      __builtin_expect
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      编程注意点
    </span>
  </a>
  
    <nav class="md-nav" aria-label="编程注意点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    <span class="md-ellipsis">
      优先队列和sort中的不同点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      其他知识点
    </span>
  </a>
  
    <nav class="md-nav" aria-label="其他知识点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#deletenullptr" class="md-nav__link">
    <span class="md-ellipsis">
      为什么有的时候指针delete后还需要赋值nullptr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#int-mainreturn" class="md-nav__link">
    <span class="md-ellipsis">
      int main为什么可以不用return
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlock_guardstdmutex-lockm_mutex" class="md-nav__link">
    <span class="md-ellipsis">
      std::lock_guard\&lt;std::mutex> lock(m_mutex);
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      匿名对象
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlock_guard" class="md-nav__link">
    <span class="md-ellipsis">
      std::lock_guard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boost_check" class="md-nav__link">
    <span class="md-ellipsis">
      BOOST_CHECK
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdmove" class="md-nav__link">
    <span class="md-ellipsis">
      std::move
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdatomic" class="md-nav__link">
    <span class="md-ellipsis">
      std::atomic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdany" class="md-nav__link">
    <span class="md-ellipsis">
      std::any
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdfunction" class="md-nav__link">
    <span class="md-ellipsis">
      std::function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdbind" class="md-nav__link">
    <span class="md-ellipsis">
      std::bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdatomic_int" class="md-nav__link">
    <span class="md-ellipsis">
      std::atomic_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#syscallsys_gettid" class="md-nav__link">
    <span class="md-ellipsis">
      syscall(SYS_gettid)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linuxusrlocalincludeusrlocallibusrincludeusrlib" class="md-nav__link">
    <span class="md-ellipsis">
      linux下/usr/local/include、/usr/local/lib和/usr/include、/usr/lib的区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#__builtin_expect_1" class="md-nav__link">
    <span class="md-ellipsis">
      __builtin_expect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      类里纯虚函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      虚析构函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdweak_ptr" class="md-nav__link">
    <span class="md-ellipsis">
      std::weak_ptr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_" class="md-nav__link">
    <span class="md-ellipsis">
      变量名命名加_
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      变量作用域
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      C++绑定器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_str" class="md-nav__link">
    <span class="md-ellipsis">
      .c_str()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      函数对象和函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdis_trivially_destructible" class="md-nav__link">
    <span class="md-ellipsis">
      std::is_trivially_destructible
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trivial-destructor" class="md-nav__link">
    <span class="md-ellipsis">
      trivial destructor平凡析构函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      内存地址是按字节进行编码的
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_1" class="md-nav__link">
    <span class="md-ellipsis">
      C++函数什么时候传入参数用&amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#creturnexit" class="md-nav__link">
    <span class="md-ellipsis">
      C++中return和exit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static_1" class="md-nav__link">
    <span class="md-ellipsis">
      静态static
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cjava" class="md-nav__link">
    <span class="md-ellipsis">
      C++和java
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#main" class="md-nav__link">
    <span class="md-ellipsis">
      多个main问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ch" class="md-nav__link">
    <span class="md-ellipsis">
      C++类模板的声明和定义要放在同一个.h头文件
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      常量引用和引用引用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      指针指针
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      结构体里的静态函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stl" class="md-nav__link">
    <span class="md-ellipsis">
      STL中的配接器和配置器的区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c-iostream" class="md-nav__link">
    <span class="md-ellipsis">
      C++ iostream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stl_1" class="md-nav__link">
    <span class="md-ellipsis">
      STL中函数对象和算法的区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nullnullptr" class="md-nav__link">
    <span class="md-ellipsis">
      NULL和nullptr的区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cforii" class="md-nav__link">
    <span class="md-ellipsis">
      C++的for循环中++i和i++的区别：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      无穷大与无穷小
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#template" class="md-nav__link">
    <span class="md-ellipsis">
      template
    </span>
  </a>
  
    <nav class="md-nav" aria-label="template">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      函数模板
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      类模板
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterator_type-base-const" class="md-nav__link">
    <span class="md-ellipsis">
      iterator_type base() const
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      证同函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const_cast" class="md-nav__link">
    <span class="md-ellipsis">
      const_cast
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reinterpret_cast" class="md-nav__link">
    <span class="md-ellipsis">
      reinterpret_cast
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_const" class="md-nav__link">
    <span class="md-ellipsis">
      remove_const
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      可变参数模板
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      左值和右值
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      左值引用和右值引用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      右值引用&amp;&amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static_cast" class="md-nav__link">
    <span class="md-ellipsis">
      static_cast
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const_caststatic_cast" class="md-nav__link">
    <span class="md-ellipsis">
      什么时候用const_cast和什么时候用static_cast
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert" class="md-nav__link">
    <span class="md-ellipsis">
      assert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cin" class="md-nav__link">
    <span class="md-ellipsis">
      cin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cinget" class="md-nav__link">
    <span class="md-ellipsis">
      cin.get()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    <span class="md-ellipsis">
      const &amp;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      闭包
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1、单纯用{}把一段代码框起来
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5c" class="md-nav__link">
    <span class="md-ellipsis">
      5、C++回调
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10c" class="md-nav__link">
    <span class="md-ellipsis">
      10、C中的回调
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15cstructclass" class="md-nav__link">
    <span class="md-ellipsis">
      15、C++中的struct和class区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    <span class="md-ellipsis">
      25、指针符号存放地址
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30memsetsizeof" class="md-nav__link">
    <span class="md-ellipsis">
      30、memset，sizeof
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35size_tint" class="md-nav__link">
    <span class="md-ellipsis">
      35、什么时候用size_t，什么时候用int
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40using-namespace-stdnamespace-std" class="md-nav__link">
    <span class="md-ellipsis">
      40、using namespace std;和namespace std
    </span>
  </a>
  
    <nav class="md-nav" aria-label="40、using namespace std;和namespace std">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#using-namespace-std" class="md-nav__link">
    <span class="md-ellipsis">
      using namespace std;
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#namespace-std" class="md-nav__link">
    <span class="md-ellipsis">
      namespace std { ... }
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      推荐做法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#45privateprotected" class="md-nav__link">
    <span class="md-ellipsis">
      45、类里面的private和protected
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#50" class="md-nav__link">
    <span class="md-ellipsis">
      50、函数名的意义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#55" class="md-nav__link">
    <span class="md-ellipsis">
      55、虚函数和纯虚函数，子类继承后会怎么样
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#60auto" class="md-nav__link">
    <span class="md-ellipsis">
      60、auto时要不要使用引用&amp;
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      错误
    </span>
  </a>
  
    <nav class="md-nav" aria-label="错误">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stdanyvscodestdany" class="md-nav__link">
    <span class="md-ellipsis">
      编译的时候std::any能找到没出错，但是vscode里编辑时找不到std::any
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#65" class="md-nav__link">
    <span class="md-ellipsis">
      65、一个文件使用另一个文件的变量
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      常用实例
    </span>
  </a>
  
    <nav class="md-nav" aria-label="常用实例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1、函数与库的对应
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2、常用操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3、数组
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3、数组">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      动态创建数组并输出
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4vector" class="md-nav__link">
    <span class="md-ellipsis">
      4、vector
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4、vector">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector" class="md-nav__link">
    <span class="md-ellipsis">
      vector创建不定长的一组数据
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector_1" class="md-nav__link">
    <span class="md-ellipsis">
      手动创建vector容器嵌套容器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector_2" class="md-nav__link">
    <span class="md-ellipsis">
      vector容器打印
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector_3" class="md-nav__link">
    <span class="md-ellipsis">
      vector容器嵌套容器的打印
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      求容器中的最大最小值
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5、字符串
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5、字符串">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      输入一个不带空格的字符串
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      输入一个带空格的字符串
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      常用函数
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    <span class="md-ellipsis">
      6、链表
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6、链表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    <span class="md-ellipsis">
      尾插法创建不定长的单向链表（带头结点）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    <span class="md-ellipsis">
      尾插法创建不定长的单向链表（不带头结点）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    <span class="md-ellipsis">
      输出链表元素（带头结点）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    <span class="md-ellipsis">
      输出链表元素（不带头结点）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    <span class="md-ellipsis">
      7、树
    </span>
  </a>
  
    <nav class="md-nav" aria-label="7、树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    <span class="md-ellipsis">
      根据数组，层次法创建二叉树
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树的遍历，并输出
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    <span class="md-ellipsis">
      数学
    </span>
  </a>
  
    <nav class="md-nav" aria-label="数学">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    <span class="md-ellipsis">
      公倍数与公因数
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#70" class="md-nav__link">
    <span class="md-ellipsis">
      70、回调函数，什么时候回调，谁来回调
    </span>
  </a>
  
    <nav class="md-nav" aria-label="70、回调函数，什么时候回调，谁来回调">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    <span class="md-ellipsis">
      异步调用为什么要有回调函数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="异步调用为什么要有回调函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      1. 网络请求
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-io" class="md-nav__link">
    <span class="md-ellipsis">
      2. 文件I/O
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    <span class="md-ellipsis">
      示例代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    <span class="md-ellipsis">
      代码解释
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#75static" class="md-nav__link">
    <span class="md-ellipsis">
      75、类的static成员函数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="75、类的static成员函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    <span class="md-ellipsis">
      示例代码
    </span>
  </a>
  
    <nav class="md-nav" aria-label="示例代码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    <span class="md-ellipsis">
      类声明（头文件）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    <span class="md-ellipsis">
      类定义（源文件）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    <span class="md-ellipsis">
      主函数（测试文件）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    <span class="md-ellipsis">
      解释
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8075" class="md-nav__link">
    <span class="md-ellipsis">
      80、什么时候有必要像75这么做
    </span>
  </a>
  
    <nav class="md-nav" aria-label="80、什么时候有必要像75这么做">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    <span class="md-ellipsis">
      1. 不依赖于实例成员
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2. 全局唯一的行为
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      3. 工厂方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4. 访问静态成员
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5_1" class="md-nav__link">
    <span class="md-ellipsis">
      5. 不需要多态行为
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6_1" class="md-nav__link">
    <span class="md-ellipsis">
      6. 提高可读性和组织性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#85this" class="md-nav__link">
    <span class="md-ellipsis">
      85、this指针的作用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#90" class="md-nav__link">
    <span class="md-ellipsis">
      90、类的虚函数声明
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#95" class="md-nav__link">
    <span class="md-ellipsis">
      95、回调函数什么时候需要声明成静态
    </span>
  </a>
  
    <nav class="md-nav" aria-label="95、回调函数什么时候需要声明成静态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    <span class="md-ellipsis">
      什么时候需要声明回调函数为静态
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    <span class="md-ellipsis">
      示例
    </span>
  </a>
  
    <nav class="md-nav" aria-label="示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    <span class="md-ellipsis">
      静态成员函数作为回调函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    <span class="md-ellipsis">
      非静态成员函数作为回调函数
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#100switch-case" class="md-nav__link">
    <span class="md-ellipsis">
      100、switch-case中变量的作用域
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#105c_str" class="md-nav__link">
    <span class="md-ellipsis">
      105、c_str
    </span>
  </a>
  
    <nav class="md-nav" aria-label="105、c_str">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    <span class="md-ellipsis">
      详细解释
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#110" class="md-nav__link">
    <span class="md-ellipsis">
      110、什么时候接口或回调函数传入*或**
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    <span class="md-ellipsis">
      示例
    </span>
  </a>
  
    <nav class="md-nav" aria-label="示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    <span class="md-ellipsis">
      函数实现示例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    <span class="md-ellipsis">
      解释
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    <span class="md-ellipsis">
      释放内存示例
    </span>
  </a>
  
    <nav class="md-nav" aria-label="释放内存示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#char" class="md-nav__link">
    <span class="md-ellipsis">
      使用 char*
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#char_1" class="md-nav__link">
    <span class="md-ellipsis">
      使用 char**
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    <span class="md-ellipsis">
      示例说明
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#115" class="md-nav__link">
    <span class="md-ellipsis">
      115、指针终极理解
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#120stdmutex" class="md-nav__link">
    <span class="md-ellipsis">
      120、明确std::mutex锁
    </span>
  </a>
  
    <nav class="md-nav" aria-label="120、明确std::mutex锁">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stdlock_guard_1" class="md-nav__link">
    <span class="md-ellipsis">
      std::lock_guard
    </span>
  </a>
  
    <nav class="md-nav" aria-label="std::lock_guard">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-stdlock_guard" class="md-nav__link">
    <span class="md-ellipsis">
      1. std::lock_guard 什么时候释放
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 避免死锁：确保总是以相同的顺序锁定多个互斥锁
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdlock" class="md-nav__link">
    <span class="md-ellipsis">
      使用 std::lock 来避免死锁
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#125r" class="md-nav__link">
    <span class="md-ellipsis">
      125、构建字符串前加不加R
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#130const-stdstring-stdstring-stdstring" class="md-nav__link">
    <span class="md-ellipsis">
      130、函数的入参什么时候设置为const std::string&amp;或 std::string&amp;或 std::string
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#135structclass" class="md-nav__link">
    <span class="md-ellipsis">
      135、struct和class里定义哪些必须赋初值
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#140" class="md-nav__link">
    <span class="md-ellipsis">
      140、类什么时候拥有默认构造函数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="140、类什么时候拥有默认构造函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    <span class="md-ellipsis">
      默认构造函数的存在条件
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    <span class="md-ellipsis">
      显式声明默认构造函数
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#145clear-str" class="md-nav__link">
    <span class="md-ellipsis">
      145、clear() 和赋值操作 str = ""
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#150" class="md-nav__link">
    <span class="md-ellipsis">
      150、防止类的拷贝和赋值操作
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#155free" class="md-nav__link">
    <span class="md-ellipsis">
      155、什么时候需要free内存
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#160stdenable_shared_from_this" class="md-nav__link">
    <span class="md-ellipsis">
      160、继承时使用std::enable_shared_from_this
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#165" class="md-nav__link">
    <span class="md-ellipsis">
      165、在程序接口中传入指针又传出指针，要记得判空
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#180" class="md-nav__link">
    <span class="md-ellipsis">
      180、对于空字符串进入进出函数，也最好需要判断
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#181stdmovenlohmannjson" class="md-nav__link">
    <span class="md-ellipsis">
      181、有些临时对象记得用std::move，避免不必要的拷贝操作。特别是对于nlohmann::json这种大的对象
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#182returnreturn" class="md-nav__link">
    <span class="md-ellipsis">
      182、在所有的return之前一定要记得释放资源，而不要提前return了，却没有释放。（包括文件、指针之类的都算）
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#185" class="md-nav__link">
    <span class="md-ellipsis">
      185、对同一块内容不能锁定两次
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#190static" class="md-nav__link">
    <span class="md-ellipsis">
      190、在局部函数里用static，定义比较大的一块内存，比如数组之类，这样不用每次进入都浪费内存
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#195" class="md-nav__link">
    <span class="md-ellipsis">
      195、迭代器
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#200" class="md-nav__link">
    <span class="md-ellipsis">
      200、什么时候需要前向声明
    </span>
  </a>
  
    <nav class="md-nav" aria-label="200、什么时候需要前向声明">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    <span class="md-ellipsis">
      1. 减少头文件依赖
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. 减少头文件依赖">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    <span class="md-ellipsis">
      示例
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    <span class="md-ellipsis">
      2. 解决循环依赖
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. 解决循环依赖">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    <span class="md-ellipsis">
      示例
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_2" class="md-nav__link">
    <span class="md-ellipsis">
      3. 减少编译时间
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      4. 隐藏实现细节
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. 隐藏实现细节">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    <span class="md-ellipsis">
      示例
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    <span class="md-ellipsis">
      什么时候不需要前向声明
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#205" class="md-nav__link">
    <span class="md-ellipsis">
      205、常量定义的地方
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#210externstatic" class="md-nav__link">
    <span class="md-ellipsis">
      210、extern和static关键字
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#215mapnlohamnnjson" class="md-nav__link">
    <span class="md-ellipsis">
      215、map里nlohamnn::json的指针或者迭代器失效的问题
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#220" class="md-nav__link">
    <span class="md-ellipsis">
      220、在基类函数中判断子类的类型
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#225dynamic_pointer_castdynamic_cast" class="md-nav__link">
    <span class="md-ellipsis">
      225、dynamic_pointer_cast和dynamic_cast区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#230stdmove" class="md-nav__link">
    <span class="md-ellipsis">
      230、什么时候使用std::move
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#235" class="md-nav__link">
    <span class="md-ellipsis">
      235、检查准则
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#240intconst" class="md-nav__link">
    <span class="md-ellipsis">
      240、int入参，我感觉就没必要const引用了，反正很小；如果要修改入参的话再用引用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#245" class="md-nav__link">
    <span class="md-ellipsis">
      245、迭代器全部失效而不是部分失效的原因
    </span>
  </a>
  
    <nav class="md-nav" aria-label="245、迭代器全部失效而不是部分失效的原因">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    <span class="md-ellipsis">
      为什么会全部失效？
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#250emplace_back" class="md-nav__link">
    <span class="md-ellipsis">
      250、emplace_back什么时候会重新分配内存
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#255" class="md-nav__link">
    <span class="md-ellipsis">
      255、命名空间的相关问题
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#230nlohmannjsontry-catch" class="md-nav__link">
    <span class="md-ellipsis">
      230、nlohmann::json与try-catch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#235dynamic_caststatic_cast" class="md-nav__link">
    <span class="md-ellipsis">
      235、dynamic_cast和static_cast有什么区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#240delete" class="md-nav__link">
    <span class="md-ellipsis">
      240、delete掉拷贝构造函数和移动构造函数
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#245_1" class="md-nav__link">
    <span class="md-ellipsis">
      245、赋值运算符和构造函数的区别是什么
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#250vector" class="md-nav__link">
    <span class="md-ellipsis">
      250、vector容器的注意点
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#255-stdunique_lock-stdlock_guard" class="md-nav__link">
    <span class="md-ellipsis">
      255、等待条件变量时，使用 std::unique_lock 而不是 std::lock_guard
    </span>
  </a>
  
    <nav class="md-nav" aria-label="255、等待条件变量时，使用 std::unique_lock 而不是 std::lock_guard">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    <span class="md-ellipsis">
      代码示例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#260" class="md-nav__link">
    <span class="md-ellipsis">
      260、锁的问题
    </span>
  </a>
  
    <nav class="md-nav" aria-label="260、锁的问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    <span class="md-ellipsis">
      具体原因
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    <span class="md-ellipsis">
      正确的使用方式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#265share_from_thisweak_ptrweak_ptrlockshare_ptr" class="md-nav__link">
    <span class="md-ellipsis">
      265、share_from_this返回了一个weak_ptr，然后weak_ptr再去lock得到一个share_ptr是什么操作
    </span>
  </a>
  
    <nav class="md-nav" aria-label="265、share_from_this返回了一个weak_ptr，然后weak_ptr再去lock得到一个share_ptr是什么操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shared_from_this-weak_ptr" class="md-nav__link">
    <span class="md-ellipsis">
      shared_from_this 和 weak_ptr 的使用
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weak_ptr-lock" class="md-nav__link">
    <span class="md-ellipsis">
      weak_ptr 和 lock
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    <span class="md-ellipsis">
      操作步骤
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#270stdmutexlockunlocklock_guardunique_lock" class="md-nav__link">
    <span class="md-ellipsis">
      270、std::mutex直接lock和unlock、lock_guard、unique_lock的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#275unique_locklockunlock" class="md-nav__link">
    <span class="md-ellipsis">
      275、unique_lock手动lock和unlock的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#280notify" class="md-nav__link">
    <span class="md-ellipsis">
      280、什么时候调用notify
    </span>
  </a>
  
    <nav class="md-nav" aria-label="280、什么时候调用notify">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#notify" class="md-nav__link">
    <span class="md-ellipsis">
      什么时候调用 notify
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#285" class="md-nav__link">
    <span class="md-ellipsis">
      285、前向声明
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#290" class="md-nav__link">
    <span class="md-ellipsis">
      290、不要出现交叉引用的问题
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#295" class="md-nav__link">
    <span class="md-ellipsis">
      295、虚函数在基类要声明成什么访问类型，在子类重载时又要声明成什么访问类型
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#300protectedprivate" class="md-nav__link">
    <span class="md-ellipsis">
      300、虚函数在基类声明成protected成员，子类可以声明成private吗
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#305delete" class="md-nav__link">
    <span class="md-ellipsis">
      305、为什么习惯将拷贝构造函数和赋值构造函数声明为delete
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#310extern-c" class="md-nav__link">
    <span class="md-ellipsis">
      310、什么时候加extern "C"
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#315" class="md-nav__link">
    <span class="md-ellipsis">
      315、孙子类继承
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#320" class="md-nav__link">
    <span class="md-ellipsis">
      320、基类指针指向子类和孙子类
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#325" class="md-nav__link">
    <span class="md-ellipsis">
      325、含有默认参数的函数声明与定义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#330constunordered_map" class="md-nav__link">
    <span class="md-ellipsis">
      330、const类型的unordered_map取值
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#335mapinsertmap" class="md-nav__link">
    <span class="md-ellipsis">
      335、map容器insert另一个map时的问题
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#340goto-end" class="md-nav__link">
    <span class="md-ellipsis">
      340、goto end的使用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#345lambda" class="md-nav__link">
    <span class="md-ellipsis">
      345、lambda函数捕获变量[&amp;]
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#350" class="md-nav__link">
    <span class="md-ellipsis">
      350、构造函数
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#355cc" class="md-nav__link">
    <span class="md-ellipsis">
      355、在C和C++编程中，将结构体作为函数参数传递时，使用指针而不是值传递有几个重要原因：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="355、在C和C++编程中，将结构体作为函数参数传递时，使用指针而不是值传递有几个重要原因：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_5" class="md-nav__link">
    <span class="md-ellipsis">
      1. 性能考虑
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_4" class="md-nav__link">
    <span class="md-ellipsis">
      2. 修改原数据
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 一致性和习惯
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#340c" class="md-nav__link">
    <span class="md-ellipsis">
      340、在C语言，默认参数不能是引用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#345" class="md-nav__link">
    <span class="md-ellipsis">
      345、函数入参可以传引用，这个强制调用者在外部创造一个拥有自己内存空间的对象
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/smileatl/smileatlRepo/edit/master/docs/Cpp/myCpp/100.myCpp.md" title="编辑此页" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg>
    </a>
  
  
    
      
    
    <a href="https://github.com/smileatl/smileatlRepo/raw/master/docs/Cpp/myCpp/100.myCpp.md" title="查看本页的源代码" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"/></svg>
    </a>
  


<h1 id="mycpp">myCpp<a class="headerlink" href="#mycpp" title="Permanent link">&para;</a></h1>
<h2 id="_1">自己的知识点<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>返回值不可以作为重载的区分</p>
<h3 id="_2">引用<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p><font color='red'>指针常量：指针的指向不可修改，指针指向的值是可以改变的</font></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="c1">//发现是引用，转换为 int* const ref = &amp;a;</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref</span><span class="p">){</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="w">    </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="c1">// ref是引用，转换为*ref = 100</span>
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="p">}</span>
<a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>
<a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a><span class="w">    </span><span class="c1">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span>
<a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a><span class="w">    </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span>
<a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a><span class="w">    </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c1">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span>
<a id="__codelineno-0-11" name="__codelineno-0-11" href="#__codelineno-0-11"></a>
<a id="__codelineno-0-12" name="__codelineno-0-12" href="#__codelineno-0-12"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-0-13" name="__codelineno-0-13" href="#__codelineno-0-13"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ref:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-0-14" name="__codelineno-0-14" href="#__codelineno-0-14"></a>
<a id="__codelineno-0-15" name="__codelineno-0-15" href="#__codelineno-0-15"></a><span class="w">    </span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<a id="__codelineno-0-16" name="__codelineno-0-16" href="#__codelineno-0-16"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-0-17" name="__codelineno-0-17" href="#__codelineno-0-17"></a><span class="p">}</span>
</code></pre></div>
<p><img alt="s1663253977101" src="../assets/1663253977101.png" /></p>
<h3 id="new-delete">new , delete<a class="headerlink" href="#new-delete" title="Permanent link">&para;</a></h3>
<p>堆区程序员手动开辟，也需要手动释放，不delete掉的话会造成内存泄漏</p>
<p>利用new创建的数据，会返回该数据对应的类型的指针</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="c1">//利用new关键字  可以将数据开辟到堆区</span>
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="c1">//利用new创建的数据，会返回该数据对应的类型的指针</span>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="c1">//指针  本质也是局部变量，放在栈区，指针保存的数据是放在堆区</span>
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="c1">//释放</span>
<a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="k">delete</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>
<a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="c1">//释放数组 delete 后加 []</span>
<a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span>
</code></pre></div>
<p>指针：本质也是局部变量，放在栈区
指针保存的数据放在堆区</p>
<p>当我们使用未初始化内存的指针时：
会导致程序无法进行，因为指针并没有指向一个合法的地址，这时候其内部存的只是一些乱码，所以在调用函数时，会使用乱码所指的内存，指针根本就无权访问，导致出错。
解决办法：new 为指针动态分配内存，之后再用delete将其释放</p>
<p>容器中*it是什么是</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="w">        </span><span class="c1">//*it就是int</span>
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="w">    </span><span class="p">}</span>
</code></pre></div>
<h3 id="_3">指针<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<h4 id="_4">指针与常量<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">//指针可以被修改，值也可以被修改</span>
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">//指针可以被修改，值不可以被修改（const int），常量指针</span>
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">//指针不可以被修改（* const），值可以被修改，指针常量</span>
<a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">p4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">//指针不可以被修改，值也不可以被修改</span>
</code></pre></div>
<h4 id="_5">指针函数与函数指针<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="c1">// addition是指针函数，一个返回类型是指针的函数</span>
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">addition</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a><span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="p">}</span>
<a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a><span class="kt">int</span><span class="w"> </span><span class="nf">subtraction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a><span class="p">}</span>
<a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a><span class="kt">int</span><span class="w"> </span><span class="nf">operation</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a><span class="p">}</span>
<a id="__codelineno-4-12" name="__codelineno-4-12" href="#__codelineno-4-12"></a>
<a id="__codelineno-4-13" name="__codelineno-4-13" href="#__codelineno-4-13"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addition</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<a id="__codelineno-4-14" name="__codelineno-4-14" href="#__codelineno-4-14"></a><span class="c1">// minus是函数指针，指向函数的指针</span>
<a id="__codelineno-4-15" name="__codelineno-4-15" href="#__codelineno-4-15"></a><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">minus</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtraction</span><span class="p">;</span>
<a id="__codelineno-4-16" name="__codelineno-4-16" href="#__codelineno-4-16"></a><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">operation</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">minus</span><span class="p">);</span>
</code></pre></div>
<h4 id="_6">指向指针的引用<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p>在函数调用时用指针或者引用做参数，表示把变量的地址传递给子函数，
但是子函数只能修改指针所指变量的值，并不能修改指针的指向。</p>
<p><mark>如果想要修改指针的指向，就要用指针的指针，或者指针的引用</mark></p>
<h3 id="_7">字符串<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// 字符串</span>
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="c1">// 字符串中取出来单个字符还是字符串</span>
</code></pre></div>
<h3 id="_8">关键字<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<h4 id="auto">auto<a class="headerlink" href="#auto" title="Permanent link">&para;</a></h4>
<p>就是根据后面的值，来自己推测前面的类型是什么。
作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。
用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）</p>
<h4 id="constexpr">constexpr<a class="headerlink" href="#constexpr" title="Permanent link">&para;</a></h4>
<p><code>constexpr</code> 是 C++11 引入的一个关键字，用于声明在编译时可以计算出结果的表达式或函数。使用 <code>constexpr</code> 声明的表达式或函数在编译时就会被计算出结果，而不是在程序运行时才计算。这样可以提高程序的性能和效率。</p>
<p><code>constexpr</code> 可以用于声明变量、函数和类成员函数。对于变量，使用 <code>constexpr</code> 声明的变量必须在编译时就能确定其值。对于函数，使用 <code>constexpr</code> 声明的函数必须能在编译时就能计算出结果。对于类成员函数，使用 <code>constexpr</code> 声明的成员函数必须能在编译时就能计算出结果，并且不能有任何副作用。</p>
<p>下面是一个使用 <code>constexpr</code> 声明的函数示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="p">{</span>
<a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="mi">-1</span><span class="p">);</span>
<a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a><span class="p">}</span>
</code></pre></div>
<p>这个函数计算一个整数的阶乘，并使用 <code>constexpr</code> 声明，因此可以在编译时就计算出结果。在使用时，可以将其作为常量表达式使用：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// x 的值为 120</span>
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span><span class="w"> </span><span class="c1">// y 的值为 720，在编译时就计算出结果</span>
</code></pre></div>
<p>需要注意的是，<code>constexpr</code> 声明的函数必须满足一些限制，比如不能有任何副作用，不能包含循环语句等。</p>
<h4 id="explict">explict<a class="headerlink" href="#explict" title="Permanent link">&para;</a></h4>
<p><code>explicit</code> 是 C++ 中的一个关键字，用于修饰构造函数，表示该构造函数只能用于显式地创建对象，而不能隐式地进行类型转换。举个例子，如果有一个类 A，它有一个带有一个参数的构造函数，如果这个构造函数被声明为 <code>explicit</code>，那么就不能像下面这样隐式地进行类型转换：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错误，不能隐式地进行类型转换</span>
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="n">A</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 正确，可以显式地创建对象</span>
</code></pre></div>
<p>如果该构造函数没有被声明为 <code>explicit</code>，那么上面的代码就会编译通过，因为编译器会自动把整型转换成类 Anb 的一个对象。<code>explicit</code> 关键字可以避免这种情况的发生，使代码更加明确和安全。</p>
<p>C++显式构造是指通过构造函数明确地创建对象，不允许进行隐式转换。这意味着在使用显式构造时，必须使用构造函数来创建对象，不能简单地将其他类型的值赋给该对象。显式构造可以避免一些意外的类型转换，提高代码的可读性和安全性。</p>
<h4 id="extern">extern<a class="headerlink" href="#extern" title="Permanent link">&para;</a></h4>
<p>在C++中，<code>extern</code>是一个关键字，用于指示一个变量或函数是在其他文件中定义的。具体来说，如果一个变量或函数被声明为<code>extern</code>，那么编译器将在其他文件中查找该变量或函数的定义。这通常用于在多个源文件中共享变量或函数的定义。例如，如果你在一个源文件中定义了一个全局变量，并且想在另一个源文件中使用该变量，你可以在第二个源文件中使用<code>extern</code>关键字来引用该变量，而不需要重新定义它。</p>
<p>例如，假设你在一个源文件中定义了一个全局变量<code>int num = 10;</code>，你可以在另一个源文件中使用<code>extern int num;</code>来引用该变量，而不需要重新定义它。这样，编译器将在其他文件中查找该变量的定义，然后将其链接到你的程序中。</p>
<p>注意，<code>extern</code>关键字只是一个声明，它并不会分配内存或定义变量或函数。它只是告诉编译器该变量或函数在其他文件中定义，需要在链接时进行解析。</p>
<p>在 C++ 中，<code>extern</code> 是一个关键字，用于在当前文件以外的地方声明一个变量或函数。其作用有以下两个方面：</p>
<ol>
<li>声明外部变量：使用 <code>extern</code> 关键字可以在当前文件中声明一个在其他文件中定义的全局变量。这样，在当前文件中就可以使用这个变量，而不需要重新定义一遍。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="c1">// file1.cpp</span>
<a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>
<a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a><span class="c1">// file2.cpp</span>
<a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a>
<a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a><span class="c1">// main.cpp</span>
<a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-9-9" name="__codelineno-9-9" href="#__codelineno-9-9"></a><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<a id="__codelineno-9-10" name="__codelineno-9-10" href="#__codelineno-9-10"></a>
<a id="__codelineno-9-11" name="__codelineno-9-11" href="#__codelineno-9-11"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-9-12" name="__codelineno-9-12" href="#__codelineno-9-12"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;count = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-9-13" name="__codelineno-9-13" href="#__codelineno-9-13"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-9-14" name="__codelineno-9-14" href="#__codelineno-9-14"></a><span class="p">}</span>
</code></pre></div>
<p>在这个例子中，<code>count</code> 变量在 <code>file1.cpp</code> 中被声明为外部变量，然后在 <code>file2.cpp</code> 中被定义为 0。在 <code>main.cpp</code> 中，<code>count</code> 又被声明为外部变量，并被用于输出。</p>
<ol>
<li>
<p>声明外部函数：使用 <code>extern</code> 关键字可以在当前文件中声明一个在其他文件中定义的函数。这样，在当前文件中就可以调用这个函数，而不需要重新定义一遍。</p>
</li>
<li>
<p><code>extern "C"</code>是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern "C"来说明</p>
</li>
</ol>
<h4 id="final">final<a class="headerlink" href="#final" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，<code>final</code> 是一个关键字，用于限制类、成员函数或虚函数的继承或覆盖。</p>
<ol>
<li><code>final</code> 修饰类：
   当一个类被声明为 <code>final</code> 时，表示该类不能被继承。任何试图从该类派生出新类的尝试都将导致编译错误。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a><span class="w">  </span><span class="c1">// ...</span>
<a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a><span class="p">};</span>
<a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a>
<a id="__codelineno-10-5" name="__codelineno-10-5" href="#__codelineno-10-5"></a><span class="c1">// 错误示例：无法从 final 类派生</span>
<a id="__codelineno-10-6" name="__codelineno-10-6" href="#__codelineno-10-6"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-10-7" name="__codelineno-10-7" href="#__codelineno-10-7"></a><span class="w">  </span><span class="c1">// ...</span>
<a id="__codelineno-10-8" name="__codelineno-10-8" href="#__codelineno-10-8"></a><span class="p">};</span>
</code></pre></div>
<ol>
<li><code>final</code> 修饰成员函数：
   当一个成员函数被声明为 <code>final</code> 时，表示该函数不能被重写（覆盖）。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a><span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a><span class="p">};</span>
<a id="__codelineno-11-7" name="__codelineno-11-7" href="#__codelineno-11-7"></a>
<a id="__codelineno-11-8" name="__codelineno-11-8" href="#__codelineno-11-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-9" name="__codelineno-11-9" href="#__codelineno-11-9"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-11-10" name="__codelineno-11-10" href="#__codelineno-11-10"></a><span class="w">  </span><span class="c1">// 错误示例：无法重写 final 函数</span>
<a id="__codelineno-11-11" name="__codelineno-11-11" href="#__codelineno-11-11"></a><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-12" name="__codelineno-11-12" href="#__codelineno-11-12"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-11-13" name="__codelineno-11-13" href="#__codelineno-11-13"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-11-14" name="__codelineno-11-14" href="#__codelineno-11-14"></a><span class="p">};</span>
</code></pre></div>
<ol>
<li><code>final</code> 修饰虚函数：
   当一个虚函数被声明为 <code>final</code> 时，表示该虚函数不能被子类再次重写（覆盖）。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a><span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-12-4" name="__codelineno-12-4" href="#__codelineno-12-4"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-12-5" name="__codelineno-12-5" href="#__codelineno-12-5"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-12-6" name="__codelineno-12-6" href="#__codelineno-12-6"></a><span class="p">};</span>
<a id="__codelineno-12-7" name="__codelineno-12-7" href="#__codelineno-12-7"></a>
<a id="__codelineno-12-8" name="__codelineno-12-8" href="#__codelineno-12-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-12-9" name="__codelineno-12-9" href="#__codelineno-12-9"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-12-10" name="__codelineno-12-10" href="#__codelineno-12-10"></a><span class="w">  </span><span class="c1">// 错误示例：无法重写 final 虚函数</span>
<a id="__codelineno-12-11" name="__codelineno-12-11" href="#__codelineno-12-11"></a><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-12-12" name="__codelineno-12-12" href="#__codelineno-12-12"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-12-13" name="__codelineno-12-13" href="#__codelineno-12-13"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-12-14" name="__codelineno-12-14" href="#__codelineno-12-14"></a><span class="p">};</span>
</code></pre></div>
<p>使用 <code>final</code> 关键字可以用于防止类被继承、成员函数被重写，或者虚函数在子类中被再次覆盖。这有助于强制执行设计意图，并提高代码的可靠性和可维护性。</p>
<h4 id="friend">friend<a class="headerlink" href="#friend" title="Permanent link">&para;</a></h4>
<p>在C++中，<code>friend</code>是一个关键字，用于声明一个函数或类是另一个类的友元。友元可以访问声明它为友元的类的私有成员和保护成员，即使这些成员在其他地方是不可访问的。</p>
<p>具体来说，如果一个函数或类被声明为另一个类的友元，那么它就可以访问该类的私有成员和保护成员。这在某些情况下是非常有用的，例如在两个类之间需要共享数据时。但是，友元也可能导致代码的可维护性和安全性降低，因此应该谨慎使用。</p>
<p>友元可以声明在类的内部或外部，如果声明在类的内部，它将成为一个成员函数或成员类，如果声明在类的外部，它将成为一个普通函数或类。</p>
<p>下面是一个友元函数的例子：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<a id="__codelineno-13-4" name="__codelineno-13-4" href="#__codelineno-13-4"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-13-5" name="__codelineno-13-5" href="#__codelineno-13-5"></a><span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">setX</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// 声明setX为A的友元函数</span>
<a id="__codelineno-13-6" name="__codelineno-13-6" href="#__codelineno-13-6"></a><span class="p">};</span>
<a id="__codelineno-13-7" name="__codelineno-13-7" href="#__codelineno-13-7"></a>
<a id="__codelineno-13-8" name="__codelineno-13-8" href="#__codelineno-13-8"></a><span class="kt">void</span><span class="w"> </span><span class="nf">setX</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-13-9" name="__codelineno-13-9" href="#__codelineno-13-9"></a><span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 可以访问A的私有成员x</span>
<a id="__codelineno-13-10" name="__codelineno-13-10" href="#__codelineno-13-10"></a><span class="p">}</span>
</code></pre></div>
<p>在这个例子中，<code>setX</code>被声明为<code>A</code>的友元函数，因此它可以访问<code>A</code>的私有成员<code>x</code>。注意，<code>setX</code>并不是<code>A</code>的成员函数，因此它不能通过<code>this</code>指针访问<code>A</code>的成员。</p>
<h4 id="inline">inline<a class="headerlink" href="#inline" title="Permanent link">&para;</a></h4>
<p><code>inline</code> 是一个关键字，用于向编译器提供函数内联展开的建议。当函数被声明为 <code>inline</code> 时，编译器可以将函数的代码插入到调用该函数的地方，而不是通过函数调用的方式执行。这样可以减少函数调用的开销，提高代码的执行效率。</p>
<p>使用 <code>inline</code> 关键字的函数通常是**简短的函数**，函数体内部没有复杂的控制流和大量的代码。这样的函数在被频繁调用时，通过内联展开可以减少函数调用的开销，提高程序的性能。</p>
<p>需要注意的是，<code>inline</code> 关键字只是向编译器提供了一个建议，编译器是否真正将函数内联展开取决于编译器的实现和优化策略。编译器可能会根据函数的复杂性、调用频率等因素来决定是否进行内联展开。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a>在代码示例中，`inline int tid()` 表示将 `tid` 函数声明为内联函数。这意味着编译器可以选择将 `tid` 函数的代码插入到调用 `tid` 函数的地方，而不是通过函数调用的方式执行。这样可以避免函数调用的开销，提高获取线程 ID 的效率。
</code></pre></div>
<h4 id="mutable">mutable<a class="headerlink" href="#mutable" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，<code>mutable</code> 是一个关键字，用于修饰类的成员变量。当一个成员变量被声明为 <code>mutable</code> 时，表示该成员变量可以在 const 成员函数中修改。</p>
<p>通常情况下，const 成员函数不允许修改类的成员变量，因为 const 成员函数被认为是不会对对象的状态做出任何更改的函数。但有时候，我们可能需要在 const 成员函数中修改某些临时状态或计数器等非关键数据，这时就可以使用 <code>mutable</code> 关键字。</p>
<p>以下是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a><span class="w">  </span><span class="k">mutable</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用 mutable 修饰的可变成员变量</span>
<a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a>
<a id="__codelineno-15-4" name="__codelineno-15-4" href="#__codelineno-15-4"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-15-5" name="__codelineno-15-5" href="#__codelineno-15-5"></a><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">increment</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-15-6" name="__codelineno-15-6" href="#__codelineno-15-6"></a><span class="w">    </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 在 const 成员函数中修改 mutable 成员变量</span>
<a id="__codelineno-15-7" name="__codelineno-15-7" href="#__codelineno-15-7"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-15-8" name="__codelineno-15-8" href="#__codelineno-15-8"></a>
<a id="__codelineno-15-9" name="__codelineno-15-9" href="#__codelineno-15-9"></a><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">getCounter</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-15-10" name="__codelineno-15-10" href="#__codelineno-15-10"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span><span class="w"> </span><span class="c1">// 在 const 成员函数中访问 mutable 成员变量</span>
<a id="__codelineno-15-11" name="__codelineno-15-11" href="#__codelineno-15-11"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-15-12" name="__codelineno-15-12" href="#__codelineno-15-12"></a><span class="p">};</span>
</code></pre></div>
<p>在上述示例中，<code>increment()</code> 是一个 const 成员函数，但由于 <code>counter</code> 被声明为 <code>mutable</code>，它可以在该函数中被递增。而 <code>getCounter()</code> 也是一个 const 成员函数，可以读取 <code>counter</code> 的值。</p>
<p>需要注意的是，虽然 <code>mutable</code> 关键字允许在 const 成员函数中修改特定的成员变量，但仍然需要谨慎使用。滥用 <code>mutable</code> 可能会导致代码变得难以理解和维护，因此应该遵循良好的代码设计原则并慎重决定是否使用 <code>mutable</code>。</p>
<h4 id="namespace">namespace<a class="headerlink" href="#namespace" title="Permanent link">&para;</a></h4>
<p><code>namespace</code> 是 C++ 中用于避免命名冲突的一种机制。可以将一组相关的函数、类、变量等放在一个命名空间中，从而避免与其他命名空间中的同名实体发生冲突。在 C++ 中，命名空间用 <code>namespace</code> 关键字来定义，语法如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a><span class="k">namespace</span><span class="w"> </span><span class="nn">namespace_name</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-16-2" name="__codelineno-16-2" href="#__codelineno-16-2"></a><span class="w">    </span><span class="c1">// 命名空间内的代码</span>
<a id="__codelineno-16-3" name="__codelineno-16-3" href="#__codelineno-16-3"></a><span class="p">}</span>
</code></pre></div>
<p>在命名空间内部定义的变量、函数等只在该命名空间内可见，可以通过 <code>namespace_name::</code> 来访问。例如，假设有一个名为 <code>my_namespace</code> 的命名空间，其中定义了一个名为 <code>my_function</code> 的函数，可以使用以下方式来调用该函数：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a><span class="n">my_namespace</span><span class="o">::</span><span class="n">my_function</span><span class="p">();</span>
</code></pre></div>
<p>此外，还可以使用 <code>using namespace</code> 语句来指定使用哪个命名空间中的实体。例如，以下代码将使用 <code>my_namespace</code> 命名空间中的所有实体：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">my_namespace</span><span class="p">;</span>
</code></pre></div>
<p>需要注意的是，使用 <code>using namespace</code> 语句可能会导致命名冲突，因此应谨慎使用。</p>
<h4 id="noexcept">noexcept<a class="headerlink" href="#noexcept" title="Permanent link">&para;</a></h4>
<p><code>noexcept</code> 是 C++11 引入的一个关键字，用于指示一个函数是否会抛出异常。可以在函数声明或定义时使用 <code>noexcept</code> 关键字来指示该函数是否可能抛出异常，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-19-2" name="__codelineno-19-2" href="#__codelineno-19-2"></a><span class="w">    </span><span class="c1">// 函数体</span>
<a id="__codelineno-19-3" name="__codelineno-19-3" href="#__codelineno-19-3"></a><span class="p">}</span>
</code></pre></div>
<p>上述代码中，<code>noexcept</code> 关键字指示函数 <code>func()</code> 不会抛出异常。如果在函数体中抛出了异常，则程序会调用 <code>std::terminate()</code> 来终止程序。</p>
<p><code>noexcept</code> 还可以用于模板参数和表达式中，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-20-2" name="__codelineno-20-2" href="#__codelineno-20-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-20-3" name="__codelineno-20-3" href="#__codelineno-20-3"></a><span class="w">    </span><span class="c1">// 函数体</span>
<a id="__codelineno-20-4" name="__codelineno-20-4" href="#__codelineno-20-4"></a><span class="p">}</span>
</code></pre></div>
<p>上述代码中，<code>noexcept</code> 关键字用于模板参数 <code>T</code> 和表达式 <code>std::forward&lt;T&gt;(t)</code>，以指示函数 <code>func()</code> 是否会抛出异常。如果 <code>T</code> 或 <code>std::forward&lt;T&gt;(t)</code> 中包含了可能抛出异常的操作，则 <code>noexcept</code> 的值为 <code>false</code>，否则为 <code>true</code>。</p>
<p>使用 <code>noexcept</code> 关键字可以帮助编译器进行优化，提高程序的性能。</p>
<h4 id="override">override<a class="headerlink" href="#override" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，<code>override</code> 是一个关键字，用于显式地指示派生类的成员函数覆盖（重写）了基类中的虚函数。</p>
<p>当派生类继承自基类并且想要重写基类中的虚函数时，可以使用 <code>override</code> 关键字来提醒编译器检查是否正确地进行了函数的覆盖。这样可以避免一些因拼写错误或函数签名不匹配而导致的错误。</p>
<p>以下是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-21-2" name="__codelineno-21-2" href="#__codelineno-21-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-21-3" name="__codelineno-21-3" href="#__codelineno-21-3"></a><span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<a id="__codelineno-21-4" name="__codelineno-21-4" href="#__codelineno-21-4"></a><span class="p">};</span>
<a id="__codelineno-21-5" name="__codelineno-21-5" href="#__codelineno-21-5"></a>
<a id="__codelineno-21-6" name="__codelineno-21-6" href="#__codelineno-21-6"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-21-7" name="__codelineno-21-7" href="#__codelineno-21-7"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-21-8" name="__codelineno-21-8" href="#__codelineno-21-8"></a><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用 override 关键字，确保正确重写基类的虚函数</span>
<a id="__codelineno-21-9" name="__codelineno-21-9" href="#__codelineno-21-9"></a><span class="p">};</span>
</code></pre></div>
<p>在上述示例中，<code>Derived</code> 类继承自 <code>Base</code> 类，并重写了基类中的虚函数 <code>foo()</code>。通过在派生类中使用 <code>override</code> 关键字，编译器会检查是否存在与基类虚函数相匹配的函数。如果没有找到匹配的函数，或者函数签名不匹配，编译器将会报错。</p>
<p>使用 <code>override</code> 关键字可以增强代码的可读性和可维护性，并帮助捕获常见的重写错误。它是 C++11 引入的特性，但仅在虚函数重写时才需要使用，对于非虚函数没有必要使用 <code>override</code> 关键字。</p>
<h4 id="static">static<a class="headerlink" href="#static" title="Permanent link">&para;</a></h4>
<p>C++中的<code>static</code>关键字有多种用法：</p>
<ol>
<li>声明静态变量：在函数内部使用<code>static</code>关键字声明的变量将成为静态变量，其生命周期将与程序的生命周期相同，而不是与函数的生命周期相同。</li>
<li>声明静态成员变量：在类中使用<code>static</code>关键字声明的变量将成为静态成员变量，它们属于类而不是属于类的任何实例。静态成员变量在所有类的实例之间共享。</li>
<li>声明静态成员函数：在类中使用<code>static</code>关键字声明的函数将成为静态成员函数，它们不属于任何特定的实例，可以直接通过类名调用。</li>
<li>声明静态局部变量：在函数内部使用<code>static</code>关键字声明的变量将成为静态局部变量，其生命周期将与程序的生命周期相同，而不是与函数的生命周期相同。静态局部变量只能在声明的函数内部访问。</li>
</ol>
<p>总的来说，<code>static</code>关键字的作用是限制变量或函数的作用域，并且可以使变量或函数在程序的生命周期内保持状态。</p>
<h4 id="static_assert">static_assert<a class="headerlink" href="#static_assert" title="Permanent link">&para;</a></h4>
<p><code>static_assert</code> 是 C++11 标准引入的一个关键字，用于在编译期检查表达式是否为真。它的语法形式如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a><span class="k">static_assert</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span>
</code></pre></div>
<p>其中，<code>expression</code> 是要进行检查的表达式，可以是任意的常量表达式，如果表达式的结果为 false，则编译器会在编译期间产生一条错误信息，并输出 <code>message</code>。<code>message</code> 是可选的，用于指定错误信息的提示消息。</p>
<p><code>static_assert</code> 的作用是在编译期间检查程序的正确性，可以避免一些常见的编程错误。例如，可以使用 <code>static_assert</code> 来检查数组的大小是否符合要求，或者检查类型的大小是否满足某些限制。</p>
<h4 id="typename">typename<a class="headerlink" href="#typename" title="Permanent link">&para;</a></h4>
<p><code>typename</code> 是 C++ 中的一个关键字，通常用于模板元编程中。在模板中使用类型时，如果该类型依赖于模板参数，则需要使用 <code>typename</code> 关键字来告诉编译器该类型是一个类型而非一个变量或函数。例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-23-2" name="__codelineno-23-2" href="#__codelineno-23-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span>
<a id="__codelineno-23-3" name="__codelineno-23-3" href="#__codelineno-23-3"></a><span class="p">{</span>
<a id="__codelineno-23-4" name="__codelineno-23-4" href="#__codelineno-23-4"></a><span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">value_type</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// T::value_type 是一个依赖于模板参数 T 的类型</span>
<a id="__codelineno-23-5" name="__codelineno-23-5" href="#__codelineno-23-5"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的例子中，我们需要使用 <code>typename</code> 关键字来告诉编译器 <code>T::value_type</code> 是一个类型而非一个变量或函数。如果不使用 <code>typename</code>，编译器会将 <code>T::value_type</code> 解释为一个变量或函数，从而导致编译错误。</p>
<h4 id="typedefusingtypename">typedef、using、typename<a class="headerlink" href="#typedefusingtypename" title="Permanent link">&para;</a></h4>
<p>不完全正确。在C++中，<code>typename</code> 关键字通常用于指示一个依赖类型（dependent type）。它在模板编程中经常用于告诉编译器某个名称是一个类型而不是一个值或静态成员。</p>
<p><code>typename</code> 关键字通常在以下两种情况下使用：</p>
<ol>
<li>在模板中使用嵌套类型时，如果嵌套类型依赖于模板参数，需要使用 <code>typename</code> 来告诉编译器它是一个类型。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-24-2" name="__codelineno-24-2" href="#__codelineno-24-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-24-3" name="__codelineno-24-3" href="#__codelineno-24-3"></a><span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">NestedType</span><span class="w"> </span><span class="n">variable</span><span class="p">;</span><span class="w"> </span><span class="c1">// 告诉编译器 NestedType 是一个类型</span>
<a id="__codelineno-24-4" name="__codelineno-24-4" href="#__codelineno-24-4"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-24-5" name="__codelineno-24-5" href="#__codelineno-24-5"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li>在模板特化中引用依赖类型时，也需要使用 <code>typename</code>。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-25-2" name="__codelineno-25-2" href="#__codelineno-25-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-25-3" name="__codelineno-25-3" href="#__codelineno-25-3"></a><span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">NestedType</span><span class="w"> </span><span class="n">member</span><span class="p">;</span><span class="w"> </span><span class="c1">// 告诉编译器 NestedType 是一个类型</span>
<a id="__codelineno-25-4" name="__codelineno-25-4" href="#__codelineno-25-4"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-25-5" name="__codelineno-25-5" href="#__codelineno-25-5"></a><span class="p">};</span>
</code></pre></div>
<p>注意，<code>typename</code> 并非用于重命名类型的关键字。如果要重命名类型，可以使用 <code>typedef</code> 或 <code>using</code> 关键字。例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MyInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将 int 重命名为 MyInt</span>
<a id="__codelineno-26-2" name="__codelineno-26-2" href="#__codelineno-26-2"></a>
<a id="__codelineno-26-3" name="__codelineno-26-3" href="#__codelineno-26-3"></a><span class="k">using</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将 std::vector&lt;int&gt; 重命名为 MyType</span>
</code></pre></div>
<p>总结来说，<code>typename</code> 关键字用于指示依赖类型，而 <code>typedef</code> 或 <code>using</code> 关键字用于重命名类型。</p>
<h4 id="volatile">volatile<a class="headerlink" href="#volatile" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，<code>volatile</code> 是一个关键字，用于告诉编译器该变量的值可能会在程序的其他部分被修改，因此编译器不应该对该变量进行优化，例如缓存该变量的值，而应该每次都从内存中读取该变量的值。</p>
<p><code>volatile</code> 通常用于多线程编程或者与硬件交互的程序中，因为在这些情况下，变量的值可能会在程序的其他部分被修改，而编译器可能会对变量进行优化，导致程序出现错误。使用 <code>volatile</code> 可以避免这种情况发生。</p>
<p>需要注意的是，<code>volatile</code> 并不是线程安全的解决方案，它只是告诉编译器该变量可能会被修改，编译器会相应地生成代码，但是如果多个线程同时修改该变量，仍然需要使用其他的线程安全机制来保证程序的正确性。</p>
<h4 id="__thread">__thread<a class="headerlink" href="#__thread" title="Permanent link">&para;</a></h4>
<p><code>__thread</code> 是一个GCC编译器提供的关键字，用于声明线程局部存储(thread-local storage)的变量。</p>
<p>线程局部存储是一种机制，可以使得每个线程都拥有自己独立的变量副本，各个线程之间互不干扰。通常情况下，全局变量和静态变量是所有线程共享的，而使用 <code>__thread</code> 声明的变量则是每个线程独有的。</p>
<p>使用 <code>__thread</code> 关键字声明的变量只能是基本数据类型或指针类型，并且其生命周期与所属线程的生命周期相同。每个线程对应的变量副本在线程创建时被初始化，在线程销毁时被销毁。</p>
<p>这种线程局部存储的机制在多线程编程中非常有用，可以避免多个线程之间对同一变量的竞争和冲突。常见的应用场景包括线程安全的日志记录、线程特定的缓存等。需要注意的是，<code>__thread</code> 关键字仅在一些特定的编译器中有效，因此在编写跨平台的代码时需谨慎使用。</p>
<h3 id="_9">内置函数<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<h4 id="__builtin_expect">__builtin_expect<a class="headerlink" href="#__builtin_expect" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-27-1" name="__codelineno-27-1" href="#__codelineno-27-1"></a>// 使用 __builtin_expect 内置函数来提高条件判断的性能
<a id="__codelineno-27-2" name="__codelineno-27-2" href="#__codelineno-27-2"></a>// __builtin_expect用于给编译器提示条件表达式的预期结果，以便优化生成的代码。
</code></pre></div>
<h3 id="_10">编程注意点<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<h4 id="sort">优先队列和sort中的不同点<a class="headerlink" href="#sort" title="Permanent link">&para;</a></h4>
<ul>
<li><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;</code>：这行代码创建了一个名为 <code>minHeap</code> 的 <code>std::priority_queue</code>，并使用 <code>std::greater&lt;int&gt;</code> 作为比较函数。在优先队列中，<code>std::greater&lt;int&gt;</code> 会导致元素按照升序排列，因此 <code>minHeap</code> 是一个小顶堆，最小的元素位于队列的顶部。</li>
<li><code>sort(res.begin(), res.end(), greater&lt;int&gt;());</code>：这行代码使用 <code>std::greater&lt;int&gt;</code> 作为比较函数来对 <code>res</code> 容器中的元素进行排序。在 <code>std::sort</code> 函数中，<code>std::greater&lt;int&gt;</code> 会导致元素按照降序排列，因此 <code>res</code> 容器的元素将会按照降序排列。</li>
</ul>
<p>总结：</p>
<ul>
<li>对于优先队列 <code>std::priority_queue</code>，<code>std::greater&lt;int&gt;</code> 作为比较函数会导致小顶堆的形式，最小的元素位于堆顶。</li>
<li>对于排序函数 <code>std::sort</code>，<code>std::greater&lt;int&gt;</code> 作为比较函数会导致降序排列，最大的元素位于容器的前面。</li>
</ul>
<p>问题的关键在于比较函数的定义和上下文中的使用方式。</p>
<ul>
<li><strong>优先队列中的 <code>std::greater&lt;int&gt;</code></strong>：在优先队列中，<code>std::greater&lt;int&gt;</code> 作为比较函数，会导致元素按照升序排列，因为优先队列的特性是，堆顶元素是最小的。使用 <code>std::greater&lt;int&gt;</code> 作为比较函数确保较小的元素排在前面，创建了一个小顶堆。</li>
<li><strong>排序函数中<code>的 std::greater&lt;int&gt;</code></strong>：在排序函数中，<code>std::greater&lt;int&gt;</code> 作为比较函数，会导致元素按照降序排列，因为该比较函数会将较大的元素排在前面，从而实现降序排列。</li>
</ul>
<p>实际上，<code>std::greater&lt;int&gt;</code> 所做的事情是定义了一个“比较规则”，以决定元素之间的相对顺序。在优先队列中，这个比较规则用于确定元素在堆中的排列顺序，而在排序函数中，它用于确定元素在结果序列中的排列顺序。</p>
<p>所以，尽管在两个情境中都使用了 <code>std::greater&lt;int&gt;</code>，但是它们在不同的上下文中被用于不同的目的，从而产生了不同的效果。我希望这次的解释能够更加清楚地回答你的问题。如果还有疑惑，请随时继续提问。</p>
<h2 id="_11">其他知识点<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h2>
<h4 id="deletenullptr">为什么有的时候指针delete后还需要赋值nullptr<a class="headerlink" href="#deletenullptr" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，使用 <code>delete</code> 关键字释放动态分配的内存时，被释放的指针仍然保留着之前分配的内存地址。这意味着，即使你已经释放了内存，该指针仍然拥有一个无效的地址，也称为野指针。</p>
<p>为了避免在对已释放内存进行误操作时出现问题，通常建议将指针赋值为 <code>nullptr</code>。<code>nullptr</code> 是 C++11 引入的特殊空指针值，表示指针不指向任何有效的对象或函数。</p>
<p>通过将指针赋值为 <code>nullptr</code>，你可以在后续引用指针时进行检查，并避免意外地使用已释放的内存。这样做能够增加代码的可读性和可靠性，帮助你更容易地发现并处理潜在的 bug。</p>
<p>下面是一个示例，展示了删除指针后赋值为 <code>nullptr</code> 的用法：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-28-1" name="__codelineno-28-1" href="#__codelineno-28-1"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// 动态分配内存并初始化指针</span>
<a id="__codelineno-28-2" name="__codelineno-28-2" href="#__codelineno-28-2"></a><span class="c1">// 使用指针进行一些操作</span>
<a id="__codelineno-28-3" name="__codelineno-28-3" href="#__codelineno-28-3"></a><span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// 释放内存</span>
<a id="__codelineno-28-4" name="__codelineno-28-4" href="#__codelineno-28-4"></a><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将指针赋值为 nullptr</span>
</code></pre></div>
<p>注意，将指针赋值为 <code>nullptr</code> 只是一种良好的编程实践，并不是必需的操作。但是在多人协作或复杂的代码中，这样做可以提高代码的可维护性和安全性。</p>
<h4 id="int-mainreturn">int main为什么可以不用return<a class="headerlink" href="#int-mainreturn" title="Permanent link">&para;</a></h4>
<p>在 C++ 的 <code>main</code> 函数中，可以省略 <code>return</code> 语句，并且默认情况下视为隐含了 <code>return 0;</code>。这是因为 C++ 标准规定，如果 <code>main</code> 函数没有显式指定返回值，则默认返回值为 0，表示程序成功地终止。</p>
<p>这种行为是由 C++ 标准定义的一种约定，用于简化编写入口函数的代码。当 <code>main</code> 函数执行完毕时，程序会自动返回 0。这对于绝大多数程序来说是合适的，因为返回 0 通常表示程序正常退出。</p>
<p>然而，也可以显式地在 <code>main</code> 函数中使用 <code>return</code> 语句，并提供其他的返回值，以便表示特定的程序状态或错误码。例如，返回一个非零值可能表示程序发生了某种错误或异常情况。</p>
<p>总之，在大多数情况下，如果在 <code>main</code> 函数中省略了 <code>return</code> 语句，编译器会自动插入 <code>return 0;</code> 作为默认的返回值。但为了代码的清晰和可读性，建议在 <code>main</code> 函数中显式地使用 <code>return</code> 语句，以明确指定返回值。</p>
<h4 id="stdlock_guardstdmutex-lockm_mutex">std::lock_guard\&lt;std::mutex&gt; lock(m_mutex);<a class="headerlink" href="#stdlock_guardstdmutex-lockm_mutex" title="Permanent link">&para;</a></h4>
<p><code>std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</code> 是一个常用的用法，它使用了 C++ 标准库中的 <code>std::lock_guard</code> 类来实现互斥锁的自动上锁和解锁。</p>
<p>在这个用法中，<code>m_mutex</code> 是一个 <code>std::mutex</code> 对象，表示一个互斥锁。<code>std::lock_guard</code> 类是一个轻量级的 RAII（资源获取即初始化）封装类，用于管理互斥锁的上锁和解锁。</p>
<p>当定义 <code>std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</code> 时，构造函数会被调用，并且自动上锁 <code>m_mutex</code>。在 <code>lock_guard</code> 对象离开作用域时，析构函数会被调用，自动解锁 <code>m_mutex</code>。这样确保了在任何情况下都能正确地进行互斥锁的释放。</p>
<p>这种方式可以避免由于异常或代码中的早期返回而导致忘记手动解锁互斥锁的情况，从而更有效地编写线程安全的代码。</p>
<p>以下是一个简单示例，展示了如何使用 <code>std::lock_guard</code> 来保护一个临界区：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-29-1" name="__codelineno-29-1" href="#__codelineno-29-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>
<a id="__codelineno-29-2" name="__codelineno-29-2" href="#__codelineno-29-2"></a>
<a id="__codelineno-29-3" name="__codelineno-29-3" href="#__codelineno-29-3"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">m_mutex</span><span class="p">;</span>
<a id="__codelineno-29-4" name="__codelineno-29-4" href="#__codelineno-29-4"></a>
<a id="__codelineno-29-5" name="__codelineno-29-5" href="#__codelineno-29-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">criticalSection</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-29-6" name="__codelineno-29-6" href="#__codelineno-29-6"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
<a id="__codelineno-29-7" name="__codelineno-29-7" href="#__codelineno-29-7"></a>
<a id="__codelineno-29-8" name="__codelineno-29-8" href="#__codelineno-29-8"></a><span class="w">    </span><span class="c1">// 在这里执行需要保护的临界区代码</span>
<a id="__codelineno-29-9" name="__codelineno-29-9" href="#__codelineno-29-9"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-29-10" name="__codelineno-29-10" href="#__codelineno-29-10"></a>
<a id="__codelineno-29-11" name="__codelineno-29-11" href="#__codelineno-29-11"></a><span class="p">}</span><span class="w"> </span><span class="c1">// lock_guard 的析构函数在这里自动解锁互斥锁</span>
</code></pre></div>
<p>在上述示例中，<code>criticalSection()</code> 函数定义了一个临界区，在进入临界区之前使用 <code>std::lock_guard</code> 对 <code>m_mutex</code> 进行了上锁。当 <code>criticalSection()</code> 函数执行完毕时，<code>lock_guard</code> 的析构函数会自动解锁 <code>m_mutex</code>。</p>
<p>通过使用 <code>std::lock_guard</code>，我们可以确保在任何情况下都能正确地管理互斥锁的上锁和解锁操作。</p>
<p>希望对您有所帮助！如果您还有其他问题，请随时提问。</p>
<h4 id="_12">匿名对象<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>C++中的匿名对象是指没有被命名或赋值给变量的临时对象。它们通常在表达式中使用，并且只在该表达式的作用域内存在。</p>
<p>匿名对象可以用于简化代码和对临时结果的处理。例如，在函数调用时，可以直接传递一个匿名对象作为参数，而无需显式定义一个变量来保存临时结果。另外，匿名对象还可以用于链式调用，如多个成员函数的连续调用。</p>
<p>然而，需要注意以下几点：</p>
<ol>
<li>
<p>生命周期：匿名对象的生命周期仅限于包含它的表达式的作用域。一旦该表达式结束，匿名对象将被销毁。</p>
</li>
<li>
<p>可读性和可维护性：由于匿名对象没有名称，所以在代码阅读和维护时可能会增加困难。因此，过多地使用匿名对象可能降低代码的可读性。</p>
</li>
<li>
<p>性能开销：如果一个匿名对象需要进行较为复杂的构造或析构操作，那么频繁创建和销毁匿名对象可能会带来一定的性能开销。在这种情况下，可以考虑使用命名对象来提高代码的可读性和性能。</p>
</li>
</ol>
<p>总结来说，C++中的匿名对象是没有被命名或赋值给变量的临时对象。它们主要用于简化代码和处理临时结果，但需要注意生命周期、可读性和性能开销等方面的考虑。正确使用匿名对象可以提高代码的简洁性和可维护性。</p>
<h4 id="stdlock_guard">std::lock_guard<a class="headerlink" href="#stdlock_guard" title="Permanent link">&para;</a></h4>
<p><code>std::lock_guard</code> 是 C++ 标准库中的一个模板类，用于在作用域内自动管理互斥锁。</p>
<p>它是基于 RAII（Resource Acquisition Is Initialization）原则设计的，即资源获取即初始化。<code>std::lock_guard</code> 的主要作用是在构造时获取互斥锁，并在析构时释放互斥锁，确保在任何情况下都能正确释放锁。</p>
<p>下面是使用 <code>std::lock_guard</code> 的示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-30-1" name="__codelineno-30-1" href="#__codelineno-30-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>
<a id="__codelineno-30-2" name="__codelineno-30-2" href="#__codelineno-30-2"></a>
<a id="__codelineno-30-3" name="__codelineno-30-3" href="#__codelineno-30-3"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<a id="__codelineno-30-4" name="__codelineno-30-4" href="#__codelineno-30-4"></a>
<a id="__codelineno-30-5" name="__codelineno-30-5" href="#__codelineno-30-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-30-6" name="__codelineno-30-6" href="#__codelineno-30-6"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="w"> </span><span class="c1">// 在这里获取互斥锁</span>
<a id="__codelineno-30-7" name="__codelineno-30-7" href="#__codelineno-30-7"></a>
<a id="__codelineno-30-8" name="__codelineno-30-8" href="#__codelineno-30-8"></a><span class="w">    </span><span class="c1">// 临界区，执行需要互斥访问的代码块</span>
<a id="__codelineno-30-9" name="__codelineno-30-9" href="#__codelineno-30-9"></a><span class="w">    </span><span class="c1">// ...</span>
<a id="__codelineno-30-10" name="__codelineno-30-10" href="#__codelineno-30-10"></a>
<a id="__codelineno-30-11" name="__codelineno-30-11" href="#__codelineno-30-11"></a><span class="p">}</span><span class="w"> </span><span class="c1">// 在这里离开作用域，std::lock_guard 的析构函数会自动释放互斥锁</span>
</code></pre></div>
<p>通过创建 <code>std::lock_guard</code> 对象并传入互斥锁，可以确保在退出作用域时自动释放互斥锁，避免了手动调用 <code>unlock()</code> 的麻烦，并且保证了异常安全性，即使在发生异常的情况下也能正确释放锁。</p>
<p>请注意，<code>std::lock_guard</code> 是一种辅助工具，用于简化互斥锁的使用。如果需要更复杂的锁操作，可以考虑使用 <code>std::unique_lock</code> 或 <code>std::shared_lock</code>。</p>
<h4 id="boost_check">BOOST_CHECK<a class="headerlink" href="#boost_check" title="Permanent link">&para;</a></h4>
<p><code>BOOST_CHECK</code> 是 Boost.Test 库中的一个断言宏，用于判断给定条件是否为真。如果条件为真，则测试继续进行；如果条件为假，则测试失败并输出相应的错误信息。</p>
<h4 id="stdmove">std::move<a class="headerlink" href="#stdmove" title="Permanent link">&para;</a></h4>
<p><code>std::move</code>是C++标准库中的一个函数模板，位于 <code>&lt;utility&gt;</code> 头文件中，用于实现右值引用语义，将左值转换为对应的右值引用。它的作用是将对象的所有权从一个对象移动到另一个对象，而不进行内存拷贝或额外的资源分配。</p>
<p>具体来说，<code>std::move</code>的使用方式如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-31-1" name="__codelineno-31-1" href="#__codelineno-31-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-31-2" name="__codelineno-31-2" href="#__codelineno-31-2"></a><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
</code></pre></div>
<ul>
<li>
<p>参数 <code>arg</code>：转移所有权的对象。</p>
</li>
<li>
<p>返回值：右值引用类型，即将参数转换为对应的右值引用。</p>
</li>
</ul>
<p>以下是对 <code>std::move</code> 的详细解释和常见用法：</p>
<ol>
<li>
<p>转移语义（Move Semantics）：<code>std::move</code> 的主要目的是实现转移语义，通过将对象的资源所有权从一个对象转移到另一个对象，避免不必要的复制和资源分配，提高性能。</p>
</li>
<li>
<p>右值引用（Rvalue Reference）：<code>std::move</code> 将左值强制转换为右值引用。右值引用表示临时对象、匿名对象或即将销毁的对象。通过右值引用，可以调用移动构造函数或移动赋值操作符，实现高效的资源管理。</p>
</li>
<li>
<p>安全地交换对象：<code>std::move</code> 常用于容器类中的元素交换、移动语义的实现等场景。可以通过 <code>std::move</code> 将对象移动到容器或容器中的元素，避免不必要的复制和内存分配。</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-32-1" name="__codelineno-32-1" href="#__codelineno-32-1"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<a id="__codelineno-32-2" name="__codelineno-32-2" href="#__codelineno-32-2"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">destination</span><span class="p">;</span>
<a id="__codelineno-32-3" name="__codelineno-32-3" href="#__codelineno-32-3"></a>
<a id="__codelineno-32-4" name="__codelineno-32-4" href="#__codelineno-32-4"></a><span class="n">destination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将source的内容移动到destination，并清空source</span>
</code></pre></div>
<ol>
<li>注意事项：</li>
<li>使用 <code>std::move</code> 后，原来的对象处于有效但未定义的状态，不应再访问该对象。</li>
<li>被转移的对象，其资源所有权会被转移到目标对象，源对象不再拥有该资源。</li>
<li><code>std::move</code> 并不实际移动数据，它只是改变了对象的状态，告诉编译器使用右值引用。</li>
</ol>
<p>总结：<code>std::move</code> 是C++中实现转移语义的重要函数模板，通过将左值转换为对应的右值引用，实现高效的资源管理和对象交换。使用 <code>std::move</code> 可以显式地指定转移所有权，并提高代码的性能和效率。但需要注意的是，在使用 <code>std::move</code> 后，源对象的状态会发生改变，不应再对其进行访问。</p>
<h4 id="stdatomic">std::atomic<a class="headerlink" href="#stdatomic" title="Permanent link">&para;</a></h4>
<p><code>std::atomic</code> 是 C++ 标准库提供的模板类之一，位于 <code>&lt;atomic&gt;</code> 头文件中。它用于实现原子操作，提供了对共享变量的原子性访问和修改。</p>
<p><code>std::atomic</code> 类的主要功能有：</p>
<ol>
<li>原子加载（load）：使用 <code>load()</code> 成员函数可以原子地获取当前存储在 <code>std::atomic</code> 对象中的值。</li>
<li>原子存储（store）：使用 <code>store()</code> 成员函数可以原子地将指定的值存储到 <code>std::atomic</code> 对象中。</li>
<li>原子交换（exchange）：使用 <code>exchange()</code> 成员函数可以原子地将新值存储到 <code>std::atomic</code> 对象中，并返回之前的值。</li>
<li>原子比较和交换（compare-and-exchange）：使用 <code>compare_exchange_weak()</code> 或 <code>compare_exchange_strong()</code> 成员函数可以原子地比较 <code>std::atomic</code> 对象的值，并根据比较结果进行条件性的存储或交换操作。</li>
<li>原子算术操作：<code>std::atomic</code> 提供了一系列的成员函数，如 `fetch_add</li>
</ol>
<h4 id="stdany">std::any<a class="headerlink" href="#stdany" title="Permanent link">&para;</a></h4>
<p><code>std::any</code> 是 C++17 中引入的标准库类之一，位于 <code>&lt;any&gt;</code> 头文件中。它是一种类型安全的容器，可以存储任何可复制、可移动的类型。</p>
<p><code>std::any</code> 类的主要功能有：</p>
<ol>
<li>存储和访问任意类型的值：<code>std::any</code> 可以存储任何类型的值，包括内置类型、用户定义的类型和标准库类型等。它使用类型擦除的机制，可以在运行时存储和提取值，而不需要提前知道具体的类型。</li>
<li>类型安全的值提取：可以使用 <code>std::any_cast</code> 函数将存储在 <code>std::any</code> 中的值按照指定的类型进行提取，同时会进行类型检查，如果类型不匹配，则会抛出 <code>std::bad_any_cast</code> 异常。</li>
<li>支持空状态：<code>std::any</code> 在默认构造时是空的，可以通过赋值操作或者 <code>emplace</code> 成员函数来设置非空值，也可以通过 <code>reset</code> 成员函数将其重置为空状态。</li>
<li>支持复制和移动语义：<code>std::any</code> 可以通过复制构造函数和移动构造函数进行复制和移动操作，从一个 <code>std::any</code> 对象转移到另一个对象，并保持存储的值不变。</li>
</ol>
<p>使用 <code>std::any</code> 可以灵活地处理不确定的数据类型，特别适用于需要在运行时处理不同类型数据的情况，同时提供了类型安全的访问机制。例如，在实现通用容器、配置解析等场景中，可以使用 <code>std::any</code> 存储和操作各种类型的值。</p>
<h4 id="stdfunction">std::function<a class="headerlink" href="#stdfunction" title="Permanent link">&para;</a></h4>
<p><code>std::function</code> 是 C++ 标准库中的一个模板类，用于封装可调用对象（callable object），并提供一种统一的接口来处理不同类型的可调用实体。</p>
<p>通过 <code>std::function</code>，可以将函数、函数指针、成员函数、lambda 表达式等各种可调用实体存储到同一类型的对象中，并能够在需要时进行调用。它提供了一种灵活且类型安全的方式来操作可调用实体。</p>
<p>使用 <code>std::function</code> 的语法如下：
<div class="highlight"><pre><span></span><code><a id="__codelineno-33-1" name="__codelineno-33-1" href="#__codelineno-33-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<a id="__codelineno-33-2" name="__codelineno-33-2" href="#__codelineno-33-2"></a>
<a id="__codelineno-33-3" name="__codelineno-33-3" href="#__codelineno-33-3"></a><span class="c1">// 定义一个 std::function 对象</span>
<a id="__codelineno-33-4" name="__codelineno-33-4" href="#__codelineno-33-4"></a><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">返回类型</span><span class="p">(</span><span class="n">参数类型</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">;</span>
<a id="__codelineno-33-5" name="__codelineno-33-5" href="#__codelineno-33-5"></a>
<a id="__codelineno-33-6" name="__codelineno-33-6" href="#__codelineno-33-6"></a><span class="c1">// 绑定一个函数</span>
<a id="__codelineno-33-7" name="__codelineno-33-7" href="#__codelineno-33-7"></a><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">函数名</span><span class="p">;</span>
<a id="__codelineno-33-8" name="__codelineno-33-8" href="#__codelineno-33-8"></a>
<a id="__codelineno-33-9" name="__codelineno-33-9" href="#__codelineno-33-9"></a><span class="c1">// 绑定一个函数对象</span>
<a id="__codelineno-33-10" name="__codelineno-33-10" href="#__codelineno-33-10"></a><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">函数对象</span><span class="p">;</span>
<a id="__codelineno-33-11" name="__codelineno-33-11" href="#__codelineno-33-11"></a>
<a id="__codelineno-33-12" name="__codelineno-33-12" href="#__codelineno-33-12"></a><span class="c1">// 调用可调用实体</span>
<a id="__codelineno-33-13" name="__codelineno-33-13" href="#__codelineno-33-13"></a><span class="n">func</span><span class="p">(</span><span class="n">参数列表</span><span class="p">);</span>
</code></pre></div></p>
<p>其中，<code>返回类型</code> 是函数或函数对象的返回类型，<code>参数类型</code> 是函数或函数对象的参数类型。</p>
<p>通过 <code>std::function</code>，可以实现函数的传递、回调、事件处理等功能。它还支持函数对象之间的复制和赋值操作，使得代码更加灵活和可重用。</p>
<p>需要注意的是，<code>std::function</code> 对于函数的调用可能会引入一定的开销，但在大多数情况下这种开销可以忽略不计。此外，<code>std::function</code> 不能存储非静态的成员变量指针，只能存储成员函数或静态成员函数。</p>
<h4 id="stdbind">std::bind<a class="headerlink" href="#stdbind" title="Permanent link">&para;</a></h4>
<p><code>std::bind</code> 是 C++ 标准库中的一个函数模板，用于创建一个可调用对象（callable object），将参数绑定到特定的函数或成员函数上。</p>
<p>通过 <code>std::bind</code>，可以实现对函数或成员函数进行参数绑定、占位符替换和部分应用等操作，以生成新的可调用对象。这样可以延迟函数的调用，并在需要时提供参数。</p>
<p>使用 <code>std::bind</code> 的语法如下：
<div class="highlight"><pre><span></span><code><a id="__codelineno-34-1" name="__codelineno-34-1" href="#__codelineno-34-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<a id="__codelineno-34-2" name="__codelineno-34-2" href="#__codelineno-34-2"></a>
<a id="__codelineno-34-3" name="__codelineno-34-3" href="#__codelineno-34-3"></a><span class="c1">// 绑定一个函数</span>
<a id="__codelineno-34-4" name="__codelineno-34-4" href="#__codelineno-34-4"></a><span class="k">auto</span><span class="w"> </span><span class="n">boundFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">函数名</span><span class="p">,</span><span class="w"> </span><span class="n">参数1</span><span class="p">,</span><span class="w"> </span><span class="n">参数2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<a id="__codelineno-34-5" name="__codelineno-34-5" href="#__codelineno-34-5"></a>
<a id="__codelineno-34-6" name="__codelineno-34-6" href="#__codelineno-34-6"></a><span class="c1">// 绑定成员函数</span>
<a id="__codelineno-34-7" name="__codelineno-34-7" href="#__codelineno-34-7"></a><span class="k">auto</span><span class="w"> </span><span class="n">boundMemberFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">类名</span><span class="o">::</span><span class="n">成员函数名</span><span class="p">,</span><span class="w"> </span><span class="n">对象指针</span><span class="p">,</span><span class="w"> </span><span class="n">参数1</span><span class="p">,</span><span class="w"> </span><span class="n">参数2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<a id="__codelineno-34-8" name="__codelineno-34-8" href="#__codelineno-34-8"></a>
<a id="__codelineno-34-9" name="__codelineno-34-9" href="#__codelineno-34-9"></a><span class="c1">// 使用占位符进行参数绑定</span>
<a id="__codelineno-34-10" name="__codelineno-34-10" href="#__codelineno-34-10"></a><span class="k">auto</span><span class="w"> </span><span class="n">boundFuncWithPlaceholder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">函数名</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
</code></pre></div></p>
<p>其中，<code>函数名</code> 是要绑定的函数或成员函数的名称，<code>参数1, 参数2, ...</code> 是要绑定的参数。对于成员函数，需要提供对象指针作为第一个参数。</p>
<p>通过 <code>std::bind</code> 绑定的可调用对象可以像普通函数一样进行调用，并根据绑定的参数来执行相应的操作。</p>
<p>除了参数绑定，<code>std::bind</code> 还支持占位符（placeholder）的使用。占位符使用 <code>std::placeholders::_N</code> 表示，其中 N 是参数的位置索引。通过占位符，可以在调用时提供缺失的参数，并将其绑定到正确的位置。</p>
<p>需要注意的是，<code>std::bind</code> 可以实现函数的柯里化（currying）和部分应用（partial application），以及对参数排序和重排等操作。它提供了更灵活的方式来处理函数对象，并可以用于实现回调、事件处理等功能。</p>
<p>然而，C++11 引入了 lambda 表达式，它提供了更简洁和直观的语法来处理函数对象和参数绑定的需求。在现代 C++ 中，通常推荐使用 lambda 表达式而不是 <code>std::bind</code>。</p>
<h4 id="stdatomic_int">std::atomic_int<a class="headerlink" href="#stdatomic_int" title="Permanent link">&para;</a></h4>
<p><code>std::atomic_int</code> 是 C++ 标准库中的一个原子类型，用于实现多线程环境下的原子操作。</p>
<p>原子操作是指在并发环境中不会被其他线程中断的操作。<code>std::atomic_int</code> 类型提供了一种线程安全的方式来使用整数类型变量（int），保证对该变量的读取和写入操作具有原子性。</p>
<p>通过 <code>std::atomic_int</code>，你可以进行原子的读取、写入、交换、自增/自减、比较与交换等操作。这些操作都能够确保在多线程环境下不会出现数据竞争或不一致的情况。</p>
<p>使用 <code>std::atomic_int</code> 的语法如下：
<div class="highlight"><pre><span></span><code><a id="__codelineno-35-1" name="__codelineno-35-1" href="#__codelineno-35-1"></a><span class="n">std</span><span class="o">::</span><span class="kt">atomic_int</span><span class="w"> </span><span class="n">myAtomicInt</span><span class="p">;</span><span class="w"> </span><span class="c1">// 声明一个 std::atomic_int 类型的变量</span>
<a id="__codelineno-35-2" name="__codelineno-35-2" href="#__codelineno-35-2"></a>
<a id="__codelineno-35-3" name="__codelineno-35-3" href="#__codelineno-35-3"></a><span class="n">myAtomicInt</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"> </span><span class="c1">// 存储值为 42</span>
<a id="__codelineno-35-4" name="__codelineno-35-4" href="#__codelineno-35-4"></a><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myAtomicInt</span><span class="p">.</span><span class="n">load</span><span class="p">();</span><span class="w"> </span><span class="c1">// 加载当前值</span>
<a id="__codelineno-35-5" name="__codelineno-35-5" href="#__codelineno-35-5"></a>
<a id="__codelineno-35-6" name="__codelineno-35-6" href="#__codelineno-35-6"></a><span class="n">myAtomicInt</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 原子地将当前值加 1</span>
</code></pre></div></p>
<p>需要注意的是，<code>std::atomic_int</code> 类型只适用于基本整数类型，例如 int、unsigned int、short 等等。如果需要原子操作其他类型的对象，可以使用 <code>std::atomic</code> 模板，并在模板参数中指定相应的类型。</p>
<h4 id="syscallsys_gettid">syscall(SYS_gettid)<a class="headerlink" href="#syscallsys_gettid" title="Permanent link">&para;</a></h4>
<p><code>syscall(SYS_gettid)</code> 是一个系统调用，用于获取当前线程的线程ID（Thread ID）。</p>
<p>在Linux系统中，每个线程都具有唯一的线程ID，可以通过 <code>syscall(SYS_gettid)</code> 来获取当前线程的线程ID。<code>SYS_gettid</code> 是一个宏定义，表示获取线程ID的系统调用号。</p>
<p>使用 <code>syscall(SYS_gettid)</code> 时需要包含头文件 <code>&lt;sys/syscall.h&gt;</code>。该调用返回一个整数值，表示当前线程的线程ID。</p>
<p>需要注意的是，<code>syscall()</code> 函数是一个底层的系统调用接口，直接调用底层的系统调用而不经过C库的封装。在一般情况下，我们更倾向于使用标准的C库函数或C++标准库提供的接口来进行线程相关的操作，如 <code>pthread_self()</code> 函数来获取线程ID。</p>
<h4 id="linuxusrlocalincludeusrlocallibusrincludeusrlib">linux下/usr/local/include、/usr/local/lib和/usr/include、/usr/lib的区别<a class="headerlink" href="#linuxusrlocalincludeusrlocallibusrincludeusrlib" title="Permanent link">&para;</a></h4>
<p><code>/usr/local/include</code> 和 <code>/usr/local/lib</code> 目录通常用于存放本地安装的软件的头文件和库文件，而 <code>/usr/include</code> 和 <code>/usr/lib</code> 目录则是系统默认的头文件和库文件的存放位置。</p>
<ol>
<li>
<p><code>/usr/local/include</code>：这个目录是用来存放本地安装的软件的头文件的。当你手动编译和安装某个软件时，它的头文件通常会被安装到 <code>/usr/local/include</code> 目录下。这样做的好处是可以将本地安装的软件与系统默认的软件区分开来，避免冲突。</p>
</li>
<li>
<p><code>/usr/local/lib</code>：这个目录是用来存放本地安装的软件的库文件的。当你手动编译和安装某个软件时，它的库文件通常会被安装到 <code>/usr/local/lib</code> 目录下。同样地，这样做可以将本地安装的库文件与系统默认的库文件区分开来。</p>
</li>
<li>
<p><code>/usr/include</code>：这个目录是系统默认的头文件的存放位置。它包含了系统提供的标准库的头文件以及其他系统级别的头文件。当你编译系统默认提供的库时，编译器会在 <code>/usr/include</code> 目录中查找相应的头文件。</p>
</li>
<li>
<p><code>/usr/lib</code>：这个目录是系统默认的库文件的存放位置。它包含了系统提供的标准库以及其他系统级别的库文件。当你链接系统默认提供的库时，链接器会在 <code>/usr/lib</code> 目录中查找相应的库文件。</p>
</li>
</ol>
<p>总结起来，<code>/usr/local/include</code> 和 <code>/usr/local/lib</code> 目录是用于存放本地安装的软件的头文件和库文件，而 <code>/usr/include</code> 和 <code>/usr/lib</code> 目录是系统默认的头文件和库文件的存放位置。这种分离可以帮助你管理本地安装的软件和系统默认的软件，并避免冲突。</p>
<h4 id="__builtin_expect_1">__builtin_expect<a class="headerlink" href="#__builtin_expect_1" title="Permanent link">&para;</a></h4>
<p><code>__builtin_expect</code> 是一个内置函数，用于给编译器提示条件表达式的预期结果，以便优化生成的代码。它的形式如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-36-1" name="__codelineno-36-1" href="#__codelineno-36-1"></a><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span><span class="w"> </span><span class="n">expected_value</span><span class="p">)</span>
</code></pre></div>
<p>在这段代码中，<code>__builtin_expect(t_cachedTid == 0, 0)</code> 表示条件表达式 <code>t_cachedTid == 0</code> 的预期结果是 0。这个提示告诉编译器，条件 <code>t_cachedTid == 0</code> 很可能为假，以便编译器进行相应的优化。</p>
<p>通过使用 <code>__builtin_expect</code>，编译器可以根据预期结果对代码进行优化，使得更有可能的分支更容易被预测，从而提高代码的执行效率。在这个特定的例子中，条件表达式 <code>t_cachedTid == 0</code> 的预期结果为假（0），因此编译器可能会优化条件判断的分支，使得条件为假时的代码更容易被执行。这样可以提高程序的性能，特别是在条件判断的分支频繁发生且有明显的倾向性时。</p>
<p>需要注意的是，<code>__builtin_expect</code> 只是给编译器提供了一种提示，具体的优化效果还取决于编译器的实现。不同的编译器可能对 <code>__builtin_expect</code> 的处理方式有所不同。</p>
<h4 id="_13">类里纯虚函数<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，纯虚函数是在基类中声明但没有实现的虚函数。它通过在函数声明的末尾使用 "= 0" 来表示。</p>
<p>纯虚函数的作用是为了将基类定义为一个抽象类，它只用于作为其他具体派生类的接口定义，而不能直接实例化。抽象类是一种不能创建对象的类，它只能被用作其他类的基类。</p>
<p>通过在基类中定义纯虚函数，可以强制要求派生类必须实现这个函数。派生类必须提供纯虚函数的具体实现，否则它也会成为一个抽象类，无法实例化。</p>
<p>纯虚函数可以被派生类重写，提供具体的实现。这样，通过基类指针或引用可以调用派生类的纯虚函数，实现多态的行为。</p>
<p>以下是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-37-1" name="__codelineno-37-1" href="#__codelineno-37-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-37-2" name="__codelineno-37-2" href="#__codelineno-37-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-37-3" name="__codelineno-37-3" href="#__codelineno-37-3"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">pureVirtualFunction</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 纯虚函数</span>
<a id="__codelineno-37-4" name="__codelineno-37-4" href="#__codelineno-37-4"></a><span class="p">};</span>
<a id="__codelineno-37-5" name="__codelineno-37-5" href="#__codelineno-37-5"></a>
<a id="__codelineno-37-6" name="__codelineno-37-6" href="#__codelineno-37-6"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-37-7" name="__codelineno-37-7" href="#__codelineno-37-7"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-37-8" name="__codelineno-37-8" href="#__codelineno-37-8"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">pureVirtualFunction</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-37-9" name="__codelineno-37-9" href="#__codelineno-37-9"></a><span class="w">        </span><span class="c1">// 派生类提供的具体实现</span>
<a id="__codelineno-37-10" name="__codelineno-37-10" href="#__codelineno-37-10"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-37-11" name="__codelineno-37-11" href="#__codelineno-37-11"></a><span class="p">};</span>
<a id="__codelineno-37-12" name="__codelineno-37-12" href="#__codelineno-37-12"></a>
<a id="__codelineno-37-13" name="__codelineno-37-13" href="#__codelineno-37-13"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-37-14" name="__codelineno-37-14" href="#__codelineno-37-14"></a><span class="w">    </span><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Derived</span><span class="p">();</span>
<a id="__codelineno-37-15" name="__codelineno-37-15" href="#__codelineno-37-15"></a><span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">pureVirtualFunction</span><span class="p">();</span><span class="w">  </span><span class="c1">// 通过基类指针调用派生类的纯虚函数</span>
<a id="__codelineno-37-16" name="__codelineno-37-16" href="#__codelineno-37-16"></a><span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<a id="__codelineno-37-17" name="__codelineno-37-17" href="#__codelineno-37-17"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-37-18" name="__codelineno-37-18" href="#__codelineno-37-18"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的示例中，基类 <code>Base</code> 定义了一个纯虚函数 <code>pureVirtualFunction()</code>，派生类 <code>Derived</code> 重写了这个函数并提供了具体的实现。在 <code>main()</code> 函数中，通过基类指针 <code>ptr</code> 创建了一个派生类对象，并通过指针调用了纯虚函数。</p>
<p>纯虚函数的存在使得基类成为一个抽象类，它只用于定义接口，并提供了一种规范让派生类必须实现特定的功能。这种设计可以帮助实现多态性、代码的可扩展性和可维护性。</p>
<h4 id="_14">虚析构函数<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，当一个类被设计为作为基类使用，并且可能会被其他类通过指针或引用来操作时，通常需要在该类中定义一个虚析构函数。</p>
<p>虚析构函数在基类中的作用是确保在通过基类指针或引用删除派生类对象时，能够正确调用派生类的析构函数。如果基类的析构函数不是虚函数，那么当通过基类指针或引用删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类中的资源没有得到正确释放，造成内存泄漏或其他问题。</p>
<p>通过在基类中定义虚析构函数，可以实现多态的析构行为。当通过基类指针或引用删除派生类对象时，会首先调用派生类的析构函数，然后再调用基类的析构函数。这样可以确保派生类中的资源得到正确释放，同时避免内存泄漏和未定义行为。</p>
<p>以下是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-38-1" name="__codelineno-38-1" href="#__codelineno-38-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-38-2" name="__codelineno-38-2" href="#__codelineno-38-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-38-3" name="__codelineno-38-3" href="#__codelineno-38-3"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-38-4" name="__codelineno-38-4" href="#__codelineno-38-4"></a><span class="w">        </span><span class="c1">// 基类析构函数</span>
<a id="__codelineno-38-5" name="__codelineno-38-5" href="#__codelineno-38-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-38-6" name="__codelineno-38-6" href="#__codelineno-38-6"></a><span class="p">};</span>
<a id="__codelineno-38-7" name="__codelineno-38-7" href="#__codelineno-38-7"></a>
<a id="__codelineno-38-8" name="__codelineno-38-8" href="#__codelineno-38-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-38-9" name="__codelineno-38-9" href="#__codelineno-38-9"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-38-10" name="__codelineno-38-10" href="#__codelineno-38-10"></a><span class="w">    </span><span class="o">~</span><span class="n">Derived</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-38-11" name="__codelineno-38-11" href="#__codelineno-38-11"></a><span class="w">        </span><span class="c1">// 派生类析构函数</span>
<a id="__codelineno-38-12" name="__codelineno-38-12" href="#__codelineno-38-12"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-38-13" name="__codelineno-38-13" href="#__codelineno-38-13"></a><span class="p">};</span>
<a id="__codelineno-38-14" name="__codelineno-38-14" href="#__codelineno-38-14"></a>
<a id="__codelineno-38-15" name="__codelineno-38-15" href="#__codelineno-38-15"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-38-16" name="__codelineno-38-16" href="#__codelineno-38-16"></a><span class="w">    </span><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Derived</span><span class="p">();</span>
<a id="__codelineno-38-17" name="__codelineno-38-17" href="#__codelineno-38-17"></a><span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 通过基类指针删除派生类对象</span>
<a id="__codelineno-38-18" name="__codelineno-38-18" href="#__codelineno-38-18"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-38-19" name="__codelineno-38-19" href="#__codelineno-38-19"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的示例中，基类 <code>Base</code> 定义了一个虚析构函数 <code>~Base()</code>，派生类 <code>Derived</code> 重写了析构函数 <code>~Derived()</code>。在 <code>main()</code> 函数中，通过基类指针 <code>ptr</code> 创建了一个派生类对象，并使用 <code>delete</code> 删除该对象。由于基类的析构函数是虚函数，所以会首先调用派生类的析构函数 <code>~Derived()</code>，然后再调用基类的析构函数 <code>~Base()</code>。</p>
<p>通过定义虚析构函数，可以正确释放派生类对象中的资源，确保程序的行为符合预期并避免潜在的问题。</p>
<h4 id="stdweak_ptr">std::weak_ptr<a class="headerlink" href="#stdweak_ptr" title="Permanent link">&para;</a></h4>
<p><code>std::weak_ptr&lt;void&gt;</code> 是一个弱引用指针，它可以用于跟踪一个被 <code>std::shared_ptr</code> 管理的对象，但不会增加对象的引用计数。由于 <code>std::weak_ptr</code> 是一个通用的模板类，它可以用于跟踪任何类型的对象。</p>
<p>在您提供的代码中，<code>tie_</code> 被声明为一个 <code>std::weak_ptr&lt;void&gt;</code> 类型的变量。这意味着 <code>tie_</code> 可以用于跟踪一个 <code>void</code> 类型的对象，或者跟踪任何类型的对象，因为 <code>void</code> 是一个通用的类型。</p>
<p>使用 <code>std::weak_ptr</code> 可以解决一些潜在的问题，例如循环引用。它允许您在需要时访问被 <code>std::shared_ptr</code> 管理的对象，但不会阻止对象的销毁。</p>
<p>请注意，由于 <code>std::weak_ptr</code> 是一个弱引用，如果被跟踪的对象已经被销毁，那么使用 <code>std::weak_ptr</code> 访问对象会返回一个空指针。</p>
<h4 id="_">变量名命名加_<a class="headerlink" href="#_" title="Permanent link">&para;</a></h4>
<p>系统库里的变量是_在前，_变量名</p>
<p>所以自建库里一般用 变量名_，防止冲突</p>
<h4 id="_15">变量作用域<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<p>命名空间最好都加上，防止污染</p>
<p>很多错误经常是没加上作用域导致的</p>
<h4 id="c">C++绑定器<a class="headerlink" href="#c" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，绑定器（Binder）是一种将函数与其参数部分绑定在一起创建新函数的机制。通过绑定器，我们可以创建一个新的函数对象，该对象包含了原始函数的部分参数。绑定器可以用于延迟函数调用、固定函数参数、改变函数签名等场景。</p>
<p>C++ 标准库中提供了 <code>std::bind</code> 函数，用于创建绑定器。<code>std::bind</code> 函数的基本语法如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-39-1" name="__codelineno-39-1" href="#__codelineno-39-1"></a><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</code></pre></div>
<p>其中，<code>Function</code> 是被绑定的函数，<code>Arg1, Arg2, ...</code> 是需要绑定的参数。绑定器将返回一个新的函数对象，该对象可以像普通函数一样调用。</p>
<p>下面是一个简单的示例，演示如何使用 <code>std::bind</code> 创建绑定器：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-40-1" name="__codelineno-40-1" href="#__codelineno-40-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-40-2" name="__codelineno-40-2" href="#__codelineno-40-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<a id="__codelineno-40-3" name="__codelineno-40-3" href="#__codelineno-40-3"></a>
<a id="__codelineno-40-4" name="__codelineno-40-4" href="#__codelineno-40-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-40-5" name="__codelineno-40-5" href="#__codelineno-40-5"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a + b = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-40-6" name="__codelineno-40-6" href="#__codelineno-40-6"></a><span class="p">}</span>
<a id="__codelineno-40-7" name="__codelineno-40-7" href="#__codelineno-40-7"></a>
<a id="__codelineno-40-8" name="__codelineno-40-8" href="#__codelineno-40-8"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-40-9" name="__codelineno-40-9" href="#__codelineno-40-9"></a><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">boundFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<a id="__codelineno-40-10" name="__codelineno-40-10" href="#__codelineno-40-10"></a><span class="w">    </span><span class="n">boundFunc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// 输出：a + b = 30</span>
<a id="__codelineno-40-11" name="__codelineno-40-11" href="#__codelineno-40-11"></a>
<a id="__codelineno-40-12" name="__codelineno-40-12" href="#__codelineno-40-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-40-13" name="__codelineno-40-13" href="#__codelineno-40-13"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的示例中，我们使用 <code>std::bind</code> 创建了一个绑定器 <code>boundFunc</code>，将 <code>foo</code> 函数的第一个参数绑定为 10，第二个参数使用占位符 <code>std::placeholders::_1</code> 表示在调用时传入。然后，我们通过调用 <code>boundFunc</code> 来执行绑定的函数调用。</p>
<p>绑定器还可以用于绑定成员函数、函数对象、函数指针等。通过灵活使用绑定器，我们可以实现更加灵活和可复用的函数调用方式。</p>
<h4 id="c_str">.c_str()<a class="headerlink" href="#c_str" title="Permanent link">&para;</a></h4>
<p>在C++中，<code>.c_str()</code> 是一个字符串成员函数，用于返回一个指向以 null 结尾的字符数组（C 风格字符串）的指针。它通常用于将 C++ 的 <code>std::string</code> 对象转换为 C 风格字符串。</p>
<p><code>std::string</code> 是 C++ 标准库中提供的字符串类，它提供了许多方便的操作和功能。然而，在某些情况下，你可能需要将 <code>std::string</code> 对象传递给接受 C 风格字符串的函数或库。这时，你可以使用 <code>.c_str()</code> 函数来获取一个以 null 结尾的字符数组。</p>
<p>例如，假设你有一个 <code>std::string</code> 对象 <code>str</code>，你可以通过调用 <code>str.c_str()</code> 来获取一个指向以 null 结尾的字符数组的指针。然后，你可以将该指针传递给需要 C 风格字符串的函数或库。</p>
<p>需要注意的是，返回的字符数组指针指向 <code>std::string</code> 对象内部的字符数据，因此在 <code>std::string</code> 对象被销毁之前，该指针是有效的。如果你需要在 <code>std::string</code> 对象被销毁后继续使用该字符数组，你需要将其复制到另一个字符数组中。</p>
<h4 id="_16">函数对象和函数<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<p>在C++中，函数和函数对象（也称为函数符）之间有一些区别。</p>
<ol>
<li>
<p>函数是一段可执行的代码，用于执行特定的任务。函数可以通过函数名直接调用，例如：
<div class="highlight"><pre><span></span><code><a id="__codelineno-41-1" name="__codelineno-41-1" href="#__codelineno-41-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-41-2" name="__codelineno-41-2" href="#__codelineno-41-2"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-41-3" name="__codelineno-41-3" href="#__codelineno-41-3"></a><span class="p">}</span>
<a id="__codelineno-41-4" name="__codelineno-41-4" href="#__codelineno-41-4"></a>
<a id="__codelineno-41-5" name="__codelineno-41-5" href="#__codelineno-41-5"></a><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">  </span><span class="c1">// 调用函数</span>
</code></pre></div></p>
</li>
<li>
<p>函数对象是一种特殊类型的对象，它可以像函数一样被调用。在C++中，函数对象通常通过函数符（函数调用运算符<code>()</code>的重载）来实现。函数对象可以具有状态，并且可以在调用之间保留数据。例如：
<div class="highlight"><pre><span></span><code><a id="__codelineno-42-1" name="__codelineno-42-1" href="#__codelineno-42-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">Add</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-42-2" name="__codelineno-42-2" href="#__codelineno-42-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-42-3" name="__codelineno-42-3" href="#__codelineno-42-3"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-42-4" name="__codelineno-42-4" href="#__codelineno-42-4"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-42-5" name="__codelineno-42-5" href="#__codelineno-42-5"></a><span class="p">};</span>
<a id="__codelineno-42-6" name="__codelineno-42-6" href="#__codelineno-42-6"></a>
<a id="__codelineno-42-7" name="__codelineno-42-7" href="#__codelineno-42-7"></a><span class="n">Add</span><span class="w"> </span><span class="n">add_obj</span><span class="p">;</span>
<a id="__codelineno-42-8" name="__codelineno-42-8" href="#__codelineno-42-8"></a><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_obj</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">  </span><span class="c1">// 调用函数对象</span>
</code></pre></div>
在上面的示例中，<code>Add</code>是一个函数对象，它重载了函数调用运算符<code>()</code>，使得<code>add_obj</code>可以像函数一样被调用。</p>
</li>
</ol>
<p>总结：
- 函数是一段可执行的代码，用于执行特定任务。
- 函数对象是一种特殊类型的对象，它可以像函数一样被调用，通常通过函数符（函数调用运算符<code>()</code>）来实现。</p>
<p>需要注意的是，C++中的函数对象提供了更大的灵活性，因为它们可以具有状态和成员变量。此外，函数对象还可以作为参数传递给其他函数，从而实现更高级的编程模式，如函数式编程和泛型编程。</p>
<h4 id="stdis_trivially_destructible">std::is_trivially_destructible<a class="headerlink" href="#stdis_trivially_destructible" title="Permanent link">&para;</a></h4>
<p><code>std::is_trivially_destructible</code> 是 C++ 标准库 <code>&lt;type_traits&gt;</code> 头文件中定义的类型特征（type trait）。它用于判断一个类型是否是平凡可销毁的（trivially destructible）。</p>
<p>平凡可销毁的类型是指其析构函数是空操作且没有任何副作用的类型。换句话说，可以安全地销毁该对象而无需进行任何显式的清理或资源管理。</p>
<p><code>std::is_trivially_destructible</code> 特征是一个在编译时确定的常量，如果给定类型是平凡可销毁的，则其值为 <code>true</code>，否则为 <code>false</code>。它可以根据类型的销毁性质有条件地启用或禁用某些代码优化或行为。</p>
<p>以下是一个示例用法：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-43-1" name="__codelineno-43-1" href="#__codelineno-43-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-43-2" name="__codelineno-43-2" href="#__codelineno-43-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<a id="__codelineno-43-3" name="__codelineno-43-3" href="#__codelineno-43-3"></a>
<a id="__codelineno-43-4" name="__codelineno-43-4" href="#__codelineno-43-4"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-43-5" name="__codelineno-43-5" href="#__codelineno-43-5"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<a id="__codelineno-43-6" name="__codelineno-43-6" href="#__codelineno-43-6"></a><span class="w">    </span><span class="o">~</span><span class="n">MyType</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;析构函数被调用</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<a id="__codelineno-43-7" name="__codelineno-43-7" href="#__codelineno-43-7"></a><span class="p">};</span>
<a id="__codelineno-43-8" name="__codelineno-43-8" href="#__codelineno-43-8"></a>
<a id="__codelineno-43-9" name="__codelineno-43-9" href="#__codelineno-43-9"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-43-10" name="__codelineno-43-10" href="#__codelineno-43-10"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
<a id="__codelineno-43-11" name="__codelineno-43-11" href="#__codelineno-43-11"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;MyType 是否是平凡可销毁的？&quot;</span>
<a id="__codelineno-43-12" name="__codelineno-43-12" href="#__codelineno-43-12"></a><span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">MyType</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<a id="__codelineno-43-13" name="__codelineno-43-13" href="#__codelineno-43-13"></a>
<a id="__codelineno-43-14" name="__codelineno-43-14" href="#__codelineno-43-14"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-43-15" name="__codelineno-43-15" href="#__codelineno-43-15"></a><span class="p">}</span>
</code></pre></div>
<p>在这个示例中，输出将是：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-44-1" name="__codelineno-44-1" href="#__codelineno-44-1"></a>MyType 是否是平凡可销毁的？false
</code></pre></div>
<p>由于 <code>MyType</code> 的析构函数具有副作用（打印一条消息），它不是平凡可销毁的。</p>
<h4 id="trivial-destructor">trivial destructor平凡析构函数<a class="headerlink" href="#trivial-destructor" title="Permanent link">&para;</a></h4>
<p>在C++中，根据C++标准（C++ Standard），一个类的析构函数（Destructor）被称为"trivial destructor"（平凡析构函数），如果满足以下条件之一：</p>
<ol>
<li>类没有虚函数（virtual function）和虚基类（virtual base class）。</li>
<li>类的基类（base class）也有平凡析构函数并且是非虚的。</li>
<li>类的所有非静态数据成员（non-static data members）也都有平凡析构函数。</li>
</ol>
<p>当一个类的析构函数被认为是平凡的，意味着它不需要执行任何特殊的清理操作。编译器会自动生成一个默认的平凡析构函数，它会自动调用类的成员对象的析构函数，并释放类的内存。</p>
<p>平凡析构函数的存在可以对编译器进行优化，例如在某些情况下可以进行内存布局的优化，或者在数组和容器等数据结构中进行快速的析构操作。</p>
<p>需要注意的是，当类的析构函数不满足上述条件时，它将被认为是非平凡的（non-trivial），可能需要执行额外的清理操作，如释放资源、销毁对象等。非平凡析构函数需要由程序员显式定义和实现。</p>
<p>总结起来，C++中的平凡析构函数（trivial destructor）是指满足一定条件的类的析构函数，它不需要执行特殊的清理操作，并由编译器自动生成。这些条件包括类没有虚函数、虚基类和非静态数据成员都有平凡析构函数。非平凡析构函数则需要程序员显式定义和实现，并可能执行额外的清理操作。</p>
<h4 id="_17">内存地址是按字节进行编码的<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>在大多数情况下，内存地址+1表示增加一个字节的大小。</p>
<p>内存地址是以字节为单位进行编址的，每个字节对应一个唯一的内存地址。因此，对一个内存地址进行加1操作，通常会使其指向下一个相邻的字节。</p>
<p>然而，需要注意的是，指针的自增操作并不一定严格等同于增加一个字节。指针的自增操作会根据指针所指向的数据类型的大小来进行增加。例如，对一个<code>char*</code>类型的指针进行自增操作，会使指针增加一个字节；而对一个<code>int*</code>类型的指针进行自增操作，会使指针增加四个字节（32位系统）或八个字节（64位系统）。</p>
<p>因此，当我们说内存地址+1表示增加一个字节的大小时，是基于通常情况下的假设，即指针的类型为<code>char*</code>或者我们希望以字节为单位进行地址操作。具体情况仍取决于指针的类型和所指向的数据类型的大小。</p>
<h4 id="c_1">C++函数什么时候传入参数用&amp;<a class="headerlink" href="#c_1" title="Permanent link">&para;</a></h4>
<p>在 C++ 函数中，传递参数时使用 <code>&amp;</code> 的主要情况是为了实现引用传递（Pass-by-Reference），而不是传递参数的副本。以下是一些常见的情况：</p>
<ol>
<li>修改函数外部变量：
   如果希望在函数内部修改函数外部的变量，并且避免进行参数的复制，可以使用引用传递。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-45-1" name="__codelineno-45-1" href="#__codelineno-45-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-45-2" name="__codelineno-45-2" href="#__codelineno-45-2"></a><span class="w">  </span><span class="n">num</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 修改函数外部的变量</span>
<a id="__codelineno-45-3" name="__codelineno-45-3" href="#__codelineno-45-3"></a><span class="p">}</span>
<a id="__codelineno-45-4" name="__codelineno-45-4" href="#__codelineno-45-4"></a>
<a id="__codelineno-45-5" name="__codelineno-45-5" href="#__codelineno-45-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-45-6" name="__codelineno-45-6" href="#__codelineno-45-6"></a><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<a id="__codelineno-45-7" name="__codelineno-45-7" href="#__codelineno-45-7"></a><span class="w">  </span><span class="n">increment</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过引用传递参数</span>
<a id="__codelineno-45-8" name="__codelineno-45-8" href="#__codelineno-45-8"></a><span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="c1">// 输出 6</span>
<a id="__codelineno-45-9" name="__codelineno-45-9" href="#__codelineno-45-9"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-45-10" name="__codelineno-45-10" href="#__codelineno-45-10"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li>避免大对象复制：
   当传递一个大的对象作为函数参数时，如果不希望发生对象的拷贝构造，可以使用引用传递来避免额外的开销。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-46-1" name="__codelineno-46-1" href="#__codelineno-46-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">processObject</span><span class="p">(</span><span class="n">Object</span><span class="o">&amp;</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-46-2" name="__codelineno-46-2" href="#__codelineno-46-2"></a><span class="w">  </span><span class="c1">// 对 obj 进行操作</span>
<a id="__codelineno-46-3" name="__codelineno-46-3" href="#__codelineno-46-3"></a><span class="p">}</span>
<a id="__codelineno-46-4" name="__codelineno-46-4" href="#__codelineno-46-4"></a>
<a id="__codelineno-46-5" name="__codelineno-46-5" href="#__codelineno-46-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-46-6" name="__codelineno-46-6" href="#__codelineno-46-6"></a><span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"> </span><span class="c1">// 假设 Object 是一个大的对象类型</span>
<a id="__codelineno-46-7" name="__codelineno-46-7" href="#__codelineno-46-7"></a><span class="w">  </span><span class="n">processObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过引用传递大对象</span>
<a id="__codelineno-46-8" name="__codelineno-46-8" href="#__codelineno-46-8"></a><span class="w">  </span><span class="c1">// ...</span>
<a id="__codelineno-46-9" name="__codelineno-46-9" href="#__codelineno-46-9"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-46-10" name="__codelineno-46-10" href="#__codelineno-46-10"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li>返回多个值：
   在 C++ 中，函数只能返回一个值。如果需要从函数中返回多个值，可以使用引用参数，在函数中修改参数的值。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-47-1" name="__codelineno-47-1" href="#__codelineno-47-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">calculateValues</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">difference</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-47-2" name="__codelineno-47-2" href="#__codelineno-47-2"></a><span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-47-3" name="__codelineno-47-3" href="#__codelineno-47-3"></a><span class="w">  </span><span class="n">difference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-47-4" name="__codelineno-47-4" href="#__codelineno-47-4"></a><span class="p">}</span>
<a id="__codelineno-47-5" name="__codelineno-47-5" href="#__codelineno-47-5"></a>
<a id="__codelineno-47-6" name="__codelineno-47-6" href="#__codelineno-47-6"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-47-7" name="__codelineno-47-7" href="#__codelineno-47-7"></a><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<a id="__codelineno-47-8" name="__codelineno-47-8" href="#__codelineno-47-8"></a><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">resultSum</span><span class="p">,</span><span class="w"> </span><span class="n">resultDifference</span><span class="p">;</span>
<a id="__codelineno-47-9" name="__codelineno-47-9" href="#__codelineno-47-9"></a><span class="w">  </span><span class="n">calculateValues</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">resultSum</span><span class="p">,</span><span class="w"> </span><span class="n">resultDifference</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过引用传递返回多个值</span>
<a id="__codelineno-47-10" name="__codelineno-47-10" href="#__codelineno-47-10"></a><span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Sum: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">resultSum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, Difference: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">resultDifference</span><span class="p">;</span>
<a id="__codelineno-47-11" name="__codelineno-47-11" href="#__codelineno-47-11"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-47-12" name="__codelineno-47-12" href="#__codelineno-47-12"></a><span class="p">}</span>
</code></pre></div>
<p>总结：
使用 <code>&amp;</code> 来传递参数时，可以实现引用传递，以便在函数内部修改函数外部的变量、避免大对象复制或返回多个值。这样可以提高效率和灵活性，并避免不必要的数据复制。</p>
<h4 id="creturnexit">C++中return和exit<a class="headerlink" href="#creturnexit" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，<code>return</code> 和 <code>exit</code> 是用于程序控制流程的关键字，但它们有不同的用途和行为。</p>
<ol>
<li><code>return</code>：</li>
<li><code>return</code> 用于从函数中返回值，并终止当前函数的执行。当函数达到 <code>return</code> 语句时，它会立即返回并将指定的值传递给调用者。</li>
<li><code>return</code> 可以在任何函数中使用，包括主函数 <code>main()</code>。在 <code>main()</code> 函数中，<code>return</code> 的参数将作为程序的退出状态码返回给操作系统。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-48-1" name="__codelineno-48-1" href="#__codelineno-48-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-48-2" name="__codelineno-48-2" href="#__codelineno-48-2"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// 返回 a+b 的结果，并终止函数执行</span>
<a id="__codelineno-48-3" name="__codelineno-48-3" href="#__codelineno-48-3"></a><span class="p">}</span>
<a id="__codelineno-48-4" name="__codelineno-48-4" href="#__codelineno-48-4"></a>
<a id="__codelineno-48-5" name="__codelineno-48-5" href="#__codelineno-48-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-48-6" name="__codelineno-48-6" href="#__codelineno-48-6"></a><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// 调用 sum 函数并接收返回值</span>
<a id="__codelineno-48-7" name="__codelineno-48-7" href="#__codelineno-48-7"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将 result 作为程序的退出状态码返回给操作系统</span>
<a id="__codelineno-48-8" name="__codelineno-48-8" href="#__codelineno-48-8"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><code>exit</code>：</li>
<li><code>exit</code> 用于立即终止整个程序的执行，并返回给操作系统。它可以在任何地方被调用，不仅限于函数体内部。</li>
<li><code>exit</code> 接受一个整数参数，作为程序的退出状态码。这个状态码可以用来向调用程序传递附加信息，通常用 0 表示成功，非零值表示错误。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-49-1" name="__codelineno-49-1" href="#__codelineno-49-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdlib&gt;</span>
<a id="__codelineno-49-2" name="__codelineno-49-2" href="#__codelineno-49-2"></a>
<a id="__codelineno-49-3" name="__codelineno-49-3" href="#__codelineno-49-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-49-4" name="__codelineno-49-4" href="#__codelineno-49-4"></a><span class="w">  </span><span class="c1">// 执行一些代码...</span>
<a id="__codelineno-49-5" name="__codelineno-49-5" href="#__codelineno-49-5"></a>
<a id="__codelineno-49-6" name="__codelineno-49-6" href="#__codelineno-49-6"></a><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">someCondition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-49-7" name="__codelineno-49-7" href="#__codelineno-49-7"></a><span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 程序立即终止，并返回状态码 1 给操作系统表示错误</span>
<a id="__codelineno-49-8" name="__codelineno-49-8" href="#__codelineno-49-8"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-49-9" name="__codelineno-49-9" href="#__codelineno-49-9"></a>
<a id="__codelineno-49-10" name="__codelineno-49-10" href="#__codelineno-49-10"></a><span class="w">  </span><span class="c1">// 执行一些代码...</span>
<a id="__codelineno-49-11" name="__codelineno-49-11" href="#__codelineno-49-11"></a>
<a id="__codelineno-49-12" name="__codelineno-49-12" href="#__codelineno-49-12"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-49-13" name="__codelineno-49-13" href="#__codelineno-49-13"></a><span class="p">}</span>
</code></pre></div>
<p>总结：
- <code>return</code> 用于函数内部，用于从函数中返回值并终止函数的执行。
- <code>exit</code> 用于程序任何地方，用于立即终止整个程序的执行，并返回给操作系统一个状态码作为退出信息。</p>
<h4 id="static_1">静态static<a class="headerlink" href="#static_1" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，静态成员变量和静态成员函数是属于类本身而不是类的实例的成员。它们与类相关联，而不是与类的每个对象实例相关联。</p>
<ol>
<li>静态成员变量：</li>
<li>静态成员变量是在类中定义的，但不是在对象实例中分配内存的。它只有一个副本，被所有类的实例共享。</li>
<li>静态成员变量可以在类定义中进行初始化，并且必须在类外部进行定义（通常在源文件中）以分配内存空间。</li>
<li>访问静态成员变量时，使用类名加上作用域解析运算符 <code>::</code> 进行访问。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-50-1" name="__codelineno-50-1" href="#__codelineno-50-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-50-2" name="__codelineno-50-2" href="#__codelineno-50-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-50-3" name="__codelineno-50-3" href="#__codelineno-50-3"></a><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="c1">// 声明静态成员变量</span>
<a id="__codelineno-50-4" name="__codelineno-50-4" href="#__codelineno-50-4"></a>
<a id="__codelineno-50-5" name="__codelineno-50-5" href="#__codelineno-50-5"></a><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">incrementCount</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-50-6" name="__codelineno-50-6" href="#__codelineno-50-6"></a><span class="w">    </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<a id="__codelineno-50-7" name="__codelineno-50-7" href="#__codelineno-50-7"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-50-8" name="__codelineno-50-8" href="#__codelineno-50-8"></a><span class="p">};</span>
<a id="__codelineno-50-9" name="__codelineno-50-9" href="#__codelineno-50-9"></a>
<a id="__codelineno-50-10" name="__codelineno-50-10" href="#__codelineno-50-10"></a><span class="c1">// 在类外部进行静态成员变量的定义和初始化</span>
<a id="__codelineno-50-11" name="__codelineno-50-11" href="#__codelineno-50-11"></a><span class="kt">int</span><span class="w"> </span><span class="n">MyClass</span><span class="o">::</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-50-12" name="__codelineno-50-12" href="#__codelineno-50-12"></a>
<a id="__codelineno-50-13" name="__codelineno-50-13" href="#__codelineno-50-13"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-50-14" name="__codelineno-50-14" href="#__codelineno-50-14"></a><span class="w">  </span><span class="n">MyClass</span><span class="o">::</span><span class="n">incrementCount</span><span class="p">();</span><span class="w"> </span><span class="c1">// 使用类名调用静态成员函数</span>
<a id="__codelineno-50-15" name="__codelineno-50-15" href="#__codelineno-50-15"></a><span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Count: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">MyClass</span><span class="o">::</span><span class="n">count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用类名访问静态成员变量</span>
<a id="__codelineno-50-16" name="__codelineno-50-16" href="#__codelineno-50-16"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-50-17" name="__codelineno-50-17" href="#__codelineno-50-17"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li>静态成员函数：</li>
<li>静态成员函数在类的命名空间中存在，它们不操作特定对象的数据，因此没有隐式的 <code>this</code> 指针。</li>
<li>静态成员函数可以直接从类名调用，无需创建对象实例。</li>
<li>静态成员函数只能访问静态成员变量和其他静态成员函数。它们不能访问非静态成员变量或调用非静态成员函数。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-51-1" name="__codelineno-51-1" href="#__codelineno-51-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-51-2" name="__codelineno-51-2" href="#__codelineno-51-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-51-3" name="__codelineno-51-3" href="#__codelineno-51-3"></a><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-51-4" name="__codelineno-51-4" href="#__codelineno-51-4"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;This is a static member function.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-51-5" name="__codelineno-51-5" href="#__codelineno-51-5"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-51-6" name="__codelineno-51-6" href="#__codelineno-51-6"></a><span class="p">};</span>
<a id="__codelineno-51-7" name="__codelineno-51-7" href="#__codelineno-51-7"></a>
<a id="__codelineno-51-8" name="__codelineno-51-8" href="#__codelineno-51-8"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-51-9" name="__codelineno-51-9" href="#__codelineno-51-9"></a><span class="w">  </span><span class="n">MyClass</span><span class="o">::</span><span class="n">printMessage</span><span class="p">();</span><span class="w"> </span><span class="c1">// 使用类名调用静态成员函数</span>
<a id="__codelineno-51-10" name="__codelineno-51-10" href="#__codelineno-51-10"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-51-11" name="__codelineno-51-11" href="#__codelineno-51-11"></a><span class="p">}</span>
</code></pre></div>
<p>通过使用静态成员变量和静态成员函数，我们可以在不创建类的实例的情况下，共享数据和功能，并为类提供一些全局性质的特性。</p>
<h4 id="cjava">C++和java<a class="headerlink" href="#cjava" title="Permanent link">&para;</a></h4>
<p>C++同一个文件中，类要写在main函数之前</p>
<p>java同一个文件中，main函数写在类的前面或者后面无所谓，编译器并不关心它的位置。这是因为Java编译器会对整个文件进行扫描和解析，无论<code>main</code>函数在文件中的具体位置，它都能被正确地识别为程序的入口点。</p>
<h4 id="main">多个main问题<a class="headerlink" href="#main" title="Permanent link">&para;</a></h4>
<p>在VS中，会编译和链接所有源文件，会因重复定义main()函数而报错。</p>
<p>vscode中可以只编译和链接一个源文件，所以暂时没错。</p>
<h4 id="ch">C++类模板的声明和定义要放在同一个.h头文件<a class="headerlink" href="#ch" title="Permanent link">&para;</a></h4>
<p>不是只能放在.h里面，但是推荐放在.h里面。STL模板实现全部是放在.h里面的。</p>
<p>编译能通过。
1）参与编译的只是.cpp文件，不会报错的原因，是因为它能在.h里面找到模板的声明。
链接错误。
1）链接的时候，需要实例化模板，这时候就需要找模板的具体实现了。假设在main函数中调用了一个模板函数，这时候就需要去实例化该类型的模板。注意main函数里面只包含了.h文件，也就是只有模板的声明，没有具体实现。就会报错。
2）而模板的实现.cpp里面，虽然有模板的具体实现，但是没有谁在该.cpp里面使用一个模板函数，就不会生成一个具体化的实例。
ps：模板是在需要的时候，才会去生成一个具体化的实例的，比如，你只要一个int型的实例，模板就只会给你生成一个int型的实例，模板本身是不会被执行的（也就是模板本身不产生汇编指令），是模板生成的具体化实例才产生指令（这个实例是隐藏的，我们是看不到的）</p>
<p>解决方案：
1）将模板实现写在.h里面
2）如果你非要写在.cpp里面，那么请在模板实现的.cpp文件里面（或者.h里面）显式的实例化一个模板。如果是这样的话，那模板就没有太大的意义了，难道你去自己手动实例化所有的实例？</p>
<h4 id="_18">常量引用和引用引用<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<p>常量引用和引用引用（也称为右值引用）是 C++ 中两种不同的引用类型。</p>
<p>常量引用是指被引用对象的值不能被修改，而引用引用则是用于绑定到右值表达式上的引用类型，用于实现移动语义和完美转发。</p>
<p>具体来说，常量引用使用 const 关键字进行声明，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-52-1" name="__codelineno-52-1" href="#__codelineno-52-1"></a><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
</code></pre></div>
<p>这里的 ref 是一个常量引用，它指向 num 这个整数变量，并且不能修改 num 的值。</p>
<p>引用引用则使用 &amp;&amp; 进行声明，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-53-1" name="__codelineno-53-1" href="#__codelineno-53-1"></a><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</code></pre></div>
<p>这里的 ref 是一个引用引用，它指向 num 这个右值，并且可以用于实现移动语义和完美转发。</p>
<p>总的来说，常量引用和引用引用都是引用类型，但是它们的作用和使用场景有所不同。常量引用主要用于传递参数和返回值，以避免拷贝对象，而引用引用则主要用于实现移动语义和完美转发。</p>
<h4 id="_19">指针指针<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<p>指针指针（double pointer）在 C++ 中通常用于传递指向指针的指针，或者在函数中动态分配内存并返回指向指针的指针。指针指针可以用来实现一些高级数据结构，如链表和树等。</p>
<p>一个常见的用法是在函数中动态分配内存并返回指向指针的指针。例如，如果你想在函数中创建一个数组，并返回该数组的指针，你可以使用指针指针来实现。下面是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-54-1" name="__codelineno-54-1" href="#__codelineno-54-1"></a><span class="kt">int</span><span class="o">**</span><span class="w"> </span><span class="nf">createArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-54-2" name="__codelineno-54-2" href="#__codelineno-54-2"></a><span class="w">    </span><span class="kt">int</span><span class="o">**</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">[</span><span class="n">rows</span><span class="p">];</span>
<a id="__codelineno-54-3" name="__codelineno-54-3" href="#__codelineno-54-3"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-54-4" name="__codelineno-54-4" href="#__codelineno-54-4"></a><span class="w">        </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">cols</span><span class="p">];</span>
<a id="__codelineno-54-5" name="__codelineno-54-5" href="#__codelineno-54-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-54-6" name="__codelineno-54-6" href="#__codelineno-54-6"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>
<a id="__codelineno-54-7" name="__codelineno-54-7" href="#__codelineno-54-7"></a><span class="p">}</span>
</code></pre></div>
<p>这个函数创建一个 <code>rows</code> 行 <code>cols</code> 列的二维数组，并返回一个指向指针的指针。在这个函数中，我们首先创建一个指针数组 <code>array</code>，然后使用循环为每个指针分配一个数组。</p>
<p>另一个常见的用法是在函数中传递指向指针的指针，以便在函数中修改指针的值。这在某些情况下是非常有用的，例如，当你想在函数中创建一个新的对象并将其分配给一个指针时，你可以使用指针指针来修改指针的值。下面是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-55-1" name="__codelineno-55-1" href="#__codelineno-55-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">createObject</span><span class="p">(</span><span class="n">Object</span><span class="o">**</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-55-2" name="__codelineno-55-2" href="#__codelineno-55-2"></a><span class="w">    </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span>
<a id="__codelineno-55-3" name="__codelineno-55-3" href="#__codelineno-55-3"></a><span class="p">}</span>
</code></pre></div>
<p>这个函数创建一个新的 <code>Object</code> 对象，并将其分配给指向指针的指针 <code>obj</code>。在函数中，我们通过解引用指针指针来修改指针的值。</p>
<p>总之，指针指针在 C++ 中通常用于传递指向指针的指针，或者在函数中动态分配内存并返回指向指针的指针。</p>
<h4 id="_20">结构体里的静态函数<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，结构体可以包含静态函数。静态函数是指不需要实例化结构体对象即可被调用的函数。静态函数可以使用结构体中的静态成员变量，但不能使用结构体中的非静态成员变量。</p>
<p>静态函数的语法与普通函数类似，只需要在函数前面加上 <code>static</code> 关键字即可。下面是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-56-1" name="__codelineno-56-1" href="#__codelineno-56-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-56-2" name="__codelineno-56-2" href="#__codelineno-56-2"></a><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">myStaticVar</span><span class="p">;</span>
<a id="__codelineno-56-3" name="__codelineno-56-3" href="#__codelineno-56-3"></a>
<a id="__codelineno-56-4" name="__codelineno-56-4" href="#__codelineno-56-4"></a><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">myStaticFunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-56-5" name="__codelineno-56-5" href="#__codelineno-56-5"></a><span class="w">    </span><span class="c1">// 静态函数可以使用静态成员变量</span>
<a id="__codelineno-56-6" name="__codelineno-56-6" href="#__codelineno-56-6"></a><span class="w">    </span><span class="n">myStaticVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-56-7" name="__codelineno-56-7" href="#__codelineno-56-7"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello from myStaticFunc!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-56-8" name="__codelineno-56-8" href="#__codelineno-56-8"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-56-9" name="__codelineno-56-9" href="#__codelineno-56-9"></a><span class="p">};</span>
<a id="__codelineno-56-10" name="__codelineno-56-10" href="#__codelineno-56-10"></a>
<a id="__codelineno-56-11" name="__codelineno-56-11" href="#__codelineno-56-11"></a><span class="c1">// 静态成员变量需要在类外进行初始化</span>
<a id="__codelineno-56-12" name="__codelineno-56-12" href="#__codelineno-56-12"></a><span class="kt">int</span><span class="w"> </span><span class="n">MyStruct</span><span class="o">::</span><span class="n">myStaticVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-56-13" name="__codelineno-56-13" href="#__codelineno-56-13"></a>
<a id="__codelineno-56-14" name="__codelineno-56-14" href="#__codelineno-56-14"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-56-15" name="__codelineno-56-15" href="#__codelineno-56-15"></a><span class="w">  </span><span class="c1">// 调用静态函数</span>
<a id="__codelineno-56-16" name="__codelineno-56-16" href="#__codelineno-56-16"></a><span class="w">  </span><span class="n">MyStruct</span><span class="o">::</span><span class="n">myStaticFunc</span><span class="p">();</span>
<a id="__codelineno-56-17" name="__codelineno-56-17" href="#__codelineno-56-17"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-56-18" name="__codelineno-56-18" href="#__codelineno-56-18"></a><span class="p">}</span>
</code></pre></div>
<p>注意，在结构体中定义静态函数时，函数的实现必须在结构体内部进行。另外，静态函数可以通过 <code>结构体名::函数名()</code> 的方式进行调用。</p>
<h4 id="stl">STL中的配接器和配置器的区别<a class="headerlink" href="#stl" title="Permanent link">&para;</a></h4>
<p>STL中的配接器（adapter）和配置器（allocator）是两个不同的概念。</p>
<p>配接器是一种模式，用于将一个容器的接口转化为另一个容器的接口。STL中提供了多种配接器，如stack、queue、priority_queue等。这些配接器都是通过适配器模式来实现的，可以将一个容器适配为具有不同接口的容器。</p>
<p>而配置器则是用于控制容器的内存分配和释放的机制。STL中的容器都是通过配置器来进行内存管理的，配置器可以自定义内存分配和释放的方式，以满足不同的需求。STL中提供了默认的配置器std::allocator，也可以自定义配置器来实现更灵活的内存管理。</p>
<p>因此，配接器和配置器虽然都是STL中的重要概念，但是它们的作用和实现方式是不同的。</p>
<h4 id="c-iostream">C++ iostream<a class="headerlink" href="#c-iostream" title="Permanent link">&para;</a></h4>
<p>C++ 的 iostream 库提供了输入输出流的支持，包括了 <code>iostream</code>、<code>fstream</code>、<code>stringstream</code> 等头文件。其中，<code>iostream</code> 用于控制台输入输出；<code>fstream</code> 用于文件输入输出；<code>stringstream</code> 用于字符串输入输出。</p>
<p><code>iostream</code> 头文件中主要包含了 <code>cin</code>、<code>cout</code>、<code>cerr</code> 和 <code>clog</code> 四个对象，它们分别代表标准输入流、标准输出流、标准错误流和日志输出流。<code>cin</code> 和 <code>cout</code> 是最常用的输入输出流对象，分别用于从控制台读取输入和向控制台输出内容。<code>cerr</code> 和 <code>clog</code> 用于输出错误信息和日志信息，但它们的输出方式略有不同，<code>cerr</code> 直接输出到控制台，而 <code>clog</code> 输出到文件中。</p>
<p>除了对象之外，<code>iostream</code> 还提供了一些用于格式化输出的函数和操作符，例如 <code>setw</code>、<code>setprecision</code>、<code>fixed</code>、<code>scientific</code> 等等。这些函数和操作符可以帮助我们更方便地输出特定格式的内容。</p>
<p>总的来说，C++ 的 iostream 库提供了非常强大和灵活的输入输出功能，可以满足各种不同</p>
<h4 id="stl_1">STL中函数对象和算法的区别<a class="headerlink" href="#stl_1" title="Permanent link">&para;</a></h4>
<p>STL中的函数对象和算法都是STL的重要组成部分，但它们的作用有所不同。</p>
<p>函数对象（Functor）是一种行为类似函数的对象。它们可以像函数一样被调用，但与函数不同的是，函数对象可以保存状态。STL中的函数对象通常用于排序、查找、遍历等算法中，以提供自定义的比较、判定、转换等操作。</p>
<p>算法（Algorithm）是STL中的另一个重要组成部分，它们是对容器中的元素进行操作的函数。STL中的算法包括查找、排序、遍历、删除等操作。这些算法通常需要一个或多个函数对象作为参数，以提供自定义的比较、判定、转换等操作。</p>
<p>因此，函数对象和算法是相互依存的关系，函数对象提供了算法所需的自定义操作，而算法则使用这些函数对象来完成具体的操作。</p>
<p>return static_cast\&lt;bool&gt;(L.length);  //c++运算符，类型转换，将一个表达式转换为某种类型，但没有运行时的类型检查来保证转换的安全</p>
<p>cerr&lt;&lt;"error"&lt;&lt;endl;  //输出到标准错误的ostream对象，常用于程序错误信息；</p>
<p>size_t：size type，一种用来记录大小的数据类型，表示C中任何对象所能达到的最大长度，它是无符号整数。size_t在32位系统上定义为 unsigned int，也就是32位无符号整型，4字节。在64位系统上定义为 unsigned long ，也就是64位无符号整形，8字节。</p>
<h4 id="nullnullptr">NULL和nullptr的区别<a class="headerlink" href="#nullnullptr" title="Permanent link">&para;</a></h4>
<p>在C语言中，NULL：
是一个宏，被定义为空指针，定义如下：#define NULL ((void *)0) 
NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-57-1" name="__codelineno-57-1" href="#__codelineno-57-1"></a><span class="kt">int</span><span class="w">  </span><span class="o">*</span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<a id="__codelineno-57-2" name="__codelineno-57-2" href="#__codelineno-57-2"></a><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>
<p>C++程序中的NULL，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-58-1" name="__codelineno-58-1" href="#__codelineno-58-1"></a><span class="cp">#ifdef __cplusplus</span>
<a id="__codelineno-58-2" name="__codelineno-58-2" href="#__codelineno-58-2"></a><span class="cp">#define NULL 0</span>
<a id="__codelineno-58-3" name="__codelineno-58-3" href="#__codelineno-58-3"></a><span class="cp">#else</span>
<a id="__codelineno-58-4" name="__codelineno-58-4" href="#__codelineno-58-4"></a><span class="cp">#define NULL ((void *)0)</span>
<a id="__codelineno-58-5" name="__codelineno-58-5" href="#__codelineno-58-5"></a><span class="cp">#endif</span>
</code></pre></div>
<p>可见，在C++中，NULL实际上是0。因为C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了结果空指针的表示问题，C++引入了0来表示空指针，这样就有了上述代码中的NULL宏定义。
但是实际上，用NULL代替0表示空指针在函数重载时会出现问题，程序执行的结果会与我们的想法不同，举例如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-59-1" name="__codelineno-59-1" href="#__codelineno-59-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-59-2" name="__codelineno-59-2" href="#__codelineno-59-2"></a><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>
<a id="__codelineno-59-3" name="__codelineno-59-3" href="#__codelineno-59-3"></a>
<a id="__codelineno-59-4" name="__codelineno-59-4" href="#__codelineno-59-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<a id="__codelineno-59-5" name="__codelineno-59-5" href="#__codelineno-59-5"></a><span class="p">{</span>
<a id="__codelineno-59-6" name="__codelineno-59-6" href="#__codelineno-59-6"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;func1&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-59-7" name="__codelineno-59-7" href="#__codelineno-59-7"></a><span class="p">}</span>
<a id="__codelineno-59-8" name="__codelineno-59-8" href="#__codelineno-59-8"></a>
<a id="__codelineno-59-9" name="__codelineno-59-9" href="#__codelineno-59-9"></a><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<a id="__codelineno-59-10" name="__codelineno-59-10" href="#__codelineno-59-10"></a><span class="p">{</span>
<a id="__codelineno-59-11" name="__codelineno-59-11" href="#__codelineno-59-11"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;func2&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-59-12" name="__codelineno-59-12" href="#__codelineno-59-12"></a><span class="p">}</span>
<a id="__codelineno-59-13" name="__codelineno-59-13" href="#__codelineno-59-13"></a>
<a id="__codelineno-59-14" name="__codelineno-59-14" href="#__codelineno-59-14"></a><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<a id="__codelineno-59-15" name="__codelineno-59-15" href="#__codelineno-59-15"></a><span class="p">{</span>
<a id="__codelineno-59-16" name="__codelineno-59-16" href="#__codelineno-59-16"></a><span class="w">    </span><span class="n">func</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<a id="__codelineno-59-17" name="__codelineno-59-17" href="#__codelineno-59-17"></a><span class="w">    </span><span class="n">func</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
<a id="__codelineno-59-18" name="__codelineno-59-18" href="#__codelineno-59-18"></a><span class="w">    </span><span class="n">getchar</span><span class="p">();</span>
<a id="__codelineno-59-19" name="__codelineno-59-19" href="#__codelineno-59-19"></a><span class="p">}</span>
</code></pre></div>
<p><img alt="s1666951796042" src="../assets/1666951796042.png" /></p>
<p>在这段代码中，我们对函数func进行可重载，参数分别是void*类型和int类型，但是运行结果却与我们使用NULL的初衷是相违背的，因为我们本来是想用NULL来代替空指针，但是在将NULL输入到函数中时，它却选择了int形参这个函数版本，所以是有问题的，这就是用NULL代替空指针在C++程序中的二义性。</p>
<p>为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，从上面的例子中我们可以看到，使用nullptr作为实参，确实选择了正确的以void*作为形参的函数版本。</p>
<p>**总结：**NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用</p>
<h4 id="cforii">C++的for循环中++i和i++的区别：<a class="headerlink" href="#cforii" title="Permanent link">&para;</a></h4>
<p>最终输出的结果没有区别。
二者的实现代码如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-60-1" name="__codelineno-60-1" href="#__codelineno-60-1"></a><span class="w">   </span><span class="n">A</span><span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="o">++</span><span class="p">()</span><span class="w">         </span><span class="c1">//前++</span>
<a id="__codelineno-60-2" name="__codelineno-60-2" href="#__codelineno-60-2"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-60-3" name="__codelineno-60-3" href="#__codelineno-60-3"></a><span class="w">        </span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<a id="__codelineno-60-4" name="__codelineno-60-4" href="#__codelineno-60-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<a id="__codelineno-60-5" name="__codelineno-60-5" href="#__codelineno-60-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-60-6" name="__codelineno-60-6" href="#__codelineno-60-6"></a>
<a id="__codelineno-60-7" name="__codelineno-60-7" href="#__codelineno-60-7"></a><span class="w">    </span><span class="n">A</span><span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w">      </span><span class="c1">//后++</span>
<a id="__codelineno-60-8" name="__codelineno-60-8" href="#__codelineno-60-8"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-60-9" name="__codelineno-60-9" href="#__codelineno-60-9"></a><span class="w">        </span><span class="n">A</span><span class="w"> </span><span class="n">t</span><span class="o">=*</span><span class="k">this</span><span class="p">;</span><span class="w">          </span><span class="c1">//先保存一份变量</span>
<a id="__codelineno-60-10" name="__codelineno-60-10" href="#__codelineno-60-10"></a><span class="w">        </span><span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w">          </span><span class="c1">//调用前++</span>
<a id="__codelineno-60-11" name="__codelineno-60-11" href="#__codelineno-60-11"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<a id="__codelineno-60-12" name="__codelineno-60-12" href="#__codelineno-60-12"></a><span class="w">     </span><span class="p">}</span>
</code></pre></div>
<p>可以发现，i++需要一个暂时变量，然后将i加1后，返回的是暂时变量。而++i就是自增后返回i。
所以在**空间损耗**上，<strong>i++要略高于++i</strong>，因此，<strong>在不影响代码逻辑的前提下，要尽量使用++i</strong>。</p>
<h4 id="_21">无穷大与无穷小<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<p>如果是int，可以用INT_MAX表示正无穷，INT_MIN表示负无穷，需要包含limits.h。
如果是double，可以用DBL_MAX表示正无穷，-DBL_MAX表示负无穷(注意不是DBL_MIN)，需要包含float.h。</p>
<p>返回值很奇怪，一般是没有初始化。</p>
<p><img alt="s1679407169616" src="../assets/1679407169616.png" /></p>
<p>逻辑都正确，出现不应该出现的error，很可能是数组访问下标越界。</p>
<p><img alt="s1679402810832" src="../assets/1679402810832.png" /></p>
<p>要把int改为long</p>
<h4 id="template">template<a class="headerlink" href="#template" title="Permanent link">&para;</a></h4>
<p>C++中的模板（template）是一种通用的编程工具，可以让我们编写可以处理多种数据类型的代码。模板可以用于函数、类和类成员函数，它们可以接受任意类型的参数，包括基本数据类型、自定义类型和STL容器等。使用模板可以提高代码的复用性和灵活性，可以减少代码量，提高代码的可读性和可维护性。</p>
<h5 id="_22">函数模板<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h5>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。</p>
<p><strong>语法：</strong> </p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-61-1" name="__codelineno-61-1" href="#__codelineno-61-1"></a><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-61-2" name="__codelineno-61-2" href="#__codelineno-61-2"></a><span class="n">函数声明或定义</span>
</code></pre></div>
<p><strong>解释：</strong></p>
<p>template  ---  声明创建模板</p>
<p>typename  --- 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    ---   通用的数据类型，名称可以替换，通常为大写字母</p>
<h5 id="_23">类模板<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h5>
<p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个**虚拟的类型**来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-62-1" name="__codelineno-62-1" href="#__codelineno-62-1"></a><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-62-2" name="__codelineno-62-2" href="#__codelineno-62-2"></a><span class="n">类</span>
</code></pre></div>
<p><strong>解释：</strong></p>
<p>template  ---  声明创建模板</p>
<p>typename  --- 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    ---   通用的数据类型，名称可以替换，通常为大写字母</p>
<p>类模板在模板参数列表中可以有默认参数</p>
<h4 id="iterator_type-base-const">iterator_type base() const<a class="headerlink" href="#iterator_type-base-const" title="Permanent link">&para;</a></h4>
<p>函数后面加const关键字表示该函数一个const成员函数，它保证该函数不会修改对象的状态。</p>
<p>在迭代器中，base() 函数返回迭代器所指向的底层迭代器，因此它不需要修改迭代器对象本身的状态。</p>
<h4 id="_24">证同函数<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<p>C++中的证同函数（identity function）通常用于模板编程中的类型转换或类型萃取。证同函数是一个模板函数，它接受一个参数并返回该参数，不对参数进行任何操作，因此被称为“证同函数”。</p>
<p>在模板编程中，有时需要对某个类型进行转换或者获取该类型的某些属性，但是不希望对该类型进行任何修改，这时可以使用证同函数来实现。例如，可以使用如下的证同函数来获取某个类型的 const 版本：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-63-1" name="__codelineno-63-1" href="#__codelineno-63-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-63-2" name="__codelineno-63-2" href="#__codelineno-63-2"></a><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">as_const</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-63-3" name="__codelineno-63-3" href="#__codelineno-63-3"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<a id="__codelineno-63-4" name="__codelineno-63-4" href="#__codelineno-63-4"></a><span class="p">}</span>
</code></pre></div>
<p>在 C++11 中，也可以使用标准库中的 <code>std::identity</code> 函数模板来实现证同函数，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-64-1" name="__codelineno-64-1" href="#__codelineno-64-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<a id="__codelineno-64-2" name="__codelineno-64-2" href="#__codelineno-64-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-64-3" name="__codelineno-64-3" href="#__codelineno-64-3"></a>
<a id="__codelineno-64-4" name="__codelineno-64-4" href="#__codelineno-64-4"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-64-5" name="__codelineno-64-5" href="#__codelineno-64-5"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">identity</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 输出 42</span>
<a id="__codelineno-64-6" name="__codelineno-64-6" href="#__codelineno-64-6"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">identity</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">()(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 输出 &quot;hello&quot;</span>
<a id="__codelineno-64-7" name="__codelineno-64-7" href="#__codelineno-64-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-64-8" name="__codelineno-64-8" href="#__codelineno-64-8"></a><span class="p">}</span>
</code></pre></div>
<p>这里的 <code>std::identity&lt;T&gt;</code> 是一个函数对象，它的 <code>operator()</code> 实现了证同函数的功能。</p>
<h4 id="const_cast">const_cast<a class="headerlink" href="#const_cast" title="Permanent link">&para;</a></h4>
<p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于将常量指针或引用转换为非常量指针或引用，以便在程序中修改其所指向的值。需要注意的是，<code>const_cast</code> 只能用于去除常量性，而不能用于添加常量性。</p>
<p>下面是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-65-1" name="__codelineno-65-1" href="#__codelineno-65-1"></a><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-65-2" name="__codelineno-65-2" href="#__codelineno-65-2"></a><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<a id="__codelineno-65-3" name="__codelineno-65-3" href="#__codelineno-65-3"></a><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<a id="__codelineno-65-4" name="__codelineno-65-4" href="#__codelineno-65-4"></a><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c1">// 合法，但是会导致未定义行为</span>
</code></pre></div>
<p>在上面的示例中，<code>p</code> 是一个指向常量整数的指针，但是我们可以使用 <code>const_cast</code> 将其转换为一个指向非常量整数的指针 <code>q</code>，然后修改 <code>q</code> 所指向的值。需要注意的是，这样的行为会导致未定义行为，因为我们试图修改一个常量对象的值。因此，在实际编程中，我们应该避免这样的行为。</p>
<h4 id="reinterpret_cast">reinterpret_cast<a class="headerlink" href="#reinterpret_cast" title="Permanent link">&para;</a></h4>
<p><code>reinterpret_cast</code> 是 C++ 中的一种类型转换运算符，用于在不同类型之间进行强制转换。它可以将一个指针或引用转换为一个完全不相关的类型，甚至可以将一个整数类型转换为指针类型或反之。</p>
<p><code>reinterpret_cast</code> 的语法如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-66-1" name="__codelineno-66-1" href="#__codelineno-66-1"></a><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">new_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
</code></pre></div>
<p>其中，<code>new_type</code> 是要转换为的目标类型，<code>expression</code> 是要转换的表达式。</p>
<p>下面是一些 <code>reinterpret_cast</code> 的使用示例：</p>
<ol>
<li>将指针类型转换为另一个指针类型：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-67-1" name="__codelineno-67-1" href="#__codelineno-67-1"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<a id="__codelineno-67-2" name="__codelineno-67-2" href="#__codelineno-67-2"></a><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">charPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div>
<p>在这个示例中，<code>ptr</code> 是一个 <code>int*</code> 类型的指针，通过 <code>reinterpret_cast</code> 将其转换为 <code>char*</code> 类型的指针 <code>charPtr</code>。这样做会改变指针的类型，但不会修改指针指向的数据。</p>
<ol>
<li>将指针类型转换为整数类型：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-68-1" name="__codelineno-68-1" href="#__codelineno-68-1"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<a id="__codelineno-68-2" name="__codelineno-68-2" href="#__codelineno-68-2"></a><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">intVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div>
<p>在这个示例中，<code>ptr</code> 是一个 <code>int*</code> 类型的指针，通过 <code>reinterpret_cast</code> 将其转换为 <code>uintptr_t</code> 类型的整数 <code>intVal</code>。这样做可以将指针的值表示为一个整数，但不会修改指针指向的数据。</p>
<ol>
<li>将整数类型转换为指针类型：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-69-1" name="__codelineno-69-1" href="#__codelineno-69-1"></a><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">intVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12345</span><span class="p">;</span>
<a id="__codelineno-69-2" name="__codelineno-69-2" href="#__codelineno-69-2"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">intVal</span><span class="p">);</span>
</code></pre></div>
<p>在这个示例中，<code>intVal</code> 是一个 <code>uintptr_t</code> 类型的整数，通过 <code>reinterpret_cast</code> 将其转换为 <code>int*</code> 类型的指针 <code>ptr</code>。这样做会将整数解释为一个指针，但这可能是危险的，因为指针指向的数据可能是无效的。</p>
<p>需要注意的是，使用 <code>reinterpret_cast</code> 进行类型转换存在一些限制和风险。由于它执行的是一种底层的类型转换，编译器不会进行任何类型检查或安全性验证。因此，在使用 <code>reinterpret_cast</code> 进行类型转换时，需要确保转换是合法的，并且要小心处理指针类型的转换，以避免潜在的错误和未定义行为。</p>
<h4 id="remove_const">remove_const<a class="headerlink" href="#remove_const" title="Permanent link">&para;</a></h4>
<p><code>remove_const</code> 是 C++ 中的类型转换模板，用于去除类型中的 <code>const</code> 修饰符。它可以将一个类型中的 <code>const</code> 修饰符移除，返回一个新的类型，该类型与原始类型除去 <code>const</code> 修饰符外的其他部分完全相同。</p>
<p><code>remove_const</code> 的定义位于 <code>&lt;type_traits&gt;</code> 头文件中，是 C++ 标准库中的一部分。下面是 <code>remove_const</code> 的语法：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-70-1" name="__codelineno-70-1" href="#__codelineno-70-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-70-2" name="__codelineno-70-2" href="#__codelineno-70-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">remove_const</span><span class="p">;</span>
<a id="__codelineno-70-3" name="__codelineno-70-3" href="#__codelineno-70-3"></a>
<a id="__codelineno-70-4" name="__codelineno-70-4" href="#__codelineno-70-4"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-70-5" name="__codelineno-70-5" href="#__codelineno-70-5"></a><span class="k">using</span><span class="w"> </span><span class="n">remove_const_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">remove_const</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</code></pre></div>
<p><code>remove_const</code> 是一个模板结构体，它接受一个类型 <code>T</code> 作为模板参数，并定义了一个名为 <code>type</code> 的内部类型，该类型是去除 <code>T</code> 中的 <code>const</code> 修饰符后的结果类型。</p>
<p><code>remove_const_t</code> 是一个类型别名模板，它使用 <code>remove_const</code> 结构体的 <code>type</code> 成员类型作为其类型。</p>
<p>下面是一些使用 <code>remove_const</code> 的示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-71-1" name="__codelineno-71-1" href="#__codelineno-71-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<a id="__codelineno-71-2" name="__codelineno-71-2" href="#__codelineno-71-2"></a>
<a id="__codelineno-71-3" name="__codelineno-71-3" href="#__codelineno-71-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-71-4" name="__codelineno-71-4" href="#__codelineno-71-4"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<a id="__codelineno-71-5" name="__codelineno-71-5" href="#__codelineno-71-5"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="c1">// T2 是 int 类型</span>
<a id="__codelineno-71-6" name="__codelineno-71-6" href="#__codelineno-71-6"></a><span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;T2 should be int&quot;</span><span class="p">);</span>
<a id="__codelineno-71-7" name="__codelineno-71-7" href="#__codelineno-71-7"></a>
<a id="__codelineno-71-8" name="__codelineno-71-8" href="#__codelineno-71-8"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">T3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="p">;</span>
<a id="__codelineno-71-9" name="__codelineno-71-9" href="#__codelineno-71-9"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">T4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T3</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="c1">// T4 是 double 类型</span>
<a id="__codelineno-71-10" name="__codelineno-71-10" href="#__codelineno-71-10"></a><span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T4</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;T4 should be double&quot;</span><span class="p">);</span>
<a id="__codelineno-71-11" name="__codelineno-71-11" href="#__codelineno-71-11"></a>
<a id="__codelineno-71-12" name="__codelineno-71-12" href="#__codelineno-71-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-71-13" name="__codelineno-71-13" href="#__codelineno-71-13"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的示例中，我们定义了两个类型 <code>T1</code> 和 <code>T3</code>，它们都是使用 <code>const</code> 修饰符修饰的类型。通过使用 <code>remove_const_t</code>，我们可以获得去除了 <code>const</code> 修饰符的类型 <code>T2</code> 和 <code>T4</code>，它们分别是 <code>int</code> 和 <code>double</code> 类型。</p>
<p><code>remove_const</code> 在模板元编程中非常有用，可以帮助我们处理类型的特性和属性，并进行相应的类型转换和转型操作。</p>
<h4 id="_25">可变参数模板<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<p>这是 C++ 中的可变参数模板（Variadic Templates）语法，它允许定义一个接受可变数量参数的模板函数或模板类。在模板参数列表中使用 <code>...</code> 表示可变参数，它可以接受任意数量的参数，包括零个参数。</p>
<p>例如，下面是一个接受任意数量参数的模板函数的定义：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-72-1" name="__codelineno-72-1" href="#__codelineno-72-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<a id="__codelineno-72-2" name="__codelineno-72-2" href="#__codelineno-72-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">my_function</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-72-3" name="__codelineno-72-3" href="#__codelineno-72-3"></a><span class="w">    </span><span class="c1">// 函数体</span>
<a id="__codelineno-72-4" name="__codelineno-72-4" href="#__codelineno-72-4"></a><span class="p">}</span>
</code></pre></div>
<p>在这个函数中，<code>Args...</code> 表示可变参数列表，<code>Args</code> 是参数包的名称，<code>args</code> 是参数包的实例。在函数体中，可以使用递归展开参数包，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-73-1" name="__codelineno-73-1" href="#__codelineno-73-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-73-2" name="__codelineno-73-2" href="#__codelineno-73-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">my_function</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-73-3" name="__codelineno-73-3" href="#__codelineno-73-3"></a><span class="w">    </span><span class="c1">// 处理单个参数的情况</span>
<a id="__codelineno-73-4" name="__codelineno-73-4" href="#__codelineno-73-4"></a><span class="p">}</span>
<a id="__codelineno-73-5" name="__codelineno-73-5" href="#__codelineno-73-5"></a>
<a id="__codelineno-73-6" name="__codelineno-73-6" href="#__codelineno-73-6"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<a id="__codelineno-73-7" name="__codelineno-73-7" href="#__codelineno-73-7"></a><span class="kt">void</span><span class="w"> </span><span class="n">my_function</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-73-8" name="__codelineno-73-8" href="#__codelineno-73-8"></a><span class="w">    </span><span class="c1">// 处理多个参数的情况</span>
<a id="__codelineno-73-9" name="__codelineno-73-9" href="#__codelineno-73-9"></a><span class="w">    </span><span class="n">my_function</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span><span class="w"> </span><span class="c1">// 递归展开参数包</span>
<a id="__codelineno-73-10" name="__codelineno-73-10" href="#__codelineno-73-10"></a><span class="p">}</span>
</code></pre></div>
<p>这个函数会递归展开参数包，并对每个参数进行处理。例如，如果调用 <code>my_function(1, "hello", 3.14)</code>，则会依次调用 <code>my_function(1)</code>、<code>my_function("hello")</code> 和 <code>my_function(3.14)</code>。</p>
<h4 id="_26">左值和右值<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h4>
<p>在C++中，左值（lvalue）和右值（rvalue）是用于描述表达式的值类别的概念。它们的区别可以通过以下几个方面来理解：</p>
<ol>
<li>
<p>定义：左值是可寻址的、有标识符的表达式，而右值是临时的、不可寻址的表达式。</p>
</li>
<li>
<p>内存位置：左值表示一个具体的内存位置，可以通过地址运算符<code>&amp;</code>获取其地址。右值表示一个临时的值，没有明确的内存位置。</p>
</li>
<li>
<p>生命周期：左值有持久的生命周期，可以在程序中持续存在。右值通常具有临时的生命周期，它们在表达式求值后很快就会被销毁。</p>
</li>
<li>
<p>可修改性：左值是可修改的，可以通过左值引用修改其值。右值通常是不可修改的，因为它们是临时的或常量。</p>
</li>
<li>
<p>值类别：左值是一个标识符，可以出现在赋值运算符的左边和右边。右值是一个临时的值，可以出现在赋值运算符的右边。</p>
</li>
</ol>
<p>下面是一些示例来说明左值和右值的区别：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-74-1" name="__codelineno-74-1" href="#__codelineno-74-1"></a><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">         </span><span class="c1">// x是左值，具有持久的内存位置</span>
<a id="__codelineno-74-2" name="__codelineno-74-2" href="#__codelineno-74-2"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">     </span><span class="c1">// &amp;x是左值，获取x的地址</span>
<a id="__codelineno-74-3" name="__codelineno-74-3" href="#__codelineno-74-3"></a><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">         </span><span class="c1">// x是左值，可以用于赋值操作</span>
<a id="__codelineno-74-4" name="__codelineno-74-4" href="#__codelineno-74-4"></a><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">     </span><span class="c1">// x和y是左值，可以用于表达式计算</span>
<a id="__codelineno-74-5" name="__codelineno-74-5" href="#__codelineno-74-5"></a>
<a id="__codelineno-74-6" name="__codelineno-74-6" href="#__codelineno-74-6"></a><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-74-7" name="__codelineno-74-7" href="#__codelineno-74-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">     </span><span class="c1">// 10是右值，临时的，没有具体的内存位置</span>
<a id="__codelineno-74-8" name="__codelineno-74-8" href="#__codelineno-74-8"></a><span class="p">}</span>
<a id="__codelineno-74-9" name="__codelineno-74-9" href="#__codelineno-74-9"></a>
<a id="__codelineno-74-10" name="__codelineno-74-10" href="#__codelineno-74-10"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-74-11" name="__codelineno-74-11" href="#__codelineno-74-11"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<a id="__codelineno-74-12" name="__codelineno-74-12" href="#__codelineno-74-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">;</span><span class="w">  </span><span class="c1">// &amp;value是右值，返回一个临时的指针</span>
<a id="__codelineno-74-13" name="__codelineno-74-13" href="#__codelineno-74-13"></a><span class="p">}</span>
<a id="__codelineno-74-14" name="__codelineno-74-14" href="#__codelineno-74-14"></a>
<a id="__codelineno-74-15" name="__codelineno-74-15" href="#__codelineno-74-15"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-74-16" name="__codelineno-74-16" href="#__codelineno-74-16"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">     </span><span class="c1">// a是左值，具有持久的内存位置</span>
<a id="__codelineno-74-17" name="__codelineno-74-17" href="#__codelineno-74-17"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// foo()的返回值是右值，可以用于赋值</span>
<a id="__codelineno-74-18" name="__codelineno-74-18" href="#__codelineno-74-18"></a><span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">();</span><span class="w">  </span><span class="c1">// bar()的返回值是右值，可以用于赋值</span>
<a id="__codelineno-74-19" name="__codelineno-74-19" href="#__codelineno-74-19"></a>
<a id="__codelineno-74-20" name="__codelineno-74-20" href="#__codelineno-74-20"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-74-21" name="__codelineno-74-21" href="#__codelineno-74-21"></a><span class="p">}</span>
</code></pre></div>
<p>在上述示例中，变量<code>x</code>和<code>a</code>是左值，它们具有持久的内存位置，可以被引用和修改。函数<code>foo()</code>和<code>bar()</code>返回的是右值，它们是临时的、不可寻址的值。这些右值可以用于赋值操作，但它们的生命周期较短，不能被持久引用。</p>
<p>总的来说，左值和右值是C++中描述表达式值类别的概念。左值具有持久的内存位置，可以被引用和修改。</p>
<p>而右值是临时的、不可寻址的值。</p>
<h4 id="_27">左值引用和右值引用<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h4>
<p>左值引用和右值引用有以下几个主要区别：</p>
<ol>
<li>
<p>绑定对象类型：左值引用只能绑定到左值（可寻址的、有标识符的对象），而右值引用只能绑定到右值（临时对象、字面量、表达式结果等）。</p>
</li>
<li>
<p>生命周期：左值引用可以延长绑定对象的生命周期，因为左值引用可以持续引用一个对象，直到它超出作用域。右值引用通常用于临时对象，其生命周期通常较短，当右值引用超出作用域时，绑定对象会被销毁。</p>
</li>
<li>
<p>修改对象：左值引用可以修改绑定对象的状态或资源所有权，因为左值引用提供了对对象的直接访问。右值引用通常用于移动语义，通过转移资源的所有权而不进行深拷贝，从而提高性能。</p>
</li>
<li>
<p>完美转发：右值引用可以与模板结合使用，实现完美转发，将参数以原始类型转发给其他函数，保持参数的值类别。左值引用无法实现完美转发，因为它无法区分传递的是左值还是右值。</p>
</li>
<li>
<p>语法表示：左值引用使用单个<code>&amp;</code>符号表示，例如<code>int&amp;</code>；右值引用使用双<code>&amp;&amp;</code>符号表示，例如<code>int&amp;&amp;</code>。</p>
</li>
</ol>
<p>总的来说，左值引用和右值引用在绑定对象类型、生命周期、修改对象和完美转发等方面有着明显的区别。左值引用主要用于提供别名和修改对象的状态，而右值引用主要用于移动语义和完美转发，以及临时对象的优化。它们在C++中提供了更灵活和高效的编程方式。</p>
<p>左值引用和右值引用的区别可以通过以下具体例子来说明：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-75-1" name="__codelineno-75-1" href="#__codelineno-75-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-75-2" name="__codelineno-75-2" href="#__codelineno-75-2"></a>
<a id="__codelineno-75-3" name="__codelineno-75-3" href="#__codelineno-75-3"></a><span class="kt">void</span><span class="w"> </span><span class="nf">modifyValue</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-75-4" name="__codelineno-75-4" href="#__codelineno-75-4"></a><span class="w">    </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">  </span><span class="c1">// 修改绑定对象的值</span>
<a id="__codelineno-75-5" name="__codelineno-75-5" href="#__codelineno-75-5"></a><span class="p">}</span>
<a id="__codelineno-75-6" name="__codelineno-75-6" href="#__codelineno-75-6"></a>
<a id="__codelineno-75-7" name="__codelineno-75-7" href="#__codelineno-75-7"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printValue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-75-8" name="__codelineno-75-8" href="#__codelineno-75-8"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 读取绑定对象的值</span>
<a id="__codelineno-75-9" name="__codelineno-75-9" href="#__codelineno-75-9"></a><span class="p">}</span>
<a id="__codelineno-75-10" name="__codelineno-75-10" href="#__codelineno-75-10"></a>
<a id="__codelineno-75-11" name="__codelineno-75-11" href="#__codelineno-75-11"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-75-12" name="__codelineno-75-12" href="#__codelineno-75-12"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-75-13" name="__codelineno-75-13" href="#__codelineno-75-13"></a>
<a id="__codelineno-75-14" name="__codelineno-75-14" href="#__codelineno-75-14"></a><span class="w">    </span><span class="n">modifyValue</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">  </span><span class="c1">// 使用左值引用修改x的值</span>
<a id="__codelineno-75-15" name="__codelineno-75-15" href="#__codelineno-75-15"></a><span class="w">    </span><span class="n">printValue</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">   </span><span class="c1">// 使用左值引用读取x的值</span>
<a id="__codelineno-75-16" name="__codelineno-75-16" href="#__codelineno-75-16"></a>
<a id="__codelineno-75-17" name="__codelineno-75-17" href="#__codelineno-75-17"></a><span class="w">    </span><span class="n">modifyValue</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// 错误！无法将右值绑定到左值引用</span>
<a id="__codelineno-75-18" name="__codelineno-75-18" href="#__codelineno-75-18"></a><span class="w">    </span><span class="n">printValue</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">   </span><span class="c1">// 正确！可以将右值绑定到常量左值引用</span>
<a id="__codelineno-75-19" name="__codelineno-75-19" href="#__codelineno-75-19"></a>
<a id="__codelineno-75-20" name="__codelineno-75-20" href="#__codelineno-75-20"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-75-21" name="__codelineno-75-21" href="#__codelineno-75-21"></a><span class="p">}</span>
</code></pre></div>
<p>在上述示例中，<code>modifyValue</code>函数使用左值引用来修改绑定对象的值，而<code>printValue</code>函数使用常量左值引用来读取绑定对象的值。可以看到，左值引用可以修改绑定对象的值，并且可以持续引用一个对象。</p>
<p>然而，10是临时对象，当我们尝试将右值绑定到左值引用时（<code>modifyValue(10)</code>），会产生编译错误，因为左值引用只能绑定到左值。但是，我们可以将右值绑定到常量左值引用（<code>printValue(10)</code>），因为常量左值引用可以延长右值的生命周期，允许我们读取其值。</p>
<p>为了演示右值引用的使用，我们可以考虑以下示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-76-1" name="__codelineno-76-1" href="#__codelineno-76-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-76-2" name="__codelineno-76-2" href="#__codelineno-76-2"></a>
<a id="__codelineno-76-3" name="__codelineno-76-3" href="#__codelineno-76-3"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printValue</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-76-4" name="__codelineno-76-4" href="#__codelineno-76-4"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 读取绑定对象的值</span>
<a id="__codelineno-76-5" name="__codelineno-76-5" href="#__codelineno-76-5"></a><span class="p">}</span>
<a id="__codelineno-76-6" name="__codelineno-76-6" href="#__codelineno-76-6"></a>
<a id="__codelineno-76-7" name="__codelineno-76-7" href="#__codelineno-76-7"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-76-8" name="__codelineno-76-8" href="#__codelineno-76-8"></a><span class="w">    </span><span class="n">printValue</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// 使用右值引用读取临时对象的值</span>
<a id="__codelineno-76-9" name="__codelineno-76-9" href="#__codelineno-76-9"></a>
<a id="__codelineno-76-10" name="__codelineno-76-10" href="#__codelineno-76-10"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-76-11" name="__codelineno-76-11" href="#__codelineno-76-11"></a><span class="w">    </span><span class="n">printValue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w">  </span><span class="c1">// 使用右值引用读取移动后的对象的值</span>
<a id="__codelineno-76-12" name="__codelineno-76-12" href="#__codelineno-76-12"></a>
<a id="__codelineno-76-13" name="__codelineno-76-13" href="#__codelineno-76-13"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-76-14" name="__codelineno-76-14" href="#__codelineno-76-14"></a><span class="p">}</span>
</code></pre></div>
<p>在上述示例中，<code>printValue</code>函数使用右值引用来读取绑定对象的值。我们可以直接将临时对象（右值）传递给右值引用参数（<code>printValue(10)</code>），或者使用<code>std::move</code>将左值转换为右值引用（<code>printValue(std::move(x))</code>）。右值引用的主要作用是在移动语义中使用，例如在移动构造函数或移动赋值运算符中，通过转移资源的所有权而不进行深拷贝，提高性能。</p>
<p>这些例子展示了左值引用和右值引用在绑定对象、修改对象和传递参数等方面的区别。左值引用提供了对对象的直接访问和修改能力，而右值引用用于读取临时对象的值、实现移动语义和完美转发。</p>
<h4 id="_28">右值引用&amp;&amp;<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h4>
<p>右值引用是C++11引入的特性，它主要用于解决两个问题：避免不必要的数据拷贝和实现移动语义。</p>
<p>右值引用通常用于以下情况：</p>
<ol>
<li>移动语义：当我们需要将资源（如动态分配的内存、文件句柄等）从一个对象转移给另一个对象时，可以使用右值引用来实现高效的移动语义，避免不必要的数据拷贝。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-77-1" name="__codelineno-77-1" href="#__codelineno-77-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyString</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-77-2" name="__codelineno-77-2" href="#__codelineno-77-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-77-3" name="__codelineno-77-3" href="#__codelineno-77-3"></a><span class="w">    </span><span class="c1">// 移动构造函数</span>
<a id="__codelineno-77-4" name="__codelineno-77-4" href="#__codelineno-77-4"></a><span class="w">    </span><span class="n">MyString</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-77-5" name="__codelineno-77-5" href="#__codelineno-77-5"></a><span class="w">        </span><span class="c1">// 转移资源所有权</span>
<a id="__codelineno-77-6" name="__codelineno-77-6" href="#__codelineno-77-6"></a><span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<a id="__codelineno-77-7" name="__codelineno-77-7" href="#__codelineno-77-7"></a><span class="w">        </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<a id="__codelineno-77-8" name="__codelineno-77-8" href="#__codelineno-77-8"></a><span class="w">        </span><span class="c1">// 清空原对象</span>
<a id="__codelineno-77-9" name="__codelineno-77-9" href="#__codelineno-77-9"></a><span class="w">        </span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<a id="__codelineno-77-10" name="__codelineno-77-10" href="#__codelineno-77-10"></a><span class="w">        </span><span class="n">other</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-77-11" name="__codelineno-77-11" href="#__codelineno-77-11"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-77-12" name="__codelineno-77-12" href="#__codelineno-77-12"></a>
<a id="__codelineno-77-13" name="__codelineno-77-13" href="#__codelineno-77-13"></a><span class="w">    </span><span class="c1">// 移动赋值运算符</span>
<a id="__codelineno-77-14" name="__codelineno-77-14" href="#__codelineno-77-14"></a><span class="w">    </span><span class="n">MyString</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-77-15" name="__codelineno-77-15" href="#__codelineno-77-15"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-77-16" name="__codelineno-77-16" href="#__codelineno-77-16"></a><span class="w">            </span><span class="c1">// 释放当前对象的资源</span>
<a id="__codelineno-77-17" name="__codelineno-77-17" href="#__codelineno-77-17"></a><span class="w">            </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<a id="__codelineno-77-18" name="__codelineno-77-18" href="#__codelineno-77-18"></a><span class="w">            </span><span class="c1">// 转移资源所有权</span>
<a id="__codelineno-77-19" name="__codelineno-77-19" href="#__codelineno-77-19"></a><span class="w">            </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<a id="__codelineno-77-20" name="__codelineno-77-20" href="#__codelineno-77-20"></a><span class="w">            </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<a id="__codelineno-77-21" name="__codelineno-77-21" href="#__codelineno-77-21"></a><span class="w">            </span><span class="c1">// 清空原对象</span>
<a id="__codelineno-77-22" name="__codelineno-77-22" href="#__codelineno-77-22"></a><span class="w">            </span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<a id="__codelineno-77-23" name="__codelineno-77-23" href="#__codelineno-77-23"></a><span class="w">            </span><span class="n">other</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-77-24" name="__codelineno-77-24" href="#__codelineno-77-24"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-77-25" name="__codelineno-77-25" href="#__codelineno-77-25"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<a id="__codelineno-77-26" name="__codelineno-77-26" href="#__codelineno-77-26"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-77-27" name="__codelineno-77-27" href="#__codelineno-77-27"></a>
<a id="__codelineno-77-28" name="__codelineno-77-28" href="#__codelineno-77-28"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-77-29" name="__codelineno-77-29" href="#__codelineno-77-29"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<a id="__codelineno-77-30" name="__codelineno-77-30" href="#__codelineno-77-30"></a><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<a id="__codelineno-77-31" name="__codelineno-77-31" href="#__codelineno-77-31"></a><span class="p">};</span>
<a id="__codelineno-77-32" name="__codelineno-77-32" href="#__codelineno-77-32"></a>
<a id="__codelineno-77-33" name="__codelineno-77-33" href="#__codelineno-77-33"></a><span class="c1">// 使用移动语义创建对象</span>
<a id="__codelineno-77-34" name="__codelineno-77-34" href="#__codelineno-77-34"></a><span class="n">MyString</span><span class="w"> </span><span class="n">str1</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
<a id="__codelineno-77-35" name="__codelineno-77-35" href="#__codelineno-77-35"></a><span class="n">MyString</span><span class="w"> </span><span class="nf">str2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str1</span><span class="p">));</span><span class="w">  </span><span class="c1">// 调用移动构造函数</span>
</code></pre></div>
<ol>
<li>完美转发：右值引用还可以与模板结合使用，实现完美转发（perfect forwarding），即将参数按照原始类型转发给其他函数，保持参数的值类别不变。这在实现通用函数和函数模板时非常有用。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-78-1" name="__codelineno-78-1" href="#__codelineno-78-1"></a><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<a id="__codelineno-78-2" name="__codelineno-78-2" href="#__codelineno-78-2"></a><span class="kt">void</span><span class="w"> </span><span class="n">process</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-78-3" name="__codelineno-78-3" href="#__codelineno-78-3"></a><span class="w">    </span><span class="c1">// 使用完美转发将参数传递给其他函数</span>
<a id="__codelineno-78-4" name="__codelineno-78-4" href="#__codelineno-78-4"></a><span class="w">    </span><span class="n">otherFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<a id="__codelineno-78-5" name="__codelineno-78-5" href="#__codelineno-78-5"></a><span class="p">}</span>
<a id="__codelineno-78-6" name="__codelineno-78-6" href="#__codelineno-78-6"></a>
<a id="__codelineno-78-7" name="__codelineno-78-7" href="#__codelineno-78-7"></a><span class="c1">// 调用process函数</span>
<a id="__codelineno-78-8" name="__codelineno-78-8" href="#__codelineno-78-8"></a><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-78-9" name="__codelineno-78-9" href="#__codelineno-78-9"></a><span class="n">process</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w">        </span><span class="c1">// 传递左值</span>
<a id="__codelineno-78-10" name="__codelineno-78-10" href="#__codelineno-78-10"></a><span class="n">process</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span><span class="w">          </span><span class="c1">// 传递右值</span>
<a id="__codelineno-78-11" name="__codelineno-78-11" href="#__codelineno-78-11"></a><span class="n">process</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">());</span><span class="w"> </span><span class="c1">// 传递临时对象</span>
</code></pre></div>
<p>在上述例子中，process函数接收一个通用引用（Universal Reference）参数，通过std::forward函数将参数arg以原始类型转发给otherFunction函数，保持了传递参数时的值类别。</p>
<p>总的来说，右值引用在需要实现高效的移动语义和完美转发时非常有用。它可以避免不必要的数据拷贝，提高性能，并允许更灵活地操作和管理对象的生命周期。</p>
<h4 id="static_cast">static_cast<a class="headerlink" href="#static_cast" title="Permanent link">&para;</a></h4>
<p><code>static_cast</code> 是 C++ 中的一种类型转换操作符，用于将一个类型的值转换为另一个类型的值。它可以用于将指针或引用类型转换为另一种指针或引用类型，也可以用于将一个算术类型转换为另一个算术类型。</p>
<p><code>static_cast</code> 的语法如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-79-1" name="__codelineno-79-1" href="#__codelineno-79-1"></a><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
</code></pre></div>
<p>其中，<code>type</code> 是目标类型，<code>expression</code> 是要转换的表达式。</p>
<p><code>static_cast</code> 的使用需要注意以下几点：</p>
<ol>
<li><mark>只能用于编译时已知的类型转换</mark>，不能用于运行时的类型转换。</li>
<li>只能进行相对安全的类型转换，例如将一个指针类型转换为另一个指针类型，但不能将一个指针类型转换为一个整数类型。</li>
<li>在将一个指针类型转换为另一个指针类型时，需要确保目标类型是合法的，否则会导致未定义的行为。</li>
<li>在将一个整数类型转换为另一个整数类型时，需要注意可能会发生截断或溢出的问题。</li>
</ol>
<p>总之，<code>static_cast</code> 是 C++ 中一种常用的类型转换操作符，但需要谨慎使用，避免出现未定义的行为。</p>
<h4 id="const_caststatic_cast">什么时候用const_cast和什么时候用static_cast<a class="headerlink" href="#const_caststatic_cast" title="Permanent link">&para;</a></h4>
<p>总之，<code>const_cast</code> 用于处理常量性的转换，而 <code>static_cast</code> 用于基本数据类型、类层次结构和指针之间的常见转换。在选择使用哪种转换操作时，要根据具体情况和类型安全性来进行判断，确保转换是合法且安全的。</p>
<h4 id="assert">assert<a class="headerlink" href="#assert" title="Permanent link">&para;</a></h4>
<p><code>assert</code> 是 C++ 标准库中的一个宏定义，用于在程序中进行断言检查。当程序运行到 <code>assert</code> 处时，会检查其参数是否为真，如果为假，则会触发一个断言错误，程序会终止并输出错误信息。</p>
<p><code>assert</code> 宏的语法如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-80-1" name="__codelineno-80-1" href="#__codelineno-80-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<a id="__codelineno-80-2" name="__codelineno-80-2" href="#__codelineno-80-2"></a>
<a id="__codelineno-80-3" name="__codelineno-80-3" href="#__codelineno-80-3"></a><span class="n">assert</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
</code></pre></div>
<p>其中，<code>expression</code> 是一个返回值为 <code>bool</code> 类型的表达式，通常用于检查程序中的某些假设是否成立。如果 <code>expression</code> 为假，则 <code>assert</code> 会输出错误信息，并终止程序的执行。</p>
<p>在开发过程中，使用 <code>assert</code> 可以帮助我们快速发现程序中的错误，提高程序的健壮性和可靠性。但需要注意的是，<code>assert</code> 通常只在程序开发和调试阶段使用，发布版本中应该避免使用 <code>assert</code>。</p>
<h4 id="cin">cin<a class="headerlink" href="#cin" title="Permanent link">&para;</a></h4>
<p>在 C++ 中，<code>cin</code> 默认以空白字符（包括空格、制表符和换行符）作为输入的分隔符。这意味着 <code>cin</code> 在读取输入时会忽略空格和制表符，并在遇到换行符时结束输入。</p>
<p>默认情况下，<code>cin</code> 在读取数据时会跳过前导空白字符（包括换行符），直到遇到非空白字符为止。然后，它会将非空白字符读入变量，并停止读取，不包括非空白字符后面的字符。</p>
<h4 id="cinget">cin.get()<a class="headerlink" href="#cinget" title="Permanent link">&para;</a></h4>
<p><code>cin.get()</code> 是 C++ 中用于从标准输入流（stdin）读取单个字符的函数。它可以用于读取输入中的换行符、空格或其他特殊字符。</p>
<h4 id="const">const &amp;<a class="headerlink" href="#const" title="Permanent link">&para;</a></h4>
<p>在 C++ 函数中，当传递参数时使用 <code>const &amp;</code> 的主要情况是为了实现常量引用传递（Const Reference），这样可以提高性能并确保不会修改传入的参数。以下是一些常见的使用情况：</p>
<ol>
<li>避免不必要的复制：
   通过将参数声明为 <code>const &amp;</code>，可以避免进行参数的复制构造函数调用，并且保证不会修改传入的参数。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-81-1" name="__codelineno-81-1" href="#__codelineno-81-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printMessage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-81-2" name="__codelineno-81-2" href="#__codelineno-81-2"></a><span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">message</span><span class="p">;</span>
<a id="__codelineno-81-3" name="__codelineno-81-3" href="#__codelineno-81-3"></a><span class="p">}</span>
<a id="__codelineno-81-4" name="__codelineno-81-4" href="#__codelineno-81-4"></a>
<a id="__codelineno-81-5" name="__codelineno-81-5" href="#__codelineno-81-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-81-6" name="__codelineno-81-6" href="#__codelineno-81-6"></a><span class="w">  </span><span class="n">string</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="p">;</span>
<a id="__codelineno-81-7" name="__codelineno-81-7" href="#__codelineno-81-7"></a><span class="w">  </span><span class="n">printMessage</span><span class="p">(</span><span class="n">text</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过常量引用传递参数</span>
<a id="__codelineno-81-8" name="__codelineno-81-8" href="#__codelineno-81-8"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-81-9" name="__codelineno-81-9" href="#__codelineno-81-9"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li>提高性能：
   对于大型对象或类类型的参数，使用 <code>const &amp;</code> 可以减少内存开销和函数调用的时间，因为不需要进行参数的拷贝构造。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-82-1" name="__codelineno-82-1" href="#__codelineno-82-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">processObject</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Object</span><span class="o">&amp;</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-82-2" name="__codelineno-82-2" href="#__codelineno-82-2"></a><span class="w">  </span><span class="c1">// 对 obj 进行操作</span>
<a id="__codelineno-82-3" name="__codelineno-82-3" href="#__codelineno-82-3"></a><span class="p">}</span>
<a id="__codelineno-82-4" name="__codelineno-82-4" href="#__codelineno-82-4"></a>
<a id="__codelineno-82-5" name="__codelineno-82-5" href="#__codelineno-82-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-82-6" name="__codelineno-82-6" href="#__codelineno-82-6"></a><span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"> </span><span class="c1">// 假设 Object 是一个大型对象类型</span>
<a id="__codelineno-82-7" name="__codelineno-82-7" href="#__codelineno-82-7"></a><span class="w">  </span><span class="n">processObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过常量引用传递大型对象</span>
<a id="__codelineno-82-8" name="__codelineno-82-8" href="#__codelineno-82-8"></a><span class="w">  </span><span class="c1">// ...</span>
<a id="__codelineno-82-9" name="__codelineno-82-9" href="#__codelineno-82-9"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-82-10" name="__codelineno-82-10" href="#__codelineno-82-10"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li>防止意外修改：
   将参数声明为 <code>const &amp;</code> 可以明确表明函数不会修改传入的参数值，提供更好的代码可读性和安全性。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-83-1" name="__codelineno-83-1" href="#__codelineno-83-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">displayVector</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-83-2" name="__codelineno-83-2" href="#__codelineno-83-2"></a><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-83-3" name="__codelineno-83-3" href="#__codelineno-83-3"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-83-4" name="__codelineno-83-4" href="#__codelineno-83-4"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-83-5" name="__codelineno-83-5" href="#__codelineno-83-5"></a><span class="p">}</span>
<a id="__codelineno-83-6" name="__codelineno-83-6" href="#__codelineno-83-6"></a>
<a id="__codelineno-83-7" name="__codelineno-83-7" href="#__codelineno-83-7"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-83-8" name="__codelineno-83-8" href="#__codelineno-83-8"></a><span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<a id="__codelineno-83-9" name="__codelineno-83-9" href="#__codelineno-83-9"></a><span class="w">  </span><span class="n">displayVector</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span><span class="w"> </span><span class="c1">// 通过常量引用传递参数</span>
<a id="__codelineno-83-10" name="__codelineno-83-10" href="#__codelineno-83-10"></a><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-83-11" name="__codelineno-83-11" href="#__codelineno-83-11"></a><span class="p">}</span>
</code></pre></div>
<p>总结：
使用 <code>const &amp;</code> 来传递参数时，可以实现常量引用传递，避免不必要的复制、提高性能，并确保不会修改传入的参数。这样可以提高代码效率和安全性。</p>
<h4 id="_29">闭包<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h4>
<p>在C++中，闭包（closure）通常指的是一个函数对象，它可以捕获并访问其定义范围之外的变量。这些被捕获的变量可以在闭包内部使用，就像局部变量一样。</p>
<p>闭包是一个可调用的实体，它不仅包含了代码块（函数体），还记录了一些状态信息，其中最重要的就是它所捕获的变量。通过捕获外部作用域的变量，闭包可以在其定义范围之外继续访问和操作这些变量，即使定义这个闭包的上下文已经消失。</p>
<p>使用闭包，我们可以在 C++ 中实现更灵活和功能强大的函数对象。闭包可以作为参数传递给其他函数，或者存储在容器中，以供后续使用。</p>
<p>以下是一个简单的示例，展示了 C++ 中闭包的使用：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-84-1" name="__codelineno-84-1" href="#__codelineno-84-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-84-2" name="__codelineno-84-2" href="#__codelineno-84-2"></a>
<a id="__codelineno-84-3" name="__codelineno-84-3" href="#__codelineno-84-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-84-4" name="__codelineno-84-4" href="#__codelineno-84-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<a id="__codelineno-84-5" name="__codelineno-84-5" href="#__codelineno-84-5"></a>
<a id="__codelineno-84-6" name="__codelineno-84-6" href="#__codelineno-84-6"></a><span class="w">    </span><span class="c1">// 定义一个闭包，捕获变量x并进行操作</span>
<a id="__codelineno-84-7" name="__codelineno-84-7" href="#__codelineno-84-7"></a><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-84-8" name="__codelineno-84-8" href="#__codelineno-84-8"></a><span class="w">        </span><span class="n">x</span><span class="o">++</span><span class="p">;</span><span class="w">  </span><span class="c1">// 增加变量x的值</span>
<a id="__codelineno-84-9" name="__codelineno-84-9" href="#__codelineno-84-9"></a><span class="w">    </span><span class="p">};</span>
<a id="__codelineno-84-10" name="__codelineno-84-10" href="#__codelineno-84-10"></a>
<a id="__codelineno-84-11" name="__codelineno-84-11" href="#__codelineno-84-11"></a><span class="w">    </span><span class="c1">// 调用闭包，增加变量x的值</span>
<a id="__codelineno-84-12" name="__codelineno-84-12" href="#__codelineno-84-12"></a><span class="w">    </span><span class="n">increment</span><span class="p">();</span>
<a id="__codelineno-84-13" name="__codelineno-84-13" href="#__codelineno-84-13"></a>
<a id="__codelineno-84-14" name="__codelineno-84-14" href="#__codelineno-84-14"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Updated x: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-84-15" name="__codelineno-84-15" href="#__codelineno-84-15"></a>
<a id="__codelineno-84-16" name="__codelineno-84-16" href="#__codelineno-84-16"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-84-17" name="__codelineno-84-17" href="#__codelineno-84-17"></a><span class="p">}</span>
</code></pre></div>
<p>在上述示例中，我们定义了一个闭包 <code>increment</code>，它通过引用捕获了变量 <code>x</code>。在闭包的函数体内部，我们可以访问并操作变量 <code>x</code>。在调用闭包后，变量 <code>x</code> 的值被增加了一次。最后，我们打印出更新后的变量 <code>x</code> 的值。</p>
<p>通过使用闭包，我们可以轻松地访问和操作外部作用域的变量，而无需将这些变量作为参数传递给函数或使用全局变量。闭包提供了一种方便的方式来创建具有状态的函数对象，增强了 C++ 中函数式编程的能力。</p>
<h2 id="1">1、单纯用{}把一段代码框起来<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p>"即使没有特定的控制语句或其他上下文，单纯用 <code>{}</code> 把一段代码框起来在 C/C++ 中仍然有意义，主要体现在以下几个方面：</p>
<p><strong>1. 创建新的作用域</strong></p>
<p>用 <code>{}</code> 创建一个新的作用域（scope），在这个新作用域中声明的变量在外部是不可见的。这有助于控制变量的生命周期和避免命名冲突。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-85-1" name="__codelineno-85-1" href="#__codelineno-85-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-85-2" name="__codelineno-85-2" href="#__codelineno-85-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-85-3" name="__codelineno-85-3" href="#__codelineno-85-3"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-85-4" name="__codelineno-85-4" href="#__codelineno-85-4"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这是一个新的变量，与外部的 a 无关</span>
<a id="__codelineno-85-5" name="__codelineno-85-5" href="#__codelineno-85-5"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// 输出 20</span>
<a id="__codelineno-85-6" name="__codelineno-85-6" href="#__codelineno-85-6"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-85-7" name="__codelineno-85-7" href="#__codelineno-85-7"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// 输出 10</span>
<a id="__codelineno-85-8" name="__codelineno-85-8" href="#__codelineno-85-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-85-9" name="__codelineno-85-9" href="#__codelineno-85-9"></a><span class="p">}</span>
</code></pre></div>
<p><strong>2. 控制变量的生命周期</strong></p>
<p>在新作用域中声明的变量在离开作用域时会被销毁，这对于管理资源（如内存、文件描述符等）特别有用。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-86-1" name="__codelineno-86-1" href="#__codelineno-86-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-86-2" name="__codelineno-86-2" href="#__codelineno-86-2"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-86-3" name="__codelineno-86-3" href="#__codelineno-86-3"></a><span class="w">        </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;example.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<a id="__codelineno-86-4" name="__codelineno-86-4" href="#__codelineno-86-4"></a><span class="w">        </span><span class="c1">// 使用 file</span>
<a id="__codelineno-86-5" name="__codelineno-86-5" href="#__codelineno-86-5"></a><span class="w">        </span><span class="c1">// 离开作用域时，file 会自动销毁</span>
<a id="__codelineno-86-6" name="__codelineno-86-6" href="#__codelineno-86-6"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-86-7" name="__codelineno-86-7" href="#__codelineno-86-7"></a><span class="w">    </span><span class="c1">// 在这里 file 已经不可见了</span>
<a id="__codelineno-86-8" name="__codelineno-86-8" href="#__codelineno-86-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-86-9" name="__codelineno-86-9" href="#__codelineno-86-9"></a><span class="p">}</span>
</code></pre></div>
<p><strong>3. 临时代码块</strong></p>
<p>有时在调试或临时测试代码时，可以使用 <code>{}</code> 来隔离一些代码，以确保它不会影响其他部分。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-87-1" name="__codelineno-87-1" href="#__codelineno-87-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-87-2" name="__codelineno-87-2" href="#__codelineno-87-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<a id="__codelineno-87-3" name="__codelineno-87-3" href="#__codelineno-87-3"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-87-4" name="__codelineno-87-4" href="#__codelineno-87-4"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-87-5" name="__codelineno-87-5" href="#__codelineno-87-5"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;y = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<a id="__codelineno-87-6" name="__codelineno-87-6" href="#__codelineno-87-6"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-87-7" name="__codelineno-87-7" href="#__codelineno-87-7"></a><span class="w">    </span><span class="c1">// y 在这里是不可见的</span>
<a id="__codelineno-87-8" name="__codelineno-87-8" href="#__codelineno-87-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-87-9" name="__codelineno-87-9" href="#__codelineno-87-9"></a><span class="p">}</span>
</code></pre></div>
<p><strong>4. 防止命名冲突</strong></p>
<p>在大型代码库或复杂函数中，使用 <code>{}</code> 可以避免局部变量名冲突。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-88-1" name="__codelineno-88-1" href="#__codelineno-88-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-88-2" name="__codelineno-88-2" href="#__codelineno-88-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<a id="__codelineno-88-3" name="__codelineno-88-3" href="#__codelineno-88-3"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-88-4" name="__codelineno-88-4" href="#__codelineno-88-4"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="c1">// 与外部的 value 不冲突</span>
<a id="__codelineno-88-5" name="__codelineno-88-5" href="#__codelineno-88-5"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Inner value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<a id="__codelineno-88-6" name="__codelineno-88-6" href="#__codelineno-88-6"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-88-7" name="__codelineno-88-7" href="#__codelineno-88-7"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Outer value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<a id="__codelineno-88-8" name="__codelineno-88-8" href="#__codelineno-88-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-88-9" name="__codelineno-88-9" href="#__codelineno-88-9"></a><span class="p">}</span>
</code></pre></div>
<p><strong>总结</strong></p>
<p>即使没有特定的控制语句，单纯用 <code>{}</code> 把一段代码框起来仍然有其实际意义，主要是为了创建新的作用域，从而控制变量的可见性和生命周期，避免命名冲突，并有助于资源管理。</p>
<h2 id="5c">5、C++回调<a class="headerlink" href="#5c" title="Permanent link">&para;</a></h2>
<p>在C++中，回调（Callback）是一种通过函数指针、函数对象或lambda表达式来实现的机制，使得一个函数可以在特定事件发生时调用另一个函数。回调通常用于异步编程、事件驱动编程或当某些操作完成后需要通知调用者的场景。</p>
<p><strong>（1）回调的实现方式</strong></p>
<ol>
<li><strong>函数指针</strong>：
   函数指针是最基本的回调实现方式。你可以将一个函数的地址传递给另一个函数，并在适当的时候调用这个函数。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-89-1" name="__codelineno-89-1" href="#__codelineno-89-1"></a><span class="c1">// 回调函数</span>
<a id="__codelineno-89-2" name="__codelineno-89-2" href="#__codelineno-89-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">myCallbackFunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-89-3" name="__codelineno-89-3" href="#__codelineno-89-3"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Callback called with value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-89-4" name="__codelineno-89-4" href="#__codelineno-89-4"></a><span class="p">}</span>
<a id="__codelineno-89-5" name="__codelineno-89-5" href="#__codelineno-89-5"></a>
<a id="__codelineno-89-6" name="__codelineno-89-6" href="#__codelineno-89-6"></a><span class="c1">// 接受回调函数的函数</span>
<a id="__codelineno-89-7" name="__codelineno-89-7" href="#__codelineno-89-7"></a><span class="kt">void</span><span class="w"> </span><span class="nf">performOperation</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-89-8" name="__codelineno-89-8" href="#__codelineno-89-8"></a><span class="w">    </span><span class="c1">// 模拟一些操作</span>
<a id="__codelineno-89-9" name="__codelineno-89-9" href="#__codelineno-89-9"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-89-10" name="__codelineno-89-10" href="#__codelineno-89-10"></a><span class="w">    </span><span class="c1">// 调用回调函数</span>
<a id="__codelineno-89-11" name="__codelineno-89-11" href="#__codelineno-89-11"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-89-12" name="__codelineno-89-12" href="#__codelineno-89-12"></a><span class="p">}</span>
<a id="__codelineno-89-13" name="__codelineno-89-13" href="#__codelineno-89-13"></a>
<a id="__codelineno-89-14" name="__codelineno-89-14" href="#__codelineno-89-14"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-89-15" name="__codelineno-89-15" href="#__codelineno-89-15"></a><span class="w">    </span><span class="c1">// 将回调函数传递给另一个函数</span>
<a id="__codelineno-89-16" name="__codelineno-89-16" href="#__codelineno-89-16"></a><span class="w">    </span><span class="n">performOperation</span><span class="p">(</span><span class="n">myCallbackFunction</span><span class="p">);</span>
<a id="__codelineno-89-17" name="__codelineno-89-17" href="#__codelineno-89-17"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-89-18" name="__codelineno-89-18" href="#__codelineno-89-18"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>函数对象</strong>：
   函数对象（Function Object）是通过重载 <code>operator()</code> 的类或结构体实现的。它们比函数指针更灵活，可以携带状态。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-90-1" name="__codelineno-90-1" href="#__codelineno-90-1"></a><span class="c1">// 定义函数对象</span>
<a id="__codelineno-90-2" name="__codelineno-90-2" href="#__codelineno-90-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyCallback</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-90-3" name="__codelineno-90-3" href="#__codelineno-90-3"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-90-4" name="__codelineno-90-4" href="#__codelineno-90-4"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Callback called with value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-90-5" name="__codelineno-90-5" href="#__codelineno-90-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-90-6" name="__codelineno-90-6" href="#__codelineno-90-6"></a><span class="p">};</span>
<a id="__codelineno-90-7" name="__codelineno-90-7" href="#__codelineno-90-7"></a>
<a id="__codelineno-90-8" name="__codelineno-90-8" href="#__codelineno-90-8"></a><span class="c1">// 接受回调函数的函数</span>
<a id="__codelineno-90-9" name="__codelineno-90-9" href="#__codelineno-90-9"></a><span class="kt">void</span><span class="w"> </span><span class="nf">performOperation</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyCallback</span><span class="o">&amp;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-90-10" name="__codelineno-90-10" href="#__codelineno-90-10"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-90-11" name="__codelineno-90-11" href="#__codelineno-90-11"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-90-12" name="__codelineno-90-12" href="#__codelineno-90-12"></a><span class="p">}</span>
<a id="__codelineno-90-13" name="__codelineno-90-13" href="#__codelineno-90-13"></a>
<a id="__codelineno-90-14" name="__codelineno-90-14" href="#__codelineno-90-14"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-90-15" name="__codelineno-90-15" href="#__codelineno-90-15"></a><span class="w">    </span><span class="n">MyCallback</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span>
<a id="__codelineno-90-16" name="__codelineno-90-16" href="#__codelineno-90-16"></a><span class="w">    </span><span class="n">performOperation</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
<a id="__codelineno-90-17" name="__codelineno-90-17" href="#__codelineno-90-17"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-90-18" name="__codelineno-90-18" href="#__codelineno-90-18"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><strong><code>std::function</code> 和 Lambda 表达式</strong>：
   <code>std::function</code> 是 C++ 标准库中的一个通用多态函数包装器，可以存储任何可调用对象，包括函数指针、函数对象和lambda表达式。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-91-1" name="__codelineno-91-1" href="#__codelineno-91-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-91-2" name="__codelineno-91-2" href="#__codelineno-91-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<a id="__codelineno-91-3" name="__codelineno-91-3" href="#__codelineno-91-3"></a>
<a id="__codelineno-91-4" name="__codelineno-91-4" href="#__codelineno-91-4"></a><span class="c1">// 接受回调函数的函数</span>
<a id="__codelineno-91-5" name="__codelineno-91-5" href="#__codelineno-91-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">performOperation</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-91-6" name="__codelineno-91-6" href="#__codelineno-91-6"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-91-7" name="__codelineno-91-7" href="#__codelineno-91-7"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-91-8" name="__codelineno-91-8" href="#__codelineno-91-8"></a><span class="p">}</span>
<a id="__codelineno-91-9" name="__codelineno-91-9" href="#__codelineno-91-9"></a>
<a id="__codelineno-91-10" name="__codelineno-91-10" href="#__codelineno-91-10"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-91-11" name="__codelineno-91-11" href="#__codelineno-91-11"></a><span class="w">    </span><span class="c1">// 使用 lambda 表达式作为回调函数</span>
<a id="__codelineno-91-12" name="__codelineno-91-12" href="#__codelineno-91-12"></a><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">myCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-91-13" name="__codelineno-91-13" href="#__codelineno-91-13"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Callback called with value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-91-14" name="__codelineno-91-14" href="#__codelineno-91-14"></a><span class="w">    </span><span class="p">};</span>
<a id="__codelineno-91-15" name="__codelineno-91-15" href="#__codelineno-91-15"></a>
<a id="__codelineno-91-16" name="__codelineno-91-16" href="#__codelineno-91-16"></a><span class="w">    </span><span class="n">performOperation</span><span class="p">(</span><span class="n">myCallback</span><span class="p">);</span>
<a id="__codelineno-91-17" name="__codelineno-91-17" href="#__codelineno-91-17"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-91-18" name="__codelineno-91-18" href="#__codelineno-91-18"></a><span class="p">}</span>
</code></pre></div>
<p><strong>（2）回调的应用场景</strong></p>
<ol>
<li><strong>事件处理</strong>：在图形用户界面编程中，回调常用于处理用户输入事件，如按钮点击、鼠标移动等。</li>
<li><strong>异步编程</strong>：在异步操作（如网络请求、文件I/O）完成后，回调用于通知调用者操作的结果。</li>
<li><strong>库和框架</strong>：许多库和框架提供回调机制，让用户可以自定义特定事件的处理逻辑。</li>
</ol>
<p><strong>总结</strong></p>
<p>回调是一种强大的编程技术，允许函数间进行灵活的通信和控制流。通过函数指针、函数对象和 <code>std::function</code> 等方式，C++ 提供了多种实现回调的手段，使得编写灵活和可扩展的代码变得更加容易。</p>
<h2 id="10c">10、C中的回调<a class="headerlink" href="#10c" title="Permanent link">&para;</a></h2>
<p>"在C语言中，回调（Callback）是一种通过函数指针实现的机制，使得一个函数可以在特定事件发生时调用另一个函数。回调函数常用于异步编程、事件驱动编程和库/框架中，以实现灵活的控制流和事件处理。</p>
<p><strong>（1）回调的实现</strong></p>
<ol>
<li><strong>定义回调函数类型</strong>：
   首先，需要定义一个函数指针类型，这个类型表示回调函数的签名。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-92-1" name="__codelineno-92-1" href="#__codelineno-92-1"></a><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div>
<p>上面的代码定义了一个名为 <code>callback_t</code> 的函数指针类型，该类型表示接收一个 <code>int</code> 参数并且没有返回值的函数。</p>
<ol>
<li><strong>实现回调函数</strong>：
   接下来，实现一个符合上述签名的回调函数。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-93-1" name="__codelineno-93-1" href="#__codelineno-93-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">myCallbackFunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-93-2" name="__codelineno-93-2" href="#__codelineno-93-2"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Callback called with value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<a id="__codelineno-93-3" name="__codelineno-93-3" href="#__codelineno-93-3"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>实现接受回调函数的函数</strong>：
   然后，实现一个可以接受回调函数作为参数的函数。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-94-1" name="__codelineno-94-1" href="#__codelineno-94-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">performOperation</span><span class="p">(</span><span class="n">callback_t</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-94-2" name="__codelineno-94-2" href="#__codelineno-94-2"></a><span class="w">    </span><span class="c1">// 模拟一些操作</span>
<a id="__codelineno-94-3" name="__codelineno-94-3" href="#__codelineno-94-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-94-4" name="__codelineno-94-4" href="#__codelineno-94-4"></a><span class="w">    </span><span class="c1">// 调用回调函数</span>
<a id="__codelineno-94-5" name="__codelineno-94-5" href="#__codelineno-94-5"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-94-6" name="__codelineno-94-6" href="#__codelineno-94-6"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>调用接受回调函数的函数</strong>：
   最后，在主函数中，将回调函数传递给接受回调函数的函数。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-95-1" name="__codelineno-95-1" href="#__codelineno-95-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-95-2" name="__codelineno-95-2" href="#__codelineno-95-2"></a><span class="w">    </span><span class="c1">// 将回调函数传递给另一个函数</span>
<a id="__codelineno-95-3" name="__codelineno-95-3" href="#__codelineno-95-3"></a><span class="w">    </span><span class="n">performOperation</span><span class="p">(</span><span class="n">myCallbackFunction</span><span class="p">);</span>
<a id="__codelineno-95-4" name="__codelineno-95-4" href="#__codelineno-95-4"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-95-5" name="__codelineno-95-5" href="#__codelineno-95-5"></a><span class="p">}</span>
</code></pre></div>
<p><strong>（2）完整示例</strong></p>
<p>以下是一个完整的示例代码，展示了如何在C语言中实现和使用回调函数：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-96-1" name="__codelineno-96-1" href="#__codelineno-96-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-96-2" name="__codelineno-96-2" href="#__codelineno-96-2"></a>
<a id="__codelineno-96-3" name="__codelineno-96-3" href="#__codelineno-96-3"></a><span class="c1">// 定义回调函数类型</span>
<a id="__codelineno-96-4" name="__codelineno-96-4" href="#__codelineno-96-4"></a><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<a id="__codelineno-96-5" name="__codelineno-96-5" href="#__codelineno-96-5"></a>
<a id="__codelineno-96-6" name="__codelineno-96-6" href="#__codelineno-96-6"></a><span class="c1">// 回调函数的实现</span>
<a id="__codelineno-96-7" name="__codelineno-96-7" href="#__codelineno-96-7"></a><span class="kt">void</span><span class="w"> </span><span class="nf">myCallbackFunction</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-96-8" name="__codelineno-96-8" href="#__codelineno-96-8"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Callback called with value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<a id="__codelineno-96-9" name="__codelineno-96-9" href="#__codelineno-96-9"></a><span class="p">}</span>
<a id="__codelineno-96-10" name="__codelineno-96-10" href="#__codelineno-96-10"></a>
<a id="__codelineno-96-11" name="__codelineno-96-11" href="#__codelineno-96-11"></a><span class="c1">// 接受回调函数的函数</span>
<a id="__codelineno-96-12" name="__codelineno-96-12" href="#__codelineno-96-12"></a><span class="kt">void</span><span class="w"> </span><span class="nf">performOperation</span><span class="p">(</span><span class="n">callback_t</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-96-13" name="__codelineno-96-13" href="#__codelineno-96-13"></a><span class="w">    </span><span class="c1">// 模拟一些操作</span>
<a id="__codelineno-96-14" name="__codelineno-96-14" href="#__codelineno-96-14"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<a id="__codelineno-96-15" name="__codelineno-96-15" href="#__codelineno-96-15"></a><span class="w">    </span><span class="c1">// 调用回调函数</span>
<a id="__codelineno-96-16" name="__codelineno-96-16" href="#__codelineno-96-16"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-96-17" name="__codelineno-96-17" href="#__codelineno-96-17"></a><span class="p">}</span>
<a id="__codelineno-96-18" name="__codelineno-96-18" href="#__codelineno-96-18"></a>
<a id="__codelineno-96-19" name="__codelineno-96-19" href="#__codelineno-96-19"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-96-20" name="__codelineno-96-20" href="#__codelineno-96-20"></a><span class="w">    </span><span class="c1">// 将回调函数传递给另一个函数</span>
<a id="__codelineno-96-21" name="__codelineno-96-21" href="#__codelineno-96-21"></a><span class="w">    </span><span class="n">performOperation</span><span class="p">(</span><span class="n">myCallbackFunction</span><span class="p">);</span>
<a id="__codelineno-96-22" name="__codelineno-96-22" href="#__codelineno-96-22"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-96-23" name="__codelineno-96-23" href="#__codelineno-96-23"></a><span class="p">}</span>
</code></pre></div>
<p><strong>（3）回调的应用场景</strong></p>
<ol>
<li><strong>事件处理</strong>：在嵌入式系统或图形用户界面编程中，回调常用于处理外部事件，如按键按下、传感器数据到达等。</li>
<li><strong>异步编程</strong>：在网络编程或文件I/O操作中，回调用于在异步操作完成后通知调用者。</li>
<li><strong>库和框架</strong>：许多C语言库和框架提供回调机制，让用户可以自定义特定事件的处理逻辑。</li>
</ol>
<p><strong>（4）总结</strong></p>
<p>在C语言中，回调是一种通过函数指针实现的机制，使得函数间可以灵活地进行通信和控制流。通过定义函数指针类型、实现回调函数和调用接受回调函数的函数，可以实现各种复杂的编程需求。"</p>
<h2 id="15cstructclass">15、C++中的struct和class区别<a class="headerlink" href="#15cstructclass" title="Permanent link">&para;</a></h2>
<p>在C++中，<code>struct</code>和<code>class</code>是两种定义数据结构的基本方式，它们有许多相似之处，但也存在一些重要的区别。以下是它们的主要区别和相似点：</p>
<p><strong>（1）主要区别</strong></p>
<ol>
<li>
<p><strong>默认访问权限</strong>：</p>
</li>
<li>
<p><strong><code>struct</code></strong>：成员的默认访问权限是<code>public</code>。</p>
</li>
<li><strong><code>class</code></strong>：成员的默认访问权限是<code>private</code>。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-97-1" name="__codelineno-97-1" href="#__codelineno-97-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-97-2" name="__codelineno-97-2" href="#__codelineno-97-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 默认是 public</span>
<a id="__codelineno-97-3" name="__codelineno-97-3" href="#__codelineno-97-3"></a><span class="p">};</span>
<a id="__codelineno-97-4" name="__codelineno-97-4" href="#__codelineno-97-4"></a>
<a id="__codelineno-97-5" name="__codelineno-97-5" href="#__codelineno-97-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-97-6" name="__codelineno-97-6" href="#__codelineno-97-6"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 默认是 private</span>
<a id="__codelineno-97-7" name="__codelineno-97-7" href="#__codelineno-97-7"></a><span class="p">};</span>
</code></pre></div>
<ol>
<li>
<p><strong>继承的默认访问权限</strong>：</p>
</li>
<li>
<p><strong><code>struct</code></strong>：继承的默认访问权限是<code>public</code>。</p>
</li>
<li><strong><code>class</code></strong>：继承的默认访问权限是<code>private</code>。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-98-1" name="__codelineno-98-1" href="#__codelineno-98-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">BaseStruct</span><span class="w"> </span><span class="p">{};</span>
<a id="__codelineno-98-2" name="__codelineno-98-2" href="#__codelineno-98-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">DerivedStruct</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">BaseStruct</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="c1">// 默认是 public 继承</span>
<a id="__codelineno-98-3" name="__codelineno-98-3" href="#__codelineno-98-3"></a>
<a id="__codelineno-98-4" name="__codelineno-98-4" href="#__codelineno-98-4"></a><span class="k">class</span><span class="w"> </span><span class="nc">BaseClass</span><span class="w"> </span><span class="p">{};</span>
<a id="__codelineno-98-5" name="__codelineno-98-5" href="#__codelineno-98-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">DerivedClass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">BaseClass</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="c1">// 默认是 private 继承</span>
</code></pre></div>
<p><strong>（2）相似点</strong></p>
<ol>
<li>
<p><strong>成员函数和成员变量</strong>：</p>
</li>
<li>
<p><code>struct</code>和<code>class</code>都可以包含成员函数和成员变量。</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-99-1" name="__codelineno-99-1" href="#__codelineno-99-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-99-2" name="__codelineno-99-2" href="#__codelineno-99-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<a id="__codelineno-99-3" name="__codelineno-99-3" href="#__codelineno-99-3"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-99-4" name="__codelineno-99-4" href="#__codelineno-99-4"></a><span class="p">};</span>
<a id="__codelineno-99-5" name="__codelineno-99-5" href="#__codelineno-99-5"></a>
<a id="__codelineno-99-6" name="__codelineno-99-6" href="#__codelineno-99-6"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-99-7" name="__codelineno-99-7" href="#__codelineno-99-7"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<a id="__codelineno-99-8" name="__codelineno-99-8" href="#__codelineno-99-8"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-99-9" name="__codelineno-99-9" href="#__codelineno-99-9"></a><span class="p">};</span>
</code></pre></div>
<ol>
<li>
<p><strong>构造函数、析构函数、拷贝构造函数和赋值操作符</strong>：</p>
</li>
<li>
<p><code>struct</code>和<code>class</code>都可以有构造函数、析构函数、拷贝构造函数和赋值操作符。</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-100-1" name="__codelineno-100-1" href="#__codelineno-100-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-100-2" name="__codelineno-100-2" href="#__codelineno-100-2"></a><span class="w">    </span><span class="n">MyStruct</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-100-3" name="__codelineno-100-3" href="#__codelineno-100-3"></a><span class="w">    </span><span class="o">~</span><span class="n">MyStruct</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-100-4" name="__codelineno-100-4" href="#__codelineno-100-4"></a><span class="w">    </span><span class="n">MyStruct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyStruct</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-100-5" name="__codelineno-100-5" href="#__codelineno-100-5"></a><span class="w">    </span><span class="n">MyStruct</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyStruct</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<a id="__codelineno-100-6" name="__codelineno-100-6" href="#__codelineno-100-6"></a><span class="p">};</span>
<a id="__codelineno-100-7" name="__codelineno-100-7" href="#__codelineno-100-7"></a>
<a id="__codelineno-100-8" name="__codelineno-100-8" href="#__codelineno-100-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-100-9" name="__codelineno-100-9" href="#__codelineno-100-9"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-100-10" name="__codelineno-100-10" href="#__codelineno-100-10"></a><span class="w">    </span><span class="o">~</span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-100-11" name="__codelineno-100-11" href="#__codelineno-100-11"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-100-12" name="__codelineno-100-12" href="#__codelineno-100-12"></a><span class="w">    </span><span class="n">MyClass</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<a id="__codelineno-100-13" name="__codelineno-100-13" href="#__codelineno-100-13"></a><span class="p">};</span>
</code></pre></div>
<ol>
<li>
<p><strong>继承和多态</strong>：</p>
</li>
<li>
<p><code>struct</code>和<code>class</code>都支持继承和多态。</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-101-1" name="__codelineno-101-1" href="#__codelineno-101-1"></a><span class="k">struct</span><span class="w"> </span><span class="nc">BaseStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-101-2" name="__codelineno-101-2" href="#__codelineno-101-2"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-101-3" name="__codelineno-101-3" href="#__codelineno-101-3"></a><span class="p">};</span>
<a id="__codelineno-101-4" name="__codelineno-101-4" href="#__codelineno-101-4"></a>
<a id="__codelineno-101-5" name="__codelineno-101-5" href="#__codelineno-101-5"></a><span class="k">struct</span><span class="w"> </span><span class="nc">DerivedStruct</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">BaseStruct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-101-6" name="__codelineno-101-6" href="#__codelineno-101-6"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-101-7" name="__codelineno-101-7" href="#__codelineno-101-7"></a><span class="p">};</span>
<a id="__codelineno-101-8" name="__codelineno-101-8" href="#__codelineno-101-8"></a>
<a id="__codelineno-101-9" name="__codelineno-101-9" href="#__codelineno-101-9"></a><span class="k">class</span><span class="w"> </span><span class="nc">BaseClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-101-10" name="__codelineno-101-10" href="#__codelineno-101-10"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-101-11" name="__codelineno-101-11" href="#__codelineno-101-11"></a><span class="p">};</span>
<a id="__codelineno-101-12" name="__codelineno-101-12" href="#__codelineno-101-12"></a>
<a id="__codelineno-101-13" name="__codelineno-101-13" href="#__codelineno-101-13"></a><span class="k">class</span><span class="w"> </span><span class="nc">DerivedClass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">BaseClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-101-14" name="__codelineno-101-14" href="#__codelineno-101-14"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-101-15" name="__codelineno-101-15" href="#__codelineno-101-15"></a><span class="p">};</span>
</code></pre></div>
<p><strong>（3）何时使用<code>struct</code>和<code>class</code></strong></p>
<ol>
<li><strong>使用<code>struct</code></strong>：</li>
<li>通常用于表示简单的数据结构，类似于C语言中的<code>struct</code>。</li>
<li>
<p>主要用来存储数据，且默认访问权限为<code>public</code>。</p>
</li>
<li>
<p><strong>使用<code>class</code></strong>：</p>
</li>
<li>通常用于表示更复杂的对象，包含数据和行为。</li>
<li>主要用来封装数据和功能，且默认访问权限为<code>private</code>。</li>
</ol>
<p><strong>（4）总结</strong></p>
<p>虽然<code>struct</code>和<code>class</code>在C++中有一些语法上的区别，但它们在功能上是非常相似的。选择使用哪一个主要取决于代码的风格和设计意图。一般来说，<code>struct</code>更适用于简单的数据结构，而<code>class</code>更适用于复杂的对象和面向对象编程。</p>
<h2 id="25">25、指针符号存放地址<a class="headerlink" href="#25" title="Permanent link">&para;</a></h2>
<p>C的话指针符号<code>*</code>就靠左，</p>
<p>CPP的话指针符号 <code>*</code>就靠右</p>
<h2 id="30memsetsizeof">30、memset，sizeof<a class="headerlink" href="#30memsetsizeof" title="Permanent link">&para;</a></h2>
<p>用类型的sizeof，而不用变量的sizeof</p>
<h2 id="35size_tint">35、什么时候用size_t，什么时候用int<a class="headerlink" href="#35size_tint" title="Permanent link">&para;</a></h2>
<p>在C和C++编程中，选择使用<code>size_t</code>还是<code>int</code>取决于具体的上下文和需求。以下是一些指导原则：</p>
<p><strong>（1）使用<code>size_t</code>的情况</strong></p>
<ol>
<li><strong>数组索引和大小</strong>：<code>size_t</code>通常用于表示数组的索引和大小，因为它是一个无符号类型，能够表示更大的正整数范围。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-102-1" name="__codelineno-102-1" href="#__codelineno-102-1"></a><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<a id="__codelineno-102-2" name="__codelineno-102-2" href="#__codelineno-102-2"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-102-3" name="__codelineno-102-3" href="#__codelineno-102-3"></a><span class="w">    </span><span class="c1">// 操作数组元素</span>
<a id="__codelineno-102-4" name="__codelineno-102-4" href="#__codelineno-102-4"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>内存分配</strong>：在与内存分配函数（如<code>malloc</code>、<code>calloc</code>、<code>realloc</code>）交互时，使用<code>size_t</code>来表示内存大小。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-103-1" name="__codelineno-103-1" href="#__codelineno-103-1"></a><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">array_size</span><span class="p">);</span>
</code></pre></div>
<ol>
<li><strong>标准库函数</strong>：许多标准库函数使用<code>size_t</code>作为参数类型或返回类型，如<code>strlen</code>、<code>sizeof</code>、<code>fread</code>、<code>fwrite</code>等。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-104-1" name="__codelineno-104-1" href="#__codelineno-104-1"></a><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span>
</code></pre></div>
<p><strong>（2）使用<code>int</code>的情况</strong></p>
<ol>
<li><strong>一般整数运算</strong>：如果你需要进行一般的整数运算，特别是涉及负数的运算，使用<code>int</code>。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-105-1" name="__codelineno-105-1" href="#__codelineno-105-1"></a><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-105-2" name="__codelineno-105-2" href="#__codelineno-105-2"></a><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-5</span><span class="p">;</span>
<a id="__codelineno-105-3" name="__codelineno-105-3" href="#__codelineno-105-3"></a><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
</code></pre></div>
<ol>
<li><strong>计数器和循环</strong>：在循环中，如果计数器可能变为负值或你需要进行负数运算，使用<code>int</code>。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-106-1" name="__codelineno-106-1" href="#__codelineno-106-1"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-106-2" name="__codelineno-106-2" href="#__codelineno-106-2"></a><span class="w">    </span><span class="c1">// 处理</span>
<a id="__codelineno-106-3" name="__codelineno-106-3" href="#__codelineno-106-3"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>返回状态码</strong>：函数通常使用<code>int</code>来返回状态码，因为状态码可能包括负值来表示错误。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-107-1" name="__codelineno-107-1" href="#__codelineno-107-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">my_function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-107-2" name="__codelineno-107-2" href="#__codelineno-107-2"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error_occurred</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-107-3" name="__codelineno-107-3" href="#__codelineno-107-3"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<a id="__codelineno-107-4" name="__codelineno-107-4" href="#__codelineno-107-4"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-107-5" name="__codelineno-107-5" href="#__codelineno-107-5"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-107-6" name="__codelineno-107-6" href="#__codelineno-107-6"></a><span class="p">}</span>
</code></pre></div>
<p><strong>（3）比较<code>size_t</code>和<code>int</code></strong></p>
<ol>
<li><strong>无符号 vs. 有符号</strong>：<code>size_t</code>是无符号类型，不能表示负数，而<code>int</code>是有符号类型，可以表示负数。</li>
<li><strong>范围</strong>：<code>size_t</code>的范围通常比<code>int</code>大，因为它是无符号的，能够表示更大的正整数。</li>
<li><strong>类型匹配</strong>：在使用标准库函数时，确保参数类型匹配。例如，<code>strlen</code>返回<code>size_t</code>，因此应使用<code>size_t</code>来接收它的返回值。</li>
</ol>
<p><strong>（4）示例</strong></p>
<p><strong>使用<code>size_t</code>来处理数组和内存大小</strong></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-108-1" name="__codelineno-108-1" href="#__codelineno-108-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-108-2" name="__codelineno-108-2" href="#__codelineno-108-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-108-3" name="__codelineno-108-3" href="#__codelineno-108-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<a id="__codelineno-108-4" name="__codelineno-108-4" href="#__codelineno-108-4"></a>
<a id="__codelineno-108-5" name="__codelineno-108-5" href="#__codelineno-108-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">process_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-108-6" name="__codelineno-108-6" href="#__codelineno-108-6"></a><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<a id="__codelineno-108-7" name="__codelineno-108-7" href="#__codelineno-108-7"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-108-8" name="__codelineno-108-8" href="#__codelineno-108-8"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<a id="__codelineno-108-9" name="__codelineno-108-9" href="#__codelineno-108-9"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-108-10" name="__codelineno-108-10" href="#__codelineno-108-10"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-108-11" name="__codelineno-108-11" href="#__codelineno-108-11"></a><span class="p">}</span>
<a id="__codelineno-108-12" name="__codelineno-108-12" href="#__codelineno-108-12"></a>
<a id="__codelineno-108-13" name="__codelineno-108-13" href="#__codelineno-108-13"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-108-14" name="__codelineno-108-14" href="#__codelineno-108-14"></a><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">my_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello, world!&quot;</span><span class="p">;</span>
<a id="__codelineno-108-15" name="__codelineno-108-15" href="#__codelineno-108-15"></a><span class="w">    </span><span class="n">process_array</span><span class="p">(</span><span class="n">my_string</span><span class="p">);</span>
<a id="__codelineno-108-16" name="__codelineno-108-16" href="#__codelineno-108-16"></a>
<a id="__codelineno-108-17" name="__codelineno-108-17" href="#__codelineno-108-17"></a><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-108-18" name="__codelineno-108-18" href="#__codelineno-108-18"></a><span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">array_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<a id="__codelineno-108-19" name="__codelineno-108-19" href="#__codelineno-108-19"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-108-20" name="__codelineno-108-20" href="#__codelineno-108-20"></a><span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to allocate memory&quot;</span><span class="p">);</span>
<a id="__codelineno-108-21" name="__codelineno-108-21" href="#__codelineno-108-21"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span>
<a id="__codelineno-108-22" name="__codelineno-108-22" href="#__codelineno-108-22"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-108-23" name="__codelineno-108-23" href="#__codelineno-108-23"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
<a id="__codelineno-108-24" name="__codelineno-108-24" href="#__codelineno-108-24"></a>
<a id="__codelineno-108-25" name="__codelineno-108-25" href="#__codelineno-108-25"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<a id="__codelineno-108-26" name="__codelineno-108-26" href="#__codelineno-108-26"></a><span class="p">}</span>
</code></pre></div>
<p><strong>使用<code>int</code>来处理一般整数运算和状态码</strong></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-109-1" name="__codelineno-109-1" href="#__codelineno-109-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-109-2" name="__codelineno-109-2" href="#__codelineno-109-2"></a>
<a id="__codelineno-109-3" name="__codelineno-109-3" href="#__codelineno-109-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">add_numbers</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-109-4" name="__codelineno-109-4" href="#__codelineno-109-4"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-109-5" name="__codelineno-109-5" href="#__codelineno-109-5"></a><span class="p">}</span>
<a id="__codelineno-109-6" name="__codelineno-109-6" href="#__codelineno-109-6"></a>
<a id="__codelineno-109-7" name="__codelineno-109-7" href="#__codelineno-109-7"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-109-8" name="__codelineno-109-8" href="#__codelineno-109-8"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_numbers</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">-3</span><span class="p">);</span>
<a id="__codelineno-109-9" name="__codelineno-109-9" href="#__codelineno-109-9"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Result: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-109-10" name="__codelineno-109-10" href="#__codelineno-109-10"></a>
<a id="__codelineno-109-11" name="__codelineno-109-11" href="#__codelineno-109-11"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-109-12" name="__codelineno-109-12" href="#__codelineno-109-12"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-109-13" name="__codelineno-109-13" href="#__codelineno-109-13"></a><span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<a id="__codelineno-109-14" name="__codelineno-109-14" href="#__codelineno-109-14"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-109-15" name="__codelineno-109-15" href="#__codelineno-109-15"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<a id="__codelineno-109-16" name="__codelineno-109-16" href="#__codelineno-109-16"></a><span class="p">}</span>
</code></pre></div>
<p>总之，<code>size_t</code>主要用于表示大小和索引，而<code>int</code>用于一般的整数运算和需要表示负数的情况。根据具体需求选择合适的类型，以确保代码的正确性和可读性。</p>
<h2 class=".." id="40using-namespace-stdnamespace-std">40、using namespace std;<code>和</code>namespace std<a class="headerlink" href="#40using-namespace-stdnamespace-std" title="Permanent link">&para;</a></h2>
<p>在 C++ 编程中，<code>using namespace std;</code> 和 <code>namespace std { ... }</code> 是两种不同的用法，通常用于不同的场景。以下是它们各自的优缺点及适用场景：</p>
<h3 id="using-namespace-std"><code>using namespace std;</code><a class="headerlink" href="#using-namespace-std" title="Permanent link">&para;</a></h3>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>简洁性</strong>：可以减少代码中的前缀，使代码更简洁易读。例如，不需要在每个标准库的对象前加上 <code>std::</code>。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-110-1" name="__codelineno-110-1" href="#__codelineno-110-1"></a><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>
<a id="__codelineno-110-2" name="__codelineno-110-2" href="#__codelineno-110-2"></a><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>命名冲突</strong>：引入整个命名空间可能会导致命名冲突，尤其是在大型项目或使用多个库时。</li>
<li><strong>全局污染</strong>：在全局作用域中使用 <code>using namespace std;</code> 会将整个标准库命名空间引入到全局作用域，可能会导致意外的命名冲突。</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li>小型程序或示例代码。</li>
<li>在函数或局部作用域中使用，以减少命名冲突的风险。</li>
</ul>
<h3 id="namespace-std"><code>namespace std { ... }</code><a class="headerlink" href="#namespace-std" title="Permanent link">&para;</a></h3>
<p><strong>优点</strong>：</p>
<ol>
<li><strong>避免命名冲突</strong>：在定义自己的命名空间时，包裹标准库的代码可以避免命名冲突。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-111-1" name="__codelineno-111-1" href="#__codelineno-111-1"></a><span class="k">namespace</span><span class="w"> </span><span class="nn">mynamespace</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-111-2" name="__codelineno-111-2" href="#__codelineno-111-2"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>
<a id="__codelineno-111-3" name="__codelineno-111-3" href="#__codelineno-111-3"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">myFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-111-4" name="__codelineno-111-4" href="#__codelineno-111-4"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello from mynamespace!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-111-5" name="__codelineno-111-5" href="#__codelineno-111-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-111-6" name="__codelineno-111-6" href="#__codelineno-111-6"></a><span class="p">}</span>
</code></pre></div>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>复杂性</strong>：需要额外的命名空间管理，可能会增加代码的复杂性。</li>
<li><strong>误用风险</strong>：直接在 <code>namespace std</code> 中定义内容是错误的做法，因为会修改标准库的行为。</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li>定义自己的命名空间时，可以在命名空间内部使用 <code>using namespace std;</code>。</li>
<li><strong>注意</strong>：不要直接修改或扩展 <code>std</code> 命名空间，这会违反标准库的规则并可能导致未定义行为。</li>
</ul>
<h3 id="_30">推荐做法<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h3>
<p><strong>1. 使用 <code>std::</code> 前缀</strong></p>
<p>在大型项目中，推荐始终使用 <code>std::</code> 前缀来避免命名冲突：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-112-1" name="__codelineno-112-1" href="#__codelineno-112-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-112-2" name="__codelineno-112-2" href="#__codelineno-112-2"></a>
<a id="__codelineno-112-3" name="__codelineno-112-3" href="#__codelineno-112-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-112-4" name="__codelineno-112-4" href="#__codelineno-112-4"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-112-5" name="__codelineno-112-5" href="#__codelineno-112-5"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-112-6" name="__codelineno-112-6" href="#__codelineno-112-6"></a><span class="p">}</span>
</code></pre></div>
<p><strong>2. 在局部作用域中使用 <code>using</code></strong></p>
<p>如果觉得代码中频繁使用 <code>std::</code> 前缀太繁琐，可以在局部作用域中使用 <code>using</code> 声明：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-113-1" name="__codelineno-113-1" href="#__codelineno-113-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-113-2" name="__codelineno-113-2" href="#__codelineno-113-2"></a>
<a id="__codelineno-113-3" name="__codelineno-113-3" href="#__codelineno-113-3"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-113-4" name="__codelineno-113-4" href="#__codelineno-113-4"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<a id="__codelineno-113-5" name="__codelineno-113-5" href="#__codelineno-113-5"></a><span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-113-6" name="__codelineno-113-6" href="#__codelineno-113-6"></a>
<a id="__codelineno-113-7" name="__codelineno-113-7" href="#__codelineno-113-7"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-113-8" name="__codelineno-113-8" href="#__codelineno-113-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-113-9" name="__codelineno-113-9" href="#__codelineno-113-9"></a><span class="p">}</span>
</code></pre></div>
<p><strong>3. 避免在头文件中使用 <code>using namespace std;</code></strong></p>
<p>在头文件中使用 <code>using namespace std;</code> 会影响所有包含该头文件的源文件，容易导致命名冲突。头文件中应避免使用这种方式。</p>
<p><strong>总结</strong></p>
<ul>
<li><strong>小型程序或示例代码</strong>：可以使用 <code>using namespace std;</code> 以简化代码。</li>
<li><strong>大型项目</strong>：推荐始终使用 <code>std::</code> 前缀，或者在局部作用域中使用 <code>using</code> 声明。</li>
<li><strong>头文件</strong>：避免在头文件中使用 <code>using namespace std;</code>，以防止命名冲突和全局污染。</li>
</ul>
<h2 id="45privateprotected">45、类里面的private和protected<a class="headerlink" href="#45privateprotected" title="Permanent link">&para;</a></h2>
<p>类的private成员：只能类内部自己使用</p>
<p>类的protected成员：只能类内部和派生类内部访问（包括派生类的派生类）；你无法在某一个类里，建一个之前提到的派生类对象，然后企图访问其从基类继承到的protected成员</p>
<h2 id="50">50、函数名的意义<a class="headerlink" href="#50" title="Permanent link">&para;</a></h2>
<p>函数名其实就是一个函数指针，它指向了函数的地址</p>
<h2 id="55">55、虚函数和纯虚函数，子类继承后会怎么样<a class="headerlink" href="#55" title="Permanent link">&para;</a></h2>
<p><strong>虚函数</strong></p>
<p>虚函数是使用 <code>virtual</code> 关键字声明的成员函数，可以在派生类中被重写。当基类的指针或引用指向派生类对象时，调用虚函数会调用派生类的实现，而不是基类的实现。</p>
<p><strong>纯虚函数</strong></p>
<p>纯虚函数是没有实现的虚函数，用 <code>= 0</code> 来表示。包含纯虚函数的类是抽象类，不能实例化。派生类必须实现所有纯虚函数，否则它们也是抽象类。</p>
<p><strong>子类继承后的行为</strong></p>
<ol>
<li><strong>虚函数</strong>：如果子类重写了基类的虚函数，调用该函数时会执行子类的实现。如果子类没有重写，则调用基类的实现。</li>
<li><strong>纯虚函数</strong>：子类必须实现所有继承的纯虚函数，否则子类本身也会成为抽象类，不能被实例化。</li>
</ol>
<h2 id="60auto">60、auto时要不要使用引用&amp;<a class="headerlink" href="#60auto" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-114-1" name="__codelineno-114-1" href="#__codelineno-114-1"></a><span class="k">auto</span><span class="w"> </span><span class="n">masterPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AudioPositionMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span>
<a id="__codelineno-114-2" name="__codelineno-114-2" href="#__codelineno-114-2"></a>
<a id="__codelineno-114-3" name="__codelineno-114-3" href="#__codelineno-114-3"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">AudioPositionMap</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</code></pre></div>
<p><strong>使用 <code>auto&amp;</code></strong>：在 <code>for</code> 循环中使用 <code>auto&amp; position</code>可以避免复制每个元素，并直接操作原始元素</p>
<p><strong>初始化 <code>masterPosition</code></strong>：直接使用 <code>auto</code>，不需要引用，因为迭代器本身就是一个指针类型</p>
<h2 id="_31">错误<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h2>
<p><strong>Line 8: Char 42: error: reference to non-static member function must be called</strong>
<strong>sort(costs.begin(), costs.end(), compare);</strong></p>
<p>这个错误是因为你在调用<code>sort</code>函数时，传递了一个非静态成员函数<code>compare</code>作为比较函数。非静态成员函数需要通过对象来调用，而<code>sort</code>函数期望传递一个可调用的函数对象或函数指针作为比较函数。</p>
<p>要解决这个错误，你可以将<code>compare</code>函数改为静态成员函数或者将其定义为全局函数。这样就可以直接传递函数名作为比较函数，而不需要通过对象来调用。</p>
<h4 id="stdanyvscodestdany">编译的时候std::any能找到没出错，但是vscode里编辑时找不到std::any<a class="headerlink" href="#stdanyvscodestdany" title="Permanent link">&para;</a></h4>
<p>std::any是C++17才有的标准库类</p>
<p>如果你在编译时可以找到 <code>std::any</code> ，但在 VS Code 编辑器中无法找到它，可能是因为编辑器的标准库路径设置不正确导致的。</p>
<p>VS Code 默认使用编辑器的内置 IntelliSense 功能进行代码补全和语法检查，但它使用的标准库路径可能与你的项目配置或编译器配置不一致。为了解决这个问题，你可以尝试以下步骤：</p>
<ol>
<li>确认 C++ 标准版本：确保在 VS Code 中设置了正确的 C++ 标准版本。你可以在 <code>.vscode/settings.json</code> 文件中添加以下内容：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-115-1" name="__codelineno-115-1" href="#__codelineno-115-1"></a><span class="p">{</span>
<a id="__codelineno-115-2" name="__codelineno-115-2" href="#__codelineno-115-2"></a><span class="w">    </span><span class="nt">&quot;C_Cpp.default.cppStandard&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;c++17&quot;</span>
<a id="__codelineno-115-3" name="__codelineno-115-3" href="#__codelineno-115-3"></a><span class="p">}</span>
</code></pre></div>
<p>这会将默认的 C++ 标准设置为 C++17，以匹配你的项目配置。</p>
<ol>
<li>更新 IntelliSense 配置：在 VS Code 中，你可以通过按下 <code>Ctrl+Shift+P</code> 并输入 "C/C++: Edit Configurations (JSON)" 来编辑 IntelliSense 配置文件。然后，在 <code>"configurations"</code> 下找到你的配置，并添加 <code>"includePath"</code> 和 <code>"compilerPath"</code> 字段，分别指定标准库的路径和编译器的路径。</li>
</ol>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-116-1" name="__codelineno-116-1" href="#__codelineno-116-1"></a><span class="p">{</span>
<a id="__codelineno-116-2" name="__codelineno-116-2" href="#__codelineno-116-2"></a><span class="w">    </span><span class="nt">&quot;configurations&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<a id="__codelineno-116-3" name="__codelineno-116-3" href="#__codelineno-116-3"></a><span class="w">        </span><span class="p">{</span>
<a id="__codelineno-116-4" name="__codelineno-116-4" href="#__codelineno-116-4"></a><span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Linux&quot;</span><span class="p">,</span>
<a id="__codelineno-116-5" name="__codelineno-116-5" href="#__codelineno-116-5"></a><span class="w">            </span><span class="nt">&quot;includePath&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<a id="__codelineno-116-6" name="__codelineno-116-6" href="#__codelineno-116-6"></a><span class="w">                </span><span class="s2">&quot;${workspaceFolder}/**&quot;</span><span class="p">,</span>
<a id="__codelineno-116-7" name="__codelineno-116-7" href="#__codelineno-116-7"></a><span class="w">                </span><span class="s2">&quot;/usr/include/c++/10&quot;</span><span class="p">,</span>
<a id="__codelineno-116-8" name="__codelineno-116-8" href="#__codelineno-116-8"></a><span class="w">                </span><span class="s2">&quot;/usr/include/x86_64-linux-gnu/c++/10&quot;</span><span class="p">,</span>
<a id="__codelineno-116-9" name="__codelineno-116-9" href="#__codelineno-116-9"></a><span class="w">                </span><span class="s2">&quot;/usr/include/c++/10/backward&quot;</span><span class="p">,</span>
<a id="__codelineno-116-10" name="__codelineno-116-10" href="#__codelineno-116-10"></a><span class="w">                </span><span class="s2">&quot;/usr/lib/gcc/x86_64-linux-gnu/10/include&quot;</span><span class="p">,</span>
<a id="__codelineno-116-11" name="__codelineno-116-11" href="#__codelineno-116-11"></a><span class="w">                </span><span class="s2">&quot;/usr/local/include&quot;</span><span class="p">,</span>
<a id="__codelineno-116-12" name="__codelineno-116-12" href="#__codelineno-116-12"></a><span class="w">                </span><span class="s2">&quot;/usr/lib/gcc/x86_64-linux-gnu/10/include-fixed&quot;</span><span class="p">,</span>
<a id="__codelineno-116-13" name="__codelineno-116-13" href="#__codelineno-116-13"></a><span class="w">                </span><span class="s2">&quot;/usr/include/x86_64-linux-gnu&quot;</span><span class="p">,</span>
<a id="__codelineno-116-14" name="__codelineno-116-14" href="#__codelineno-116-14"></a><span class="w">                </span><span class="s2">&quot;/usr/include&quot;</span>
<a id="__codelineno-116-15" name="__codelineno-116-15" href="#__codelineno-116-15"></a><span class="w">            </span><span class="p">],</span>
<a id="__codelineno-116-16" name="__codelineno-116-16" href="#__codelineno-116-16"></a><span class="w">            </span><span class="nt">&quot;compilerPath&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/usr/bin/g++&quot;</span>
<a id="__codelineno-116-17" name="__codelineno-116-17" href="#__codelineno-116-17"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-116-18" name="__codelineno-116-18" href="#__codelineno-116-18"></a><span class="w">    </span><span class="p">]</span>
<a id="__codelineno-116-19" name="__codelineno-116-19" href="#__codelineno-116-19"></a><span class="p">}</span>
</code></pre></div>
<p>这样可以确保 IntelliSense 在编辑时能够正确找到标准库的位置。</p>
<ol>
<li>重启 VS Code：在进行以上更改后，重新启动 VS Code，以确保新的配置生效。</li>
</ol>
<p>如果问题仍然存在，可能需要进一步检查你的 VS Code 配置、编译器设置和项目结构，以确定是否还有其他因素导致了此问题。</p>
<h2 id="65">65、一个文件使用另一个文件的变量<a class="headerlink" href="#65" title="Permanent link">&para;</a></h2>
<p><a href="https://docs.pingcode.com/baike/1213792">c语言a文件如何调用b文件变量 | PingCode智库</a></p>
<h2 id="_32">常用实例<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h2>
<h3 id="1_1">1、函数与库的对应<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h3>
<p>1、max()、min()、abs()、swap()、reverse()、sort()、find()、count()、search()在\&lt;algorithm&gt;</p>
<p>2、内建函数对象，greater\&lt;&gt;()、less\&lt;&gt;()、bind()在\&lt;functional&gt;</p>
<p>3、accumulate在\&lt;numeric&gt;</p>
<p>4、unordered_map在\&lt;unordered_map&gt;，unordered_set在\&lt;unordered_set&gt;</p>
<h3 id="2">2、常用操作<a class="headerlink" href="#2" title="Permanent link">&para;</a></h3>
<p>bool型数据输出true/false，而并不是1/0</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-117-1" name="__codelineno-117-1" href="#__codelineno-117-1"></a><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">boolalpha</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ss</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<p>字符空格用‘ ’表示</p>
<h3 id="3">3、数组<a class="headerlink" href="#3" title="Permanent link">&para;</a></h3>
<h4 id="_33">动态创建数组并输出<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-118-1" name="__codelineno-118-1" href="#__codelineno-118-1"></a><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">   </span><span class="c1">//输入数组长度</span>
<a id="__codelineno-118-2" name="__codelineno-118-2" href="#__codelineno-118-2"></a><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<a id="__codelineno-118-3" name="__codelineno-118-3" href="#__codelineno-118-3"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">//声明一个指针</span>
<a id="__codelineno-118-4" name="__codelineno-118-4" href="#__codelineno-118-4"></a><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"> </span><span class="cm">/*创建了一个长度为n的动态数组，并且返回这个数组的首地址给p，p就指向了这个动态数组，可以通过指针p来操作数组，因为创建的动态数组并没有名字，只返回了首地址给p，所以可以把p看作是这个动态数组的名字 */</span>
<a id="__codelineno-118-5" name="__codelineno-118-5" href="#__codelineno-118-5"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-118-6" name="__codelineno-118-6" href="#__codelineno-118-6"></a><span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<a id="__codelineno-118-7" name="__codelineno-118-7" href="#__codelineno-118-7"></a><span class="p">}</span>
<a id="__codelineno-118-8" name="__codelineno-118-8" href="#__codelineno-118-8"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-118-9" name="__codelineno-118-9" href="#__codelineno-118-9"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-118-10" name="__codelineno-118-10" href="#__codelineno-118-10"></a><span class="p">}</span>
<a id="__codelineno-118-11" name="__codelineno-118-11" href="#__codelineno-118-11"></a><span class="k">delete</span><span class="p">[]</span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">//释放这个一维的动态数组，而不是释放指针p。用完以后要记得释放掉</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><a id="__codelineno-119-1" name="__codelineno-119-1" href="#__codelineno-119-1"></a><span class="c1">//无注释版</span>
<a id="__codelineno-119-2" name="__codelineno-119-2" href="#__codelineno-119-2"></a><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<a id="__codelineno-119-3" name="__codelineno-119-3" href="#__codelineno-119-3"></a><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<a id="__codelineno-119-4" name="__codelineno-119-4" href="#__codelineno-119-4"></a><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<a id="__codelineno-119-5" name="__codelineno-119-5" href="#__codelineno-119-5"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-119-6" name="__codelineno-119-6" href="#__codelineno-119-6"></a><span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<a id="__codelineno-119-7" name="__codelineno-119-7" href="#__codelineno-119-7"></a><span class="p">}</span>
<a id="__codelineno-119-8" name="__codelineno-119-8" href="#__codelineno-119-8"></a><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<a id="__codelineno-119-9" name="__codelineno-119-9" href="#__codelineno-119-9"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-119-10" name="__codelineno-119-10" href="#__codelineno-119-10"></a><span class="p">}</span>
<a id="__codelineno-119-11" name="__codelineno-119-11" href="#__codelineno-119-11"></a><span class="k">delete</span><span class="p">[]</span><span class="n">p</span><span class="p">;</span>
</code></pre></div>
<h3 id="4vector">4、vector<a class="headerlink" href="#4vector" title="Permanent link">&para;</a></h3>
<h4 id="vector">vector创建不定长的一组数据<a class="headerlink" href="#vector" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-120-1" name="__codelineno-120-1" href="#__codelineno-120-1"></a><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createVector</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-120-2" name="__codelineno-120-2" href="#__codelineno-120-2"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ivec</span><span class="p">;</span>
<a id="__codelineno-120-3" name="__codelineno-120-3" href="#__codelineno-120-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<a id="__codelineno-120-4" name="__codelineno-120-4" href="#__codelineno-120-4"></a><span class="w">    </span><span class="k">do</span>
<a id="__codelineno-120-5" name="__codelineno-120-5" href="#__codelineno-120-5"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-120-6" name="__codelineno-120-6" href="#__codelineno-120-6"></a><span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<a id="__codelineno-120-7" name="__codelineno-120-7" href="#__codelineno-120-7"></a><span class="w">        </span><span class="n">ivec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<a id="__codelineno-120-8" name="__codelineno-120-8" href="#__codelineno-120-8"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">getchar</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">//检测到换行键时，停止输入</span>
<a id="__codelineno-120-9" name="__codelineno-120-9" href="#__codelineno-120-9"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ivec</span><span class="p">;</span>
<a id="__codelineno-120-10" name="__codelineno-120-10" href="#__codelineno-120-10"></a><span class="p">}</span>
<a id="__codelineno-120-11" name="__codelineno-120-11" href="#__codelineno-120-11"></a><span class="c1">//返回值vector&lt;int&gt;是要返回vector容器，int则是返回整数</span>
<a id="__codelineno-120-12" name="__codelineno-120-12" href="#__codelineno-120-12"></a>
<a id="__codelineno-120-13" name="__codelineno-120-13" href="#__codelineno-120-13"></a><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createVector</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-120-14" name="__codelineno-120-14" href="#__codelineno-120-14"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nums</span><span class="p">;</span>
<a id="__codelineno-120-15" name="__codelineno-120-15" href="#__codelineno-120-15"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<a id="__codelineno-120-16" name="__codelineno-120-16" href="#__codelineno-120-16"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">tmp</span><span class="p">){</span>
<a id="__codelineno-120-17" name="__codelineno-120-17" href="#__codelineno-120-17"></a><span class="w">        </span><span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<a id="__codelineno-120-18" name="__codelineno-120-18" href="#__codelineno-120-18"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<a id="__codelineno-120-19" name="__codelineno-120-19" href="#__codelineno-120-19"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-120-20" name="__codelineno-120-20" href="#__codelineno-120-20"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">nums</span><span class="p">;</span>
<a id="__codelineno-120-21" name="__codelineno-120-21" href="#__codelineno-120-21"></a><span class="p">}</span>
</code></pre></div>
<blockquote>
<p>注：
a. 以空格为间隔输入数组
b. 输入完成，回车必须紧跟最后一个数字，若回车前是空格，则此回车会像空格一样被忽略</p>
</blockquote>
<h4 id="vector_1">手动创建vector容器嵌套容器<a class="headerlink" href="#vector_1" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-121-1" name="__codelineno-121-1" href="#__codelineno-121-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<a id="__codelineno-121-2" name="__codelineno-121-2" href="#__codelineno-121-2"></a><span class="p">{</span>
<a id="__codelineno-121-3" name="__codelineno-121-3" href="#__codelineno-121-3"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">intervals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">},{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="p">};</span>
<a id="__codelineno-121-4" name="__codelineno-121-4" href="#__codelineno-121-4"></a><span class="w">    </span><span class="n">printVectorInVector</span><span class="p">(</span><span class="n">intervals</span><span class="p">);</span>
<a id="__codelineno-121-5" name="__codelineno-121-5" href="#__codelineno-121-5"></a>
<a id="__codelineno-121-6" name="__codelineno-121-6" href="#__codelineno-121-6"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-121-7" name="__codelineno-121-7" href="#__codelineno-121-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-121-8" name="__codelineno-121-8" href="#__codelineno-121-8"></a><span class="p">}</span>
</code></pre></div>
<h4 id="vector_2">vector容器打印<a class="headerlink" href="#vector_2" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-122-1" name="__codelineno-122-1" href="#__codelineno-122-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printVector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-122-2" name="__codelineno-122-2" href="#__codelineno-122-2"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-122-3" name="__codelineno-122-3" href="#__codelineno-122-3"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-122-4" name="__codelineno-122-4" href="#__codelineno-122-4"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-122-5" name="__codelineno-122-5" href="#__codelineno-122-5"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-122-6" name="__codelineno-122-6" href="#__codelineno-122-6"></a><span class="p">}</span>
<a id="__codelineno-122-7" name="__codelineno-122-7" href="#__codelineno-122-7"></a>
<a id="__codelineno-122-8" name="__codelineno-122-8" href="#__codelineno-122-8"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printVector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-122-9" name="__codelineno-122-9" href="#__codelineno-122-9"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-122-10" name="__codelineno-122-10" href="#__codelineno-122-10"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-122-11" name="__codelineno-122-11" href="#__codelineno-122-11"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-122-12" name="__codelineno-122-12" href="#__codelineno-122-12"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-122-13" name="__codelineno-122-13" href="#__codelineno-122-13"></a><span class="p">}</span>
</code></pre></div>
<h4 id="vector_3">vector容器嵌套容器的打印<a class="headerlink" href="#vector_3" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-123-1" name="__codelineno-123-1" href="#__codelineno-123-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printVectorInVector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-123-2" name="__codelineno-123-2" href="#__codelineno-123-2"></a><span class="w">    </span><span class="c1">//通过大容器，把所有数据遍历一遍</span>
<a id="__codelineno-123-3" name="__codelineno-123-3" href="#__codelineno-123-3"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-123-4" name="__codelineno-123-4" href="#__codelineno-123-4"></a><span class="w">        </span><span class="c1">//(*it) ---- 容器 vector&lt;int&gt;</span>
<a id="__codelineno-123-5" name="__codelineno-123-5" href="#__codelineno-123-5"></a><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">vit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">vit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">vit</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-123-6" name="__codelineno-123-6" href="#__codelineno-123-6"></a><span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">vit</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-123-7" name="__codelineno-123-7" href="#__codelineno-123-7"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-123-8" name="__codelineno-123-8" href="#__codelineno-123-8"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-123-9" name="__codelineno-123-9" href="#__codelineno-123-9"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-123-10" name="__codelineno-123-10" href="#__codelineno-123-10"></a><span class="w">    </span><span class="c1">//每一个小容器输出，输出完了做一个换行的操作</span>
<a id="__codelineno-123-11" name="__codelineno-123-11" href="#__codelineno-123-11"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_34">求容器中的最大最小值<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h4>
<p><strong>方法：</strong>
<code>min_element</code>和<code>max_element</code>
输入参数为<code>vector</code>迭代器，输出为单一元素迭代器，要获得变量需要加*</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-124-1" name="__codelineno-124-1" href="#__codelineno-124-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-124-2" name="__codelineno-124-2" href="#__codelineno-124-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<a id="__codelineno-124-3" name="__codelineno-124-3" href="#__codelineno-124-3"></a>
<a id="__codelineno-124-4" name="__codelineno-124-4" href="#__codelineno-124-4"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<a id="__codelineno-124-5" name="__codelineno-124-5" href="#__codelineno-124-5"></a><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>
<a id="__codelineno-124-6" name="__codelineno-124-6" href="#__codelineno-124-6"></a>
<a id="__codelineno-124-7" name="__codelineno-124-7" href="#__codelineno-124-7"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<a id="__codelineno-124-8" name="__codelineno-124-8" href="#__codelineno-124-8"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="w"> </span><span class="p">};</span>
<a id="__codelineno-124-9" name="__codelineno-124-9" href="#__codelineno-124-9"></a><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">maxPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_element</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<a id="__codelineno-124-10" name="__codelineno-124-10" href="#__codelineno-124-10"></a><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">minPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_element</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<a id="__codelineno-124-11" name="__codelineno-124-11" href="#__codelineno-124-11"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">maxPosition</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; at the postion of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maxPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-124-12" name="__codelineno-124-12" href="#__codelineno-124-12"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">minPosition</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; at the postion of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">maxPosition</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-124-13" name="__codelineno-124-13" href="#__codelineno-124-13"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-124-14" name="__codelineno-124-14" href="#__codelineno-124-14"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-124-15" name="__codelineno-124-15" href="#__codelineno-124-15"></a><span class="p">}</span>
</code></pre></div>
<p><img alt="s1670400864834" src="../assets/1670400864834-1670400864939.png" /></p>
<h3 id="5">5、字符串<a class="headerlink" href="#5" title="Permanent link">&para;</a></h3>
<h4 id="_35">输入一个不带空格的字符串<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-125-1" name="__codelineno-125-1" href="#__codelineno-125-1"></a><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<a id="__codelineno-125-2" name="__codelineno-125-2" href="#__codelineno-125-2"></a><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
</code></pre></div>
<h4 id="_36">输入一个带空格的字符串<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-126-1" name="__codelineno-126-1" href="#__codelineno-126-1"></a><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<a id="__codelineno-126-2" name="__codelineno-126-2" href="#__codelineno-126-2"></a><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
</code></pre></div>
<h4 id="_37">常用函数<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h4>
<p>substr</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-127-1" name="__codelineno-127-1" href="#__codelineno-127-1"></a><span class="c1">// substr有2种用法：</span>
<a id="__codelineno-127-2" name="__codelineno-127-2" href="#__codelineno-127-2"></a><span class="c1">// 假设：string s = &quot;0123456789&quot;;</span>
<a id="__codelineno-127-3" name="__codelineno-127-3" href="#__codelineno-127-3"></a>
<a id="__codelineno-127-4" name="__codelineno-127-4" href="#__codelineno-127-4"></a><span class="n">string</span><span class="w"> </span><span class="n">sub1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">//只有一个数字5表示从下标为5开始一直到结尾：sub1 = &quot;56789&quot;</span>
<a id="__codelineno-127-5" name="__codelineno-127-5" href="#__codelineno-127-5"></a>
<a id="__codelineno-127-6" name="__codelineno-127-6" href="#__codelineno-127-6"></a><span class="n">string</span><span class="w"> </span><span class="n">sub2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">//从下标为5开始截取长度为3位：sub2 = &quot;567&quot;</span>
</code></pre></div>
<p>stoi
string-&gt;int
作用是将 n 进制的字符串转化为十进制，使用时包含头文件string.
定义如下：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-128-1" name="__codelineno-128-1" href="#__codelineno-128-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">stoi</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">);</span>
<a id="__codelineno-128-2" name="__codelineno-128-2" href="#__codelineno-128-2"></a>
<a id="__codelineno-128-3" name="__codelineno-128-3" href="#__codelineno-128-3"></a><span class="n">参数</span><span class="err">：</span>
<a id="__codelineno-128-4" name="__codelineno-128-4" href="#__codelineno-128-4"></a><span class="n">str</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">待转换的字符</span>
<a id="__codelineno-128-5" name="__codelineno-128-5" href="#__codelineno-128-5"></a><span class="n">pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">其取值可以是一个空字符</span><span class="err">，</span><span class="n">在这种情况下</span><span class="err">，</span><span class="n">pos未被使用</span><span class="err">；</span><span class="n">另外如果pos不是空指针</span><span class="err">，</span><span class="n">函数将pos的值设置为str中数字后面的第一个字符的位置</span><span class="err">。</span>
<a id="__codelineno-128-6" name="__codelineno-128-6" href="#__codelineno-128-6"></a><span class="n">base</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">字符中数字的进制</span><span class="err">，</span><span class="n">默认为10进制</span><span class="err">，</span><span class="n">如果base取值为0</span><span class="err">，</span><span class="n">则进制由字符串中的格式决定</span><span class="err">。</span>
</code></pre></div>
<h3 id="6">6、链表<a class="headerlink" href="#6" title="Permanent link">&para;</a></h3>
<h4 id="_38">尾插法创建不定长的单向链表（带头结点）<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-129-1" name="__codelineno-129-1" href="#__codelineno-129-1"></a><span class="c1">//尾插法创建不定长的单向链表（带头结点）</span>
<a id="__codelineno-129-2" name="__codelineno-129-2" href="#__codelineno-129-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">createListTail</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-129-3" name="__codelineno-129-3" href="#__codelineno-129-3"></a><span class="w">    </span><span class="c1">//r、L指向头结点</span>
<a id="__codelineno-129-4" name="__codelineno-129-4" href="#__codelineno-129-4"></a><span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<a id="__codelineno-129-5" name="__codelineno-129-5" href="#__codelineno-129-5"></a><span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-129-6" name="__codelineno-129-6" href="#__codelineno-129-6"></a><span class="w">        </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">;</span>
<a id="__codelineno-129-7" name="__codelineno-129-7" href="#__codelineno-129-7"></a><span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span><span class="w">  </span><span class="c1">//循环创建p，输入结点数据</span>
<a id="__codelineno-129-8" name="__codelineno-129-8" href="#__codelineno-129-8"></a><span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<a id="__codelineno-129-9" name="__codelineno-129-9" href="#__codelineno-129-9"></a><span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a id="__codelineno-129-10" name="__codelineno-129-10" href="#__codelineno-129-10"></a><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a id="__codelineno-129-11" name="__codelineno-129-11" href="#__codelineno-129-11"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">getchar</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<a id="__codelineno-129-12" name="__codelineno-129-12" href="#__codelineno-129-12"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_39">尾插法创建不定长的单向链表（不带头结点）<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-130-1" name="__codelineno-130-1" href="#__codelineno-130-1"></a><span class="c1">//不带头结点</span>
<a id="__codelineno-130-2" name="__codelineno-130-2" href="#__codelineno-130-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">createListTail</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-130-3" name="__codelineno-130-3" href="#__codelineno-130-3"></a><span class="w">    </span><span class="c1">//r、L直接指向首元结点而不是头结点</span>
<a id="__codelineno-130-4" name="__codelineno-130-4" href="#__codelineno-130-4"></a><span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<a id="__codelineno-130-5" name="__codelineno-130-5" href="#__codelineno-130-5"></a><span class="w">    </span><span class="c1">//第一次先输入首元结点的数据</span>
<a id="__codelineno-130-6" name="__codelineno-130-6" href="#__codelineno-130-6"></a><span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<a id="__codelineno-130-7" name="__codelineno-130-7" href="#__codelineno-130-7"></a><span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-130-8" name="__codelineno-130-8" href="#__codelineno-130-8"></a><span class="w">        </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">;</span>
<a id="__codelineno-130-9" name="__codelineno-130-9" href="#__codelineno-130-9"></a><span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span><span class="w">  </span><span class="c1">//循环创建p，输入结点数据</span>
<a id="__codelineno-130-10" name="__codelineno-130-10" href="#__codelineno-130-10"></a><span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<a id="__codelineno-130-11" name="__codelineno-130-11" href="#__codelineno-130-11"></a><span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a id="__codelineno-130-12" name="__codelineno-130-12" href="#__codelineno-130-12"></a><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a id="__codelineno-130-13" name="__codelineno-130-13" href="#__codelineno-130-13"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">getchar</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<a id="__codelineno-130-14" name="__codelineno-130-14" href="#__codelineno-130-14"></a><span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><a id="__codelineno-131-1" name="__codelineno-131-1" href="#__codelineno-131-1"></a><span class="c1">//尾插法创建不定长的单向链表</span>
<a id="__codelineno-131-2" name="__codelineno-131-2" href="#__codelineno-131-2"></a><span class="c1">//不带头结点</span>
<a id="__codelineno-131-3" name="__codelineno-131-3" href="#__codelineno-131-3"></a><span class="c1">//返回值类型直接为ListNode*</span>
<a id="__codelineno-131-4" name="__codelineno-131-4" href="#__codelineno-131-4"></a><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="nf">createListTail</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-131-5" name="__codelineno-131-5" href="#__codelineno-131-5"></a><span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">;</span>
<a id="__codelineno-131-6" name="__codelineno-131-6" href="#__codelineno-131-6"></a><span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<a id="__codelineno-131-7" name="__codelineno-131-7" href="#__codelineno-131-7"></a><span class="w">    </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<a id="__codelineno-131-8" name="__codelineno-131-8" href="#__codelineno-131-8"></a><span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-131-9" name="__codelineno-131-9" href="#__codelineno-131-9"></a><span class="w">        </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ListNode</span><span class="p">;</span>
<a id="__codelineno-131-10" name="__codelineno-131-10" href="#__codelineno-131-10"></a><span class="w">        </span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span><span class="w">  </span><span class="c1">//循环创建p，输入结点数据</span>
<a id="__codelineno-131-11" name="__codelineno-131-11" href="#__codelineno-131-11"></a><span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<a id="__codelineno-131-12" name="__codelineno-131-12" href="#__codelineno-131-12"></a><span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a id="__codelineno-131-13" name="__codelineno-131-13" href="#__codelineno-131-13"></a><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<a id="__codelineno-131-14" name="__codelineno-131-14" href="#__codelineno-131-14"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">getchar</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<a id="__codelineno-131-15" name="__codelineno-131-15" href="#__codelineno-131-15"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<a id="__codelineno-131-16" name="__codelineno-131-16" href="#__codelineno-131-16"></a><span class="p">}</span>
<a id="__codelineno-131-17" name="__codelineno-131-17" href="#__codelineno-131-17"></a>
<a id="__codelineno-131-18" name="__codelineno-131-18" href="#__codelineno-131-18"></a><span class="c1">//new出来的L，并且返回了，记得delete掉</span>
<a id="__codelineno-131-19" name="__codelineno-131-19" href="#__codelineno-131-19"></a><span class="k">delete</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
</code></pre></div>
<h4 id="_40">输出链表元素（带头结点）<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-132-1" name="__codelineno-132-1" href="#__codelineno-132-1"></a><span class="c1">//输出链表元素</span>
<a id="__codelineno-132-2" name="__codelineno-132-2" href="#__codelineno-132-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-132-3" name="__codelineno-132-3" href="#__codelineno-132-3"></a><span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<a id="__codelineno-132-4" name="__codelineno-132-4" href="#__codelineno-132-4"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-132-5" name="__codelineno-132-5" href="#__codelineno-132-5"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-132-6" name="__codelineno-132-6" href="#__codelineno-132-6"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<a id="__codelineno-132-7" name="__codelineno-132-7" href="#__codelineno-132-7"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-132-8" name="__codelineno-132-8" href="#__codelineno-132-8"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-132-9" name="__codelineno-132-9" href="#__codelineno-132-9"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_41">输出链表元素（不带头结点）<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-133-1" name="__codelineno-133-1" href="#__codelineno-133-1"></a><span class="c1">//输出链表元素</span>
<a id="__codelineno-133-2" name="__codelineno-133-2" href="#__codelineno-133-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-133-3" name="__codelineno-133-3" href="#__codelineno-133-3"></a><span class="w">    </span><span class="n">ListNode</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<a id="__codelineno-133-4" name="__codelineno-133-4" href="#__codelineno-133-4"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-133-5" name="__codelineno-133-5" href="#__codelineno-133-5"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-133-6" name="__codelineno-133-6" href="#__codelineno-133-6"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<a id="__codelineno-133-7" name="__codelineno-133-7" href="#__codelineno-133-7"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-133-8" name="__codelineno-133-8" href="#__codelineno-133-8"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-133-9" name="__codelineno-133-9" href="#__codelineno-133-9"></a><span class="p">}</span>
</code></pre></div>
<h3 id="7">7、树<a class="headerlink" href="#7" title="Permanent link">&para;</a></h3>
<h4 id="_42">根据数组，层次法创建二叉树<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-134-1" name="__codelineno-134-1" href="#__codelineno-134-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<a id="__codelineno-134-2" name="__codelineno-134-2" href="#__codelineno-134-2"></a>
<a id="__codelineno-134-3" name="__codelineno-134-3" href="#__codelineno-134-3"></a><span class="c1">//根据数组，层次法创建二叉树</span>
<a id="__codelineno-134-4" name="__codelineno-134-4" href="#__codelineno-134-4"></a><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="nf">createTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="c1">//层次法创建二叉树</span>
<a id="__codelineno-134-5" name="__codelineno-134-5" href="#__codelineno-134-5"></a><span class="p">{</span>
<a id="__codelineno-134-6" name="__codelineno-134-6" href="#__codelineno-134-6"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">//数值为0或超出数组范围</span>
<a id="__codelineno-134-7" name="__codelineno-134-7" href="#__codelineno-134-7"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<a id="__codelineno-134-8" name="__codelineno-134-8" href="#__codelineno-134-8"></a><span class="w">    </span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<a id="__codelineno-134-9" name="__codelineno-134-9" href="#__codelineno-134-9"></a><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<a id="__codelineno-134-10" name="__codelineno-134-10" href="#__codelineno-134-10"></a><span class="w">    </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<a id="__codelineno-134-11" name="__codelineno-134-11" href="#__codelineno-134-11"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>
<a id="__codelineno-134-12" name="__codelineno-134-12" href="#__codelineno-134-12"></a><span class="p">}</span>
<a id="__codelineno-134-13" name="__codelineno-134-13" href="#__codelineno-134-13"></a>
<a id="__codelineno-134-14" name="__codelineno-134-14" href="#__codelineno-134-14"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<a id="__codelineno-134-15" name="__codelineno-134-15" href="#__codelineno-134-15"></a><span class="p">{</span>
<a id="__codelineno-134-16" name="__codelineno-134-16" href="#__codelineno-134-16"></a><span class="w">    </span><span class="c1">//创建所使用的数组</span>
<a id="__codelineno-134-17" name="__codelineno-134-17" href="#__codelineno-134-17"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="w"> </span><span class="p">};</span>
<a id="__codelineno-134-18" name="__codelineno-134-18" href="#__codelineno-134-18"></a><span class="w">    </span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<a id="__codelineno-134-19" name="__codelineno-134-19" href="#__codelineno-134-19"></a><span class="w">    </span><span class="n">levelOrderIter</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<a id="__codelineno-134-20" name="__codelineno-134-20" href="#__codelineno-134-20"></a>
<a id="__codelineno-134-21" name="__codelineno-134-21" href="#__codelineno-134-21"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-134-22" name="__codelineno-134-22" href="#__codelineno-134-22"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-134-23" name="__codelineno-134-23" href="#__codelineno-134-23"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_43">二叉树的遍历，并输出<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-135-1" name="__codelineno-135-1" href="#__codelineno-135-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;queue&gt;</span>
<a id="__codelineno-135-2" name="__codelineno-135-2" href="#__codelineno-135-2"></a>
<a id="__codelineno-135-3" name="__codelineno-135-3" href="#__codelineno-135-3"></a><span class="c1">//层次遍历，迭代法</span>
<a id="__codelineno-135-4" name="__codelineno-135-4" href="#__codelineno-135-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">levelOrderIter</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-135-5" name="__codelineno-135-5" href="#__codelineno-135-5"></a><span class="w">    </span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">que</span><span class="p">;</span>
<a id="__codelineno-135-6" name="__codelineno-135-6" href="#__codelineno-135-6"></a><span class="w">    </span><span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<a id="__codelineno-135-7" name="__codelineno-135-7" href="#__codelineno-135-7"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-135-8" name="__codelineno-135-8" href="#__codelineno-135-8"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-135-9" name="__codelineno-135-9" href="#__codelineno-135-9"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-135-10" name="__codelineno-135-10" href="#__codelineno-135-10"></a><span class="w">            </span><span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
<a id="__codelineno-135-11" name="__codelineno-135-11" href="#__codelineno-135-11"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-135-12" name="__codelineno-135-12" href="#__codelineno-135-12"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-135-13" name="__codelineno-135-13" href="#__codelineno-135-13"></a><span class="w">            </span><span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<a id="__codelineno-135-14" name="__codelineno-135-14" href="#__codelineno-135-14"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-135-15" name="__codelineno-135-15" href="#__codelineno-135-15"></a><span class="w">        </span><span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<a id="__codelineno-135-16" name="__codelineno-135-16" href="#__codelineno-135-16"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-135-17" name="__codelineno-135-17" href="#__codelineno-135-17"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-135-18" name="__codelineno-135-18" href="#__codelineno-135-18"></a><span class="p">}</span>
<a id="__codelineno-135-19" name="__codelineno-135-19" href="#__codelineno-135-19"></a>
<a id="__codelineno-135-20" name="__codelineno-135-20" href="#__codelineno-135-20"></a><span class="c1">//中序遍历，迭代法  左-根-右</span>
<a id="__codelineno-135-21" name="__codelineno-135-21" href="#__codelineno-135-21"></a><span class="kt">void</span><span class="w"> </span><span class="nf">InOrderIter</span><span class="p">(</span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">)</span>
<a id="__codelineno-135-22" name="__codelineno-135-22" href="#__codelineno-135-22"></a><span class="p">{</span><span class="w"> </span>
<a id="__codelineno-135-23" name="__codelineno-135-23" href="#__codelineno-135-23"></a><span class="w">    </span><span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">stk</span><span class="p">;</span>
<a id="__codelineno-135-24" name="__codelineno-135-24" href="#__codelineno-135-24"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<a id="__codelineno-135-25" name="__codelineno-135-25" href="#__codelineno-135-25"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-135-26" name="__codelineno-135-26" href="#__codelineno-135-26"></a><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<a id="__codelineno-135-27" name="__codelineno-135-27" href="#__codelineno-135-27"></a><span class="w">        </span><span class="p">{</span>
<a id="__codelineno-135-28" name="__codelineno-135-28" href="#__codelineno-135-28"></a><span class="w">            </span><span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<a id="__codelineno-135-29" name="__codelineno-135-29" href="#__codelineno-135-29"></a><span class="w">            </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
<a id="__codelineno-135-30" name="__codelineno-135-30" href="#__codelineno-135-30"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-135-31" name="__codelineno-135-31" href="#__codelineno-135-31"></a><span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<a id="__codelineno-135-32" name="__codelineno-135-32" href="#__codelineno-135-32"></a><span class="w">        </span><span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<a id="__codelineno-135-33" name="__codelineno-135-33" href="#__codelineno-135-33"></a><span class="w">        </span><span class="n">nodes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
<a id="__codelineno-135-34" name="__codelineno-135-34" href="#__codelineno-135-34"></a><span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
<a id="__codelineno-135-35" name="__codelineno-135-35" href="#__codelineno-135-35"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-135-36" name="__codelineno-135-36" href="#__codelineno-135-36"></a><span class="p">}</span>
<a id="__codelineno-135-37" name="__codelineno-135-37" href="#__codelineno-135-37"></a>
<a id="__codelineno-135-38" name="__codelineno-135-38" href="#__codelineno-135-38"></a>
<a id="__codelineno-135-39" name="__codelineno-135-39" href="#__codelineno-135-39"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<a id="__codelineno-135-40" name="__codelineno-135-40" href="#__codelineno-135-40"></a><span class="p">{</span>
<a id="__codelineno-135-41" name="__codelineno-135-41" href="#__codelineno-135-41"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="w"> </span><span class="p">};</span>
<a id="__codelineno-135-42" name="__codelineno-135-42" href="#__codelineno-135-42"></a><span class="w">    </span><span class="n">TreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createTree</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<a id="__codelineno-135-43" name="__codelineno-135-43" href="#__codelineno-135-43"></a><span class="w">    </span><span class="n">levelOrderIter</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<a id="__codelineno-135-44" name="__codelineno-135-44" href="#__codelineno-135-44"></a>
<a id="__codelineno-135-45" name="__codelineno-135-45" href="#__codelineno-135-45"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-135-46" name="__codelineno-135-46" href="#__codelineno-135-46"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-135-47" name="__codelineno-135-47" href="#__codelineno-135-47"></a><span class="p">}</span>
</code></pre></div>
<h3 id="_44">数学<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h3>
<h4 id="_45">公倍数与公因数<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h4>
<h2 id="70">70、回调函数，什么时候回调，谁来回调<a class="headerlink" href="#70" title="Permanent link">&para;</a></h2>
<h3 id="_46">异步调用为什么要有回调函数<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h3>
<p>异步调用中的回调函数是一个非常重要的概念，特别是在处理需要长时间运行或可能阻塞的操作时，如网络请求、文件I/O操作或定时任务等。以下是一些原因，解释为什么异步调用需要回调函数：</p>
<ol>
<li>
<p><strong>避免阻塞主线程</strong>：</p>
<ul>
<li>在单线程环境中（例如JavaScript的事件循环），如果一个操作需要很长时间才能完成（如网络请求），同步调用会阻塞主线程，导致应用程序无法响应其他事件。通过异步调用，可以让主线程继续处理其他任务，而在操作完成时通过回调函数通知主线程。</li>
</ul>
</li>
<li>
<p><strong>提高性能和响应速度</strong>：</p>
<ul>
<li>异步调用允许多个操作并发执行，而不必等待每个操作顺序完成。这种方式可以显著提高应用程序的性能和响应速度。例如，在处理大量I/O操作时，异步调用可以让程序更快地响应用户操作。</li>
</ul>
</li>
<li>
<p><strong>处理并发操作</strong>：</p>
<ul>
<li>回调函数使得处理并发操作变得更加容易。多个异步操作可以同时进行，每个操作完成后调用相应的回调函数，处理结果或错误。</li>
</ul>
</li>
<li>
<p><strong>简化代码结构</strong>：</p>
<ul>
<li>使用回调函数可以将异步操作的逻辑与其完成后的处理逻辑分开，使代码更清晰，更易于维护。例如，网络请求的回调函数可以专门处理请求成功或失败后的逻辑，而不需要将这些逻辑混杂在一起。</li>
</ul>
</li>
<li>
<p><strong>灵活性</strong>：</p>
<ul>
<li>回调函数提供了很大的灵活性，可以根据不同的操作结果执行不同的处理逻辑。例如，可以根据网络请求的响应状态码，在回调函数中执行不同的操作。</li>
</ul>
</li>
</ol>
<h4 id="_47">总结<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h4>
<p>回调函数在异步调用中起到了关键作用，允许程序在长时间操作完成后执行特定的处理逻辑，而不阻塞主线程。这种机制提高了程序的性能和响应速度，使得处理并发操作变得更加容易和灵活。</p>
<p>好的，我们可以将上面的两个C++异步调用和回调函数示例改为C语言版本。以下是网络请求和文件I/O操作的C语言实现示例：</p>
<h3 id="1_2">1. <strong>网络请求</strong><a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h3>
<p>在C语言中，我们可以使用libcurl库来实现异步HTTP GET请求，并使用回调函数处理响应。以下是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-136-1" name="__codelineno-136-1" href="#__codelineno-136-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-136-2" name="__codelineno-136-2" href="#__codelineno-136-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-136-3" name="__codelineno-136-3" href="#__codelineno-136-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<a id="__codelineno-136-4" name="__codelineno-136-4" href="#__codelineno-136-4"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;curl/curl.h&gt;</span>
<a id="__codelineno-136-5" name="__codelineno-136-5" href="#__codelineno-136-5"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<a id="__codelineno-136-6" name="__codelineno-136-6" href="#__codelineno-136-6"></a>
<a id="__codelineno-136-7" name="__codelineno-136-7" href="#__codelineno-136-7"></a><span class="c1">// 回调函数，是libcurl在接收到HTTP响应数据时调用的函数，用于处理和存储接收到的数据</span>
<a id="__codelineno-136-8" name="__codelineno-136-8" href="#__codelineno-136-8"></a><span class="c1">// 这个函数将接收到的数据追加到 userp 指向的缓冲区中，并返回处理的数据大小。</span>
<a id="__codelineno-136-9" name="__codelineno-136-9" href="#__codelineno-136-9"></a><span class="kt">size_t</span><span class="w"> </span><span class="nf">WriteCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">contents</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">userp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-10" name="__codelineno-136-10" href="#__codelineno-136-10"></a><span class="w">    </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">userp</span><span class="p">)[</span><span class="n">strlen</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">userp</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nmemb</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<a id="__codelineno-136-11" name="__codelineno-136-11" href="#__codelineno-136-11"></a><span class="w">    </span><span class="n">strncat</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">userp</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">contents</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nmemb</span><span class="p">);</span>
<a id="__codelineno-136-12" name="__codelineno-136-12" href="#__codelineno-136-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nmemb</span><span class="p">;</span>
<a id="__codelineno-136-13" name="__codelineno-136-13" href="#__codelineno-136-13"></a><span class="p">}</span>
<a id="__codelineno-136-14" name="__codelineno-136-14" href="#__codelineno-136-14"></a>
<a id="__codelineno-136-15" name="__codelineno-136-15" href="#__codelineno-136-15"></a><span class="c1">// 线程函数，在线程中执行的函数，用于执行HTTP GET请求</span>
<a id="__codelineno-136-16" name="__codelineno-136-16" href="#__codelineno-136-16"></a><span class="c1">// 该函数初始化libcurl，设置URL、写入回调函数和写入数据缓冲区，执行HTTP GET请求，并在请求完成后调用用户提供的回调函数处理响应数据</span>
<a id="__codelineno-136-17" name="__codelineno-136-17" href="#__codelineno-136-17"></a><span class="c1">// 该函数分配内存存储URL和回调函数指针，创建并分离线程以执行HTTP GET请求。</span>
<a id="__codelineno-136-18" name="__codelineno-136-18" href="#__codelineno-136-18"></a><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">asyncHttpGet</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-19" name="__codelineno-136-19" href="#__codelineno-136-19"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-20" name="__codelineno-136-20" href="#__codelineno-136-20"></a><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">url</span><span class="p">;</span>
<a id="__codelineno-136-21" name="__codelineno-136-21" href="#__codelineno-136-21"></a><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<a id="__codelineno-136-22" name="__codelineno-136-22" href="#__codelineno-136-22"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span>
<a id="__codelineno-136-23" name="__codelineno-136-23" href="#__codelineno-136-23"></a>
<a id="__codelineno-136-24" name="__codelineno-136-24" href="#__codelineno-136-24"></a><span class="w">    </span><span class="n">CURL</span><span class="o">*</span><span class="w"> </span><span class="n">curl</span><span class="p">;</span>
<a id="__codelineno-136-25" name="__codelineno-136-25" href="#__codelineno-136-25"></a><span class="w">    </span><span class="n">CURLcode</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<a id="__codelineno-136-26" name="__codelineno-136-26" href="#__codelineno-136-26"></a><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">readBuffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<a id="__codelineno-136-27" name="__codelineno-136-27" href="#__codelineno-136-27"></a>
<a id="__codelineno-136-28" name="__codelineno-136-28" href="#__codelineno-136-28"></a><span class="w">    </span><span class="n">curl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curl_easy_init</span><span class="p">();</span>
<a id="__codelineno-136-29" name="__codelineno-136-29" href="#__codelineno-136-29"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-30" name="__codelineno-136-30" href="#__codelineno-136-30"></a><span class="w">        </span><span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">curl</span><span class="p">,</span><span class="w"> </span><span class="n">CURLOPT_URL</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">url</span><span class="p">);</span>
<a id="__codelineno-136-31" name="__codelineno-136-31" href="#__codelineno-136-31"></a><span class="w">        </span><span class="c1">// 如果HTTP GET请求成功，libcurl会调用 WriteCallback 函数将响应数据写入 readBuffer。</span>
<a id="__codelineno-136-32" name="__codelineno-136-32" href="#__codelineno-136-32"></a><span class="w">        </span><span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">curl</span><span class="p">,</span><span class="w"> </span><span class="n">CURLOPT_WRITEFUNCTION</span><span class="p">,</span><span class="w"> </span><span class="n">WriteCallback</span><span class="p">);</span>
<a id="__codelineno-136-33" name="__codelineno-136-33" href="#__codelineno-136-33"></a><span class="w">        </span><span class="n">curl_easy_setopt</span><span class="p">(</span><span class="n">curl</span><span class="p">,</span><span class="w"> </span><span class="n">CURLOPT_WRITEDATA</span><span class="p">,</span><span class="w"> </span><span class="n">readBuffer</span><span class="p">);</span>
<a id="__codelineno-136-34" name="__codelineno-136-34" href="#__codelineno-136-34"></a><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curl_easy_perform</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span>
<a id="__codelineno-136-35" name="__codelineno-136-35" href="#__codelineno-136-35"></a><span class="w">        </span><span class="n">curl_easy_cleanup</span><span class="p">(</span><span class="n">curl</span><span class="p">);</span>
<a id="__codelineno-136-36" name="__codelineno-136-36" href="#__codelineno-136-36"></a>
<a id="__codelineno-136-37" name="__codelineno-136-37" href="#__codelineno-136-37"></a><span class="w">        </span><span class="c1">// 请求完成后，asyncHttpGet 调用用户提供的回调函数 params-&gt;callback，即 handleHttpResponse，传递读取到的HTTP响应数据。</span>
<a id="__codelineno-136-38" name="__codelineno-136-38" href="#__codelineno-136-38"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CURLE_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-39" name="__codelineno-136-39" href="#__codelineno-136-39"></a><span class="w">            </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">readBuffer</span><span class="p">);</span><span class="w"> </span><span class="c1">// 请求成功，调用回调函数</span>
<a id="__codelineno-136-40" name="__codelineno-136-40" href="#__codelineno-136-40"></a><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-41" name="__codelineno-136-41" href="#__codelineno-136-41"></a><span class="w">            </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 请求失败，调用回调函数</span>
<a id="__codelineno-136-42" name="__codelineno-136-42" href="#__codelineno-136-42"></a><span class="w">        </span><span class="p">}</span>
<a id="__codelineno-136-43" name="__codelineno-136-43" href="#__codelineno-136-43"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-136-44" name="__codelineno-136-44" href="#__codelineno-136-44"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<a id="__codelineno-136-45" name="__codelineno-136-45" href="#__codelineno-136-45"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<a id="__codelineno-136-46" name="__codelineno-136-46" href="#__codelineno-136-46"></a><span class="p">}</span>
<a id="__codelineno-136-47" name="__codelineno-136-47" href="#__codelineno-136-47"></a>
<a id="__codelineno-136-48" name="__codelineno-136-48" href="#__codelineno-136-48"></a><span class="c1">// 异步HTTP GET请求函数</span>
<a id="__codelineno-136-49" name="__codelineno-136-49" href="#__codelineno-136-49"></a><span class="kt">void</span><span class="w"> </span><span class="nf">startAsyncHttpGet</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">url</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-50" name="__codelineno-136-50" href="#__codelineno-136-50"></a><span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="kr">thread</span><span class="p">;</span>
<a id="__codelineno-136-51" name="__codelineno-136-51" href="#__codelineno-136-51"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-52" name="__codelineno-136-52" href="#__codelineno-136-52"></a><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">url</span><span class="p">;</span>
<a id="__codelineno-136-53" name="__codelineno-136-53" href="#__codelineno-136-53"></a><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<a id="__codelineno-136-54" name="__codelineno-136-54" href="#__codelineno-136-54"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">));</span>
<a id="__codelineno-136-55" name="__codelineno-136-55" href="#__codelineno-136-55"></a><span class="w">    </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">url</span><span class="p">;</span>
<a id="__codelineno-136-56" name="__codelineno-136-56" href="#__codelineno-136-56"></a><span class="w">    </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span>
<a id="__codelineno-136-57" name="__codelineno-136-57" href="#__codelineno-136-57"></a><span class="w">    </span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">asyncHttpGet</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
<a id="__codelineno-136-58" name="__codelineno-136-58" href="#__codelineno-136-58"></a><span class="w">    </span><span class="n">pthread_detach</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
<a id="__codelineno-136-59" name="__codelineno-136-59" href="#__codelineno-136-59"></a><span class="p">}</span>
<a id="__codelineno-136-60" name="__codelineno-136-60" href="#__codelineno-136-60"></a>
<a id="__codelineno-136-61" name="__codelineno-136-61" href="#__codelineno-136-61"></a><span class="c1">// handleHttpResponse是一个用户定义的回调函数，用于处理完整的HTTP响应数据。它在异步HTTP GET请求完成后被调用</span>
<a id="__codelineno-136-62" name="__codelineno-136-62" href="#__codelineno-136-62"></a><span class="kt">void</span><span class="w"> </span><span class="nf">handleHttpResponse</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-63" name="__codelineno-136-63" href="#__codelineno-136-63"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;HTTP响应: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">);</span>
<a id="__codelineno-136-64" name="__codelineno-136-64" href="#__codelineno-136-64"></a><span class="p">}</span>
<a id="__codelineno-136-65" name="__codelineno-136-65" href="#__codelineno-136-65"></a>
<a id="__codelineno-136-66" name="__codelineno-136-66" href="#__codelineno-136-66"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-136-67" name="__codelineno-136-67" href="#__codelineno-136-67"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;开始异步HTTP GET请求...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-136-68" name="__codelineno-136-68" href="#__codelineno-136-68"></a><span class="w">    </span><span class="n">startAsyncHttpGet</span><span class="p">(</span><span class="s">&quot;http://example.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">handleHttpResponse</span><span class="p">);</span>
<a id="__codelineno-136-69" name="__codelineno-136-69" href="#__codelineno-136-69"></a>
<a id="__codelineno-136-70" name="__codelineno-136-70" href="#__codelineno-136-70"></a><span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// 等待一会儿以便看到异步操作的结果</span>
<a id="__codelineno-136-71" name="__codelineno-136-71" href="#__codelineno-136-71"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-136-72" name="__codelineno-136-72" href="#__codelineno-136-72"></a><span class="p">}</span>
</code></pre></div>
<h3 id="2-io">2. <strong>文件I/O</strong><a class="headerlink" href="#2-io" title="Permanent link">&para;</a></h3>
<p>在C语言中，我们可以使用标准库函数来实现异步文件读取，并使用回调函数处理读取的内容。以下是一个示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-137-1" name="__codelineno-137-1" href="#__codelineno-137-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-137-2" name="__codelineno-137-2" href="#__codelineno-137-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-137-3" name="__codelineno-137-3" href="#__codelineno-137-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<a id="__codelineno-137-4" name="__codelineno-137-4" href="#__codelineno-137-4"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<a id="__codelineno-137-5" name="__codelineno-137-5" href="#__codelineno-137-5"></a>
<a id="__codelineno-137-6" name="__codelineno-137-6" href="#__codelineno-137-6"></a><span class="c1">// 线程函数，用于读取文件内容</span>
<a id="__codelineno-137-7" name="__codelineno-137-7" href="#__codelineno-137-7"></a><span class="c1">// 新线程启动后，执行 asyncReadFile 函数。</span>
<a id="__codelineno-137-8" name="__codelineno-137-8" href="#__codelineno-137-8"></a><span class="c1">// asyncReadFile 函数尝试打开指定的文件并读取其内容。</span>
<a id="__codelineno-137-9" name="__codelineno-137-9" href="#__codelineno-137-9"></a><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">asyncReadFile</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-10" name="__codelineno-137-10" href="#__codelineno-137-10"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-11" name="__codelineno-137-11" href="#__codelineno-137-11"></a><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">;</span>
<a id="__codelineno-137-12" name="__codelineno-137-12" href="#__codelineno-137-12"></a><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<a id="__codelineno-137-13" name="__codelineno-137-13" href="#__codelineno-137-13"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span>
<a id="__codelineno-137-14" name="__codelineno-137-14" href="#__codelineno-137-14"></a>
<a id="__codelineno-137-15" name="__codelineno-137-15" href="#__codelineno-137-15"></a><span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<a id="__codelineno-137-16" name="__codelineno-137-16" href="#__codelineno-137-16"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-17" name="__codelineno-137-17" href="#__codelineno-137-17"></a><span class="w">        </span><span class="n">fseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">SEEK_END</span><span class="p">);</span>
<a id="__codelineno-137-18" name="__codelineno-137-18" href="#__codelineno-137-18"></a><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">fileSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ftell</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<a id="__codelineno-137-19" name="__codelineno-137-19" href="#__codelineno-137-19"></a><span class="w">        </span><span class="n">rewind</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<a id="__codelineno-137-20" name="__codelineno-137-20" href="#__codelineno-137-20"></a><span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">fileSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<a id="__codelineno-137-21" name="__codelineno-137-21" href="#__codelineno-137-21"></a><span class="w">        </span><span class="n">fread</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">fileSize</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">);</span>
<a id="__codelineno-137-22" name="__codelineno-137-22" href="#__codelineno-137-22"></a><span class="w">        </span><span class="n">content</span><span class="p">[</span><span class="n">fileSize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<a id="__codelineno-137-23" name="__codelineno-137-23" href="#__codelineno-137-23"></a><span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<a id="__codelineno-137-24" name="__codelineno-137-24" href="#__codelineno-137-24"></a><span class="w">        </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">content</span><span class="p">);</span><span class="w"> </span><span class="c1">// 文件读取成功，调用回调函数，并传递读取到的文件内容</span>
<a id="__codelineno-137-25" name="__codelineno-137-25" href="#__codelineno-137-25"></a><span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">content</span><span class="p">);</span>
<a id="__codelineno-137-26" name="__codelineno-137-26" href="#__codelineno-137-26"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-27" name="__codelineno-137-27" href="#__codelineno-137-27"></a><span class="w">        </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 文件读取失败，调用回调函数</span>
<a id="__codelineno-137-28" name="__codelineno-137-28" href="#__codelineno-137-28"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-137-29" name="__codelineno-137-29" href="#__codelineno-137-29"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<a id="__codelineno-137-30" name="__codelineno-137-30" href="#__codelineno-137-30"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<a id="__codelineno-137-31" name="__codelineno-137-31" href="#__codelineno-137-31"></a><span class="p">}</span>
<a id="__codelineno-137-32" name="__codelineno-137-32" href="#__codelineno-137-32"></a>
<a id="__codelineno-137-33" name="__codelineno-137-33" href="#__codelineno-137-33"></a><span class="c1">// 异步文件读取函数</span>
<a id="__codelineno-137-34" name="__codelineno-137-34" href="#__codelineno-137-34"></a><span class="kt">void</span><span class="w"> </span><span class="nf">startAsyncReadFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-35" name="__codelineno-137-35" href="#__codelineno-137-35"></a><span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="kr">thread</span><span class="p">;</span>
<a id="__codelineno-137-36" name="__codelineno-137-36" href="#__codelineno-137-36"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-37" name="__codelineno-137-37" href="#__codelineno-137-37"></a><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">;</span>
<a id="__codelineno-137-38" name="__codelineno-137-38" href="#__codelineno-137-38"></a><span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<a id="__codelineno-137-39" name="__codelineno-137-39" href="#__codelineno-137-39"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">));</span>
<a id="__codelineno-137-40" name="__codelineno-137-40" href="#__codelineno-137-40"></a><span class="w">    </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filename</span><span class="p">;</span>
<a id="__codelineno-137-41" name="__codelineno-137-41" href="#__codelineno-137-41"></a><span class="w">    </span><span class="n">params</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span>
<a id="__codelineno-137-42" name="__codelineno-137-42" href="#__codelineno-137-42"></a><span class="w">    </span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">asyncReadFile</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
<a id="__codelineno-137-43" name="__codelineno-137-43" href="#__codelineno-137-43"></a><span class="w">    </span><span class="n">pthread_detach</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
<a id="__codelineno-137-44" name="__codelineno-137-44" href="#__codelineno-137-44"></a><span class="p">}</span>
<a id="__codelineno-137-45" name="__codelineno-137-45" href="#__codelineno-137-45"></a>
<a id="__codelineno-137-46" name="__codelineno-137-46" href="#__codelineno-137-46"></a><span class="c1">// 回调函数定义</span>
<a id="__codelineno-137-47" name="__codelineno-137-47" href="#__codelineno-137-47"></a><span class="kt">void</span><span class="w"> </span><span class="nf">handleFileContent</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">content</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-48" name="__codelineno-137-48" href="#__codelineno-137-48"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;文件内容: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">content</span><span class="p">);</span>
<a id="__codelineno-137-49" name="__codelineno-137-49" href="#__codelineno-137-49"></a><span class="p">}</span>
<a id="__codelineno-137-50" name="__codelineno-137-50" href="#__codelineno-137-50"></a>
<a id="__codelineno-137-51" name="__codelineno-137-51" href="#__codelineno-137-51"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-137-52" name="__codelineno-137-52" href="#__codelineno-137-52"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;开始异步文件读取...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-137-53" name="__codelineno-137-53" href="#__codelineno-137-53"></a><span class="w">    </span><span class="c1">// 在 main 函数中，调用 startAsyncReadFile 函数，传入文件名和回调函数 handleFileContent。</span>
<a id="__codelineno-137-54" name="__codelineno-137-54" href="#__codelineno-137-54"></a><span class="w">    </span><span class="n">startAsyncReadFile</span><span class="p">(</span><span class="s">&quot;example.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">handleFileContent</span><span class="p">);</span>
<a id="__codelineno-137-55" name="__codelineno-137-55" href="#__codelineno-137-55"></a>
<a id="__codelineno-137-56" name="__codelineno-137-56" href="#__codelineno-137-56"></a><span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// 等待一会儿以便看到异步操作的结果</span>
<a id="__codelineno-137-57" name="__codelineno-137-57" href="#__codelineno-137-57"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-137-58" name="__codelineno-137-58" href="#__codelineno-137-58"></a><span class="p">}</span>
</code></pre></div>
<h3 id="_48">总结<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h3>
<p>在C语言中实现异步调用和回调函数时，主要是通过使用线程（如pthread库）来实现异步操作，并在操作完成后调用回调函数。与C++相比，C语言的回调函数实现更为直接，但也更依赖于手动管理内存和线程。</p>
<p>好的，我可以为你提供一个使用定时器的示例。我们可以使用POSIX定时器（如 <code>timer_create</code> 和 <code>timer_settime</code>）来实现定时器功能。下面是一个简单的示例，演示如何创建一个定时器并在定时器到期时调用回调函数。</p>
<h3 id="_49">示例代码<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-138-1" name="__codelineno-138-1" href="#__codelineno-138-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-138-2" name="__codelineno-138-2" href="#__codelineno-138-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-138-3" name="__codelineno-138-3" href="#__codelineno-138-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;signal.h&gt;</span>
<a id="__codelineno-138-4" name="__codelineno-138-4" href="#__codelineno-138-4"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>
<a id="__codelineno-138-5" name="__codelineno-138-5" href="#__codelineno-138-5"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<a id="__codelineno-138-6" name="__codelineno-138-6" href="#__codelineno-138-6"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>
<a id="__codelineno-138-7" name="__codelineno-138-7" href="#__codelineno-138-7"></a>
<a id="__codelineno-138-8" name="__codelineno-138-8" href="#__codelineno-138-8"></a><span class="c1">// 定时器到期时的回调函数</span>
<a id="__codelineno-138-9" name="__codelineno-138-9" href="#__codelineno-138-9"></a><span class="kt">void</span><span class="w"> </span><span class="nf">timerCallback</span><span class="p">(</span><span class="k">union</span><span class="w"> </span><span class="nc">sigval</span><span class="w"> </span><span class="n">sv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-138-10" name="__codelineno-138-10" href="#__codelineno-138-10"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">sv</span><span class="p">.</span><span class="n">sival_ptr</span><span class="p">;</span>
<a id="__codelineno-138-11" name="__codelineno-138-11" href="#__codelineno-138-11"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;定时器到期: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span>
<a id="__codelineno-138-12" name="__codelineno-138-12" href="#__codelineno-138-12"></a><span class="p">}</span>
<a id="__codelineno-138-13" name="__codelineno-138-13" href="#__codelineno-138-13"></a>
<a id="__codelineno-138-14" name="__codelineno-138-14" href="#__codelineno-138-14"></a><span class="c1">// 创建并启动定时器</span>
<a id="__codelineno-138-15" name="__codelineno-138-15" href="#__codelineno-138-15"></a><span class="kt">void</span><span class="w"> </span><span class="nf">startTimer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">seconds</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">union</span><span class="w"> </span><span class="nc">sigval</span><span class="p">),</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-138-16" name="__codelineno-138-16" href="#__codelineno-138-16"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="w"> </span><span class="n">sev</span><span class="p">;</span>
<a id="__codelineno-138-17" name="__codelineno-138-17" href="#__codelineno-138-17"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">itimerspec</span><span class="w"> </span><span class="n">its</span><span class="p">;</span>
<a id="__codelineno-138-18" name="__codelineno-138-18" href="#__codelineno-138-18"></a><span class="w">    </span><span class="kt">timer_t</span><span class="w"> </span><span class="n">timerid</span><span class="p">;</span>
<a id="__codelineno-138-19" name="__codelineno-138-19" href="#__codelineno-138-19"></a>
<a id="__codelineno-138-20" name="__codelineno-138-20" href="#__codelineno-138-20"></a><span class="w">    </span><span class="c1">// 配置定时器事件</span>
<a id="__codelineno-138-21" name="__codelineno-138-21" href="#__codelineno-138-21"></a><span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="p">));</span>
<a id="__codelineno-138-22" name="__codelineno-138-22" href="#__codelineno-138-22"></a><span class="w">    </span><span class="n">sev</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用线程通知</span>
<a id="__codelineno-138-23" name="__codelineno-138-23" href="#__codelineno-138-23"></a><span class="w">    </span><span class="n">sev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">message</span><span class="p">;</span><span class="w"> </span><span class="c1">// 传递给回调函数的参数</span>
<a id="__codelineno-138-24" name="__codelineno-138-24" href="#__codelineno-138-24"></a><span class="w">    </span><span class="n">sev</span><span class="p">.</span><span class="n">sigev_notify_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span><span class="w"> </span><span class="c1">// 回调函数</span>
<a id="__codelineno-138-25" name="__codelineno-138-25" href="#__codelineno-138-25"></a>
<a id="__codelineno-138-26" name="__codelineno-138-26" href="#__codelineno-138-26"></a><span class="w">    </span><span class="c1">// 创建定时器</span>
<a id="__codelineno-138-27" name="__codelineno-138-27" href="#__codelineno-138-27"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer_create</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timerid</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-138-28" name="__codelineno-138-28" href="#__codelineno-138-28"></a><span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;timer_create&quot;</span><span class="p">);</span>
<a id="__codelineno-138-29" name="__codelineno-138-29" href="#__codelineno-138-29"></a><span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<a id="__codelineno-138-30" name="__codelineno-138-30" href="#__codelineno-138-30"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-138-31" name="__codelineno-138-31" href="#__codelineno-138-31"></a>
<a id="__codelineno-138-32" name="__codelineno-138-32" href="#__codelineno-138-32"></a><span class="w">    </span><span class="c1">// 配置定时器时间</span>
<a id="__codelineno-138-33" name="__codelineno-138-33" href="#__codelineno-138-33"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seconds</span><span class="p">;</span>
<a id="__codelineno-138-34" name="__codelineno-138-34" href="#__codelineno-138-34"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-138-35" name="__codelineno-138-35" href="#__codelineno-138-35"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不重复</span>
<a id="__codelineno-138-36" name="__codelineno-138-36" href="#__codelineno-138-36"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_nsec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-138-37" name="__codelineno-138-37" href="#__codelineno-138-37"></a>
<a id="__codelineno-138-38" name="__codelineno-138-38" href="#__codelineno-138-38"></a><span class="w">    </span><span class="c1">// 启动定时器</span>
<a id="__codelineno-138-39" name="__codelineno-138-39" href="#__codelineno-138-39"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer_settime</span><span class="p">(</span><span class="n">timerid</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">its</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-138-40" name="__codelineno-138-40" href="#__codelineno-138-40"></a><span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;timer_settime&quot;</span><span class="p">);</span>
<a id="__codelineno-138-41" name="__codelineno-138-41" href="#__codelineno-138-41"></a><span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<a id="__codelineno-138-42" name="__codelineno-138-42" href="#__codelineno-138-42"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-138-43" name="__codelineno-138-43" href="#__codelineno-138-43"></a><span class="p">}</span>
<a id="__codelineno-138-44" name="__codelineno-138-44" href="#__codelineno-138-44"></a>
<a id="__codelineno-138-45" name="__codelineno-138-45" href="#__codelineno-138-45"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-138-46" name="__codelineno-138-46" href="#__codelineno-138-46"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;启动定时器...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-138-47" name="__codelineno-138-47" href="#__codelineno-138-47"></a><span class="w">    </span><span class="n">startTimer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">timerCallback</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;定时器已到期!&quot;</span><span class="p">);</span>
<a id="__codelineno-138-48" name="__codelineno-138-48" href="#__codelineno-138-48"></a>
<a id="__codelineno-138-49" name="__codelineno-138-49" href="#__codelineno-138-49"></a><span class="w">    </span><span class="c1">// 主线程等待，确保定时器回调函数有机会运行</span>
<a id="__codelineno-138-50" name="__codelineno-138-50" href="#__codelineno-138-50"></a><span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<a id="__codelineno-138-51" name="__codelineno-138-51" href="#__codelineno-138-51"></a>
<a id="__codelineno-138-52" name="__codelineno-138-52" href="#__codelineno-138-52"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-138-53" name="__codelineno-138-53" href="#__codelineno-138-53"></a><span class="p">}</span>
</code></pre></div>
<h3 id="_50">代码解释<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>定时器到期时的回调函数 <code>timerCallback</code></strong>:</p>
<ul>
<li>这是定时器到期时调用的函数。
<div class="highlight"><pre><span></span><code><a id="__codelineno-139-1" name="__codelineno-139-1" href="#__codelineno-139-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">timerCallback</span><span class="p">(</span><span class="k">union</span><span class="w"> </span><span class="nc">sigval</span><span class="w"> </span><span class="n">sv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-139-2" name="__codelineno-139-2" href="#__codelineno-139-2"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">sv</span><span class="p">.</span><span class="n">sival_ptr</span><span class="p">;</span>
<a id="__codelineno-139-3" name="__codelineno-139-3" href="#__codelineno-139-3"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;定时器到期: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span>
<a id="__codelineno-139-4" name="__codelineno-139-4" href="#__codelineno-139-4"></a><span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>创建并启动定时器的函数 <code>startTimer</code></strong>:</p>
<ul>
<li>这个函数创建一个定时器并设置其到期时间和回调函数。
<div class="highlight"><pre><span></span><code><a id="__codelineno-140-1" name="__codelineno-140-1" href="#__codelineno-140-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">startTimer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">seconds</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">union</span><span class="w"> </span><span class="nc">sigval</span><span class="p">),</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-140-2" name="__codelineno-140-2" href="#__codelineno-140-2"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="w"> </span><span class="n">sev</span><span class="p">;</span>
<a id="__codelineno-140-3" name="__codelineno-140-3" href="#__codelineno-140-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">itimerspec</span><span class="w"> </span><span class="n">its</span><span class="p">;</span>
<a id="__codelineno-140-4" name="__codelineno-140-4" href="#__codelineno-140-4"></a><span class="w">    </span><span class="kt">timer_t</span><span class="w"> </span><span class="n">timerid</span><span class="p">;</span>
<a id="__codelineno-140-5" name="__codelineno-140-5" href="#__codelineno-140-5"></a>
<a id="__codelineno-140-6" name="__codelineno-140-6" href="#__codelineno-140-6"></a><span class="w">    </span><span class="c1">// 配置定时器事件</span>
<a id="__codelineno-140-7" name="__codelineno-140-7" href="#__codelineno-140-7"></a><span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sigevent</span><span class="p">));</span>
<a id="__codelineno-140-8" name="__codelineno-140-8" href="#__codelineno-140-8"></a><span class="w">    </span><span class="n">sev</span><span class="p">.</span><span class="n">sigev_notify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGEV_THREAD</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用线程通知</span>
<a id="__codelineno-140-9" name="__codelineno-140-9" href="#__codelineno-140-9"></a><span class="w">    </span><span class="n">sev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">message</span><span class="p">;</span><span class="w"> </span><span class="c1">// 传递给回调函数的参数</span>
<a id="__codelineno-140-10" name="__codelineno-140-10" href="#__codelineno-140-10"></a><span class="w">    </span><span class="n">sev</span><span class="p">.</span><span class="n">sigev_notify_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span><span class="w"> </span><span class="c1">// 回调函数</span>
<a id="__codelineno-140-11" name="__codelineno-140-11" href="#__codelineno-140-11"></a>
<a id="__codelineno-140-12" name="__codelineno-140-12" href="#__codelineno-140-12"></a><span class="w">    </span><span class="c1">// 创建定时器</span>
<a id="__codelineno-140-13" name="__codelineno-140-13" href="#__codelineno-140-13"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer_create</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timerid</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-140-14" name="__codelineno-140-14" href="#__codelineno-140-14"></a><span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;timer_create&quot;</span><span class="p">);</span>
<a id="__codelineno-140-15" name="__codelineno-140-15" href="#__codelineno-140-15"></a><span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<a id="__codelineno-140-16" name="__codelineno-140-16" href="#__codelineno-140-16"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-140-17" name="__codelineno-140-17" href="#__codelineno-140-17"></a>
<a id="__codelineno-140-18" name="__codelineno-140-18" href="#__codelineno-140-18"></a><span class="w">    </span><span class="c1">// 配置定时器时间</span>
<a id="__codelineno-140-19" name="__codelineno-140-19" href="#__codelineno-140-19"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seconds</span><span class="p">;</span>
<a id="__codelineno-140-20" name="__codelineno-140-20" href="#__codelineno-140-20"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-140-21" name="__codelineno-140-21" href="#__codelineno-140-21"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不重复</span>
<a id="__codelineno-140-22" name="__codelineno-140-22" href="#__codelineno-140-22"></a><span class="w">    </span><span class="n">its</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_nsec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-140-23" name="__codelineno-140-23" href="#__codelineno-140-23"></a>
<a id="__codelineno-140-24" name="__codelineno-140-24" href="#__codelineno-140-24"></a><span class="w">    </span><span class="c1">// 启动定时器</span>
<a id="__codelineno-140-25" name="__codelineno-140-25" href="#__codelineno-140-25"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timer_settime</span><span class="p">(</span><span class="n">timerid</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">its</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-140-26" name="__codelineno-140-26" href="#__codelineno-140-26"></a><span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;timer_settime&quot;</span><span class="p">);</span>
<a id="__codelineno-140-27" name="__codelineno-140-27" href="#__codelineno-140-27"></a><span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<a id="__codelineno-140-28" name="__codelineno-140-28" href="#__codelineno-140-28"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-140-29" name="__codelineno-140-29" href="#__codelineno-140-29"></a><span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>主函数 <code>main</code></strong>:</p>
<ul>
<li>主函数启动定时器并等待一段时间以确保定时器回调函数有机会运行。
<div class="highlight"><pre><span></span><code><a id="__codelineno-141-1" name="__codelineno-141-1" href="#__codelineno-141-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-141-2" name="__codelineno-141-2" href="#__codelineno-141-2"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;启动定时器...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-141-3" name="__codelineno-141-3" href="#__codelineno-141-3"></a><span class="w">    </span><span class="n">startTimer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">timerCallback</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;定时器已到期!&quot;</span><span class="p">);</span>
<a id="__codelineno-141-4" name="__codelineno-141-4" href="#__codelineno-141-4"></a>
<a id="__codelineno-141-5" name="__codelineno-141-5" href="#__codelineno-141-5"></a><span class="w">    </span><span class="c1">// 主线程等待，确保定时器回调函数有机会运行</span>
<a id="__codelineno-141-6" name="__codelineno-141-6" href="#__codelineno-141-6"></a><span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<a id="__codelineno-141-7" name="__codelineno-141-7" href="#__codelineno-141-7"></a>
<a id="__codelineno-141-8" name="__codelineno-141-8" href="#__codelineno-141-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-141-9" name="__codelineno-141-9" href="#__codelineno-141-9"></a><span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="_51">总结<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><code>timerCallback</code></strong> 是定时器到期时调用的回调函数。</li>
<li><strong><code>startTimer</code></strong> 创建并启动定时器，设置定时器到期时间和回调函数。</li>
<li><strong><code>main</code></strong> 函数启动定时器并等待一段时间以确保定时器回调函数有机会运行。</li>
</ul>
<p>这个示例展示了如何使用POSIX定时器创建一个简单的定时器，并在定时器到期时调用回调函数。</p>
<h2 id="75static">75、类的static成员函数<a class="headerlink" href="#75static" title="Permanent link">&para;</a></h2>
<p>是的，C++中的类的静态成员函数（<code>static</code> 成员函数）的声明和定义可以分开。静态成员函数是属于类本身的，而不是类的某个对象，因此它们可以在类外部进行定义。</p>
<h3 id="_52">示例代码<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h3>
<p>以下是一个简单的示例，展示了如何声明和定义一个类的静态成员函数。</p>
<h4 id="_53">类声明（头文件）<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h4>
<p>首先，在头文件中声明类和静态成员函数：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-142-1" name="__codelineno-142-1" href="#__codelineno-142-1"></a><span class="c1">// MyClass.h</span>
<a id="__codelineno-142-2" name="__codelineno-142-2" href="#__codelineno-142-2"></a><span class="cp">#ifndef MYCLASS_H</span>
<a id="__codelineno-142-3" name="__codelineno-142-3" href="#__codelineno-142-3"></a><span class="cp">#define MYCLASS_H</span>
<a id="__codelineno-142-4" name="__codelineno-142-4" href="#__codelineno-142-4"></a>
<a id="__codelineno-142-5" name="__codelineno-142-5" href="#__codelineno-142-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-142-6" name="__codelineno-142-6" href="#__codelineno-142-6"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-142-7" name="__codelineno-142-7" href="#__codelineno-142-7"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">staticFunction</span><span class="p">();</span>
<a id="__codelineno-142-8" name="__codelineno-142-8" href="#__codelineno-142-8"></a><span class="p">};</span>
<a id="__codelineno-142-9" name="__codelineno-142-9" href="#__codelineno-142-9"></a>
<a id="__codelineno-142-10" name="__codelineno-142-10" href="#__codelineno-142-10"></a><span class="cp">#endif </span><span class="c1">// MYCLASS_H</span>
</code></pre></div>
<h4 id="_54">类定义（源文件）<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h4>
<p>然后，在源文件中定义静态成员函数：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-143-1" name="__codelineno-143-1" href="#__codelineno-143-1"></a><span class="c1">// MyClass.cpp</span>
<a id="__codelineno-143-2" name="__codelineno-143-2" href="#__codelineno-143-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;MyClass.h&quot;</span>
<a id="__codelineno-143-3" name="__codelineno-143-3" href="#__codelineno-143-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-143-4" name="__codelineno-143-4" href="#__codelineno-143-4"></a>
<a id="__codelineno-143-5" name="__codelineno-143-5" href="#__codelineno-143-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">MyClass::staticFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-143-6" name="__codelineno-143-6" href="#__codelineno-143-6"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;This is a static member function.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-143-7" name="__codelineno-143-7" href="#__codelineno-143-7"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_55">主函数（测试文件）<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h4>
<p>最后，在主函数中调用静态成员函数：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-144-1" name="__codelineno-144-1" href="#__codelineno-144-1"></a><span class="c1">// main.cpp</span>
<a id="__codelineno-144-2" name="__codelineno-144-2" href="#__codelineno-144-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;MyClass.h&quot;</span>
<a id="__codelineno-144-3" name="__codelineno-144-3" href="#__codelineno-144-3"></a>
<a id="__codelineno-144-4" name="__codelineno-144-4" href="#__codelineno-144-4"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-144-5" name="__codelineno-144-5" href="#__codelineno-144-5"></a><span class="w">    </span><span class="n">MyClass</span><span class="o">::</span><span class="n">staticFunction</span><span class="p">();</span>
<a id="__codelineno-144-6" name="__codelineno-144-6" href="#__codelineno-144-6"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-144-7" name="__codelineno-144-7" href="#__codelineno-144-7"></a><span class="p">}</span>
</code></pre></div>
<h3 id="_56">解释<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>类声明</strong>：</p>
<ul>
<li>在 <code>MyClass.h</code> 中，声明了一个类 <code>MyClass</code>，并在类中声明了一个静态成员函数 <code>staticFunction</code>。
<div class="highlight"><pre><span></span><code><a id="__codelineno-145-1" name="__codelineno-145-1" href="#__codelineno-145-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-145-2" name="__codelineno-145-2" href="#__codelineno-145-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-145-3" name="__codelineno-145-3" href="#__codelineno-145-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">staticFunction</span><span class="p">();</span>
<a id="__codelineno-145-4" name="__codelineno-145-4" href="#__codelineno-145-4"></a><span class="p">};</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>类定义</strong>：</p>
<ul>
<li>在 <code>MyClass.cpp</code> 中，定义了静态成员函数 <code>staticFunction</code>。注意在定义时需要使用类名 <code>MyClass::</code> 进行限定。
<div class="highlight"><pre><span></span><code><a id="__codelineno-146-1" name="__codelineno-146-1" href="#__codelineno-146-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">MyClass::staticFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-146-2" name="__codelineno-146-2" href="#__codelineno-146-2"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;This is a static member function.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-146-3" name="__codelineno-146-3" href="#__codelineno-146-3"></a><span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>主函数</strong>：</p>
<ul>
<li>在 <code>main.cpp</code> 中，调用静态成员函数 <code>MyClass::staticFunction()</code>。
<div class="highlight"><pre><span></span><code><a id="__codelineno-147-1" name="__codelineno-147-1" href="#__codelineno-147-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-147-2" name="__codelineno-147-2" href="#__codelineno-147-2"></a><span class="w">    </span><span class="n">MyClass</span><span class="o">::</span><span class="n">staticFunction</span><span class="p">();</span>
<a id="__codelineno-147-3" name="__codelineno-147-3" href="#__codelineno-147-3"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-147-4" name="__codelineno-147-4" href="#__codelineno-147-4"></a><span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
</ol>
<h3 id="_57">总结<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h3>
<ul>
<li>静态成员函数可以在类声明中进行声明，并在类外部进行定义。</li>
<li>定义静态成员函数时，需要使用类名进行限定。</li>
<li>静态成员函数可以通过类名直接调用，而不需要创建类的实例。</li>
</ul>
<h2 id="8075">80、什么时候有必要像75这么做<a class="headerlink" href="#8075" title="Permanent link">&para;</a></h2>
<p>理解什么时候将类的成员函数声明为 <code>static</code> 是设计和架构中一个重要的决策。以下是一些常见的情况和理由，说明什么时候有必要将类的成员函数声明为 <code>static</code>：</p>
<h3 id="1_3">1. 不依赖于实例成员<a class="headerlink" href="#1_3" title="Permanent link">&para;</a></h3>
<p><strong>目的</strong>：当函数不需要访问或修改类的实例成员时，将其声明为 <code>static</code>。</p>
<ul>
<li><strong>示例</strong>：类的某些实用工具函数（utility functions），如数学计算、字符串操作等，不需要访问类的实例成员。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-148-1" name="__codelineno-148-1" href="#__codelineno-148-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MathUtil</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-148-2" name="__codelineno-148-2" href="#__codelineno-148-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-148-3" name="__codelineno-148-3" href="#__codelineno-148-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-148-4" name="__codelineno-148-4" href="#__codelineno-148-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-148-5" name="__codelineno-148-5" href="#__codelineno-148-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-148-6" name="__codelineno-148-6" href="#__codelineno-148-6"></a><span class="p">};</span>
</code></pre></div>
<h3 id="2_1">2. 全局唯一的行为<a class="headerlink" href="#2_1" title="Permanent link">&para;</a></h3>
<p><strong>目的</strong>：当函数的行为在整个程序中是全局唯一的，并且不依赖于任何特定对象的状态。</p>
<ul>
<li><strong>示例</strong>：单例模式中的获取实例函数。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-149-1" name="__codelineno-149-1" href="#__codelineno-149-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-149-2" name="__codelineno-149-2" href="#__codelineno-149-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-149-3" name="__codelineno-149-3" href="#__codelineno-149-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Singleton</span><span class="o">&amp;</span><span class="w"> </span><span class="n">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-149-4" name="__codelineno-149-4" href="#__codelineno-149-4"></a><span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span>
<a id="__codelineno-149-5" name="__codelineno-149-5" href="#__codelineno-149-5"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span>
<a id="__codelineno-149-6" name="__codelineno-149-6" href="#__codelineno-149-6"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-149-7" name="__codelineno-149-7" href="#__codelineno-149-7"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-149-8" name="__codelineno-149-8" href="#__codelineno-149-8"></a><span class="w">    </span><span class="n">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-149-9" name="__codelineno-149-9" href="#__codelineno-149-9"></a><span class="p">};</span>
</code></pre></div>
<h3 id="3_1">3. 工厂方法<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h3>
<p><strong>目的</strong>：当需要提供创建类实例的工厂方法时，可以将其声明为 <code>static</code>。</p>
<ul>
<li><strong>示例</strong>：工厂方法模式，用于创建对象实例。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-150-1" name="__codelineno-150-1" href="#__codelineno-150-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Product</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-150-2" name="__codelineno-150-2" href="#__codelineno-150-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-150-3" name="__codelineno-150-3" href="#__codelineno-150-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Product</span><span class="o">*</span><span class="w"> </span><span class="n">createProduct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-150-4" name="__codelineno-150-4" href="#__codelineno-150-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Product</span><span class="p">();</span>
<a id="__codelineno-150-5" name="__codelineno-150-5" href="#__codelineno-150-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-150-6" name="__codelineno-150-6" href="#__codelineno-150-6"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-150-7" name="__codelineno-150-7" href="#__codelineno-150-7"></a><span class="w">    </span><span class="n">Product</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-150-8" name="__codelineno-150-8" href="#__codelineno-150-8"></a><span class="p">};</span>
</code></pre></div>
<h3 id="4">4. 访问静态成员<a class="headerlink" href="#4" title="Permanent link">&para;</a></h3>
<p><strong>目的</strong>：当函数需要访问或操作类的静态成员变量时，可以将其声明为 <code>static</code>。</p>
<ul>
<li><strong>示例</strong>：计数器类，记录实例的数量。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-151-1" name="__codelineno-151-1" href="#__codelineno-151-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-151-2" name="__codelineno-151-2" href="#__codelineno-151-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-151-3" name="__codelineno-151-3" href="#__codelineno-151-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">getCount</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-151-4" name="__codelineno-151-4" href="#__codelineno-151-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<a id="__codelineno-151-5" name="__codelineno-151-5" href="#__codelineno-151-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-151-6" name="__codelineno-151-6" href="#__codelineno-151-6"></a><span class="w">    </span><span class="n">Counter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-151-7" name="__codelineno-151-7" href="#__codelineno-151-7"></a><span class="w">        </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<a id="__codelineno-151-8" name="__codelineno-151-8" href="#__codelineno-151-8"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-151-9" name="__codelineno-151-9" href="#__codelineno-151-9"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-151-10" name="__codelineno-151-10" href="#__codelineno-151-10"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<a id="__codelineno-151-11" name="__codelineno-151-11" href="#__codelineno-151-11"></a><span class="p">};</span>
<a id="__codelineno-151-12" name="__codelineno-151-12" href="#__codelineno-151-12"></a>
<a id="__codelineno-151-13" name="__codelineno-151-13" href="#__codelineno-151-13"></a><span class="kt">int</span><span class="w"> </span><span class="n">Counter</span><span class="o">::</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<h3 id="5_1">5. 不需要多态行为<a class="headerlink" href="#5_1" title="Permanent link">&para;</a></h3>
<p><strong>目的</strong>：当函数不需要虚函数的多态行为时，可以将其声明为 <code>static</code>。</p>
<ul>
<li><strong>示例</strong>：实用工具函数不需要多态行为。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-152-1" name="__codelineno-152-1" href="#__codelineno-152-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Utility</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-152-2" name="__codelineno-152-2" href="#__codelineno-152-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-152-3" name="__codelineno-152-3" href="#__codelineno-152-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-152-4" name="__codelineno-152-4" href="#__codelineno-152-4"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Utility message&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-152-5" name="__codelineno-152-5" href="#__codelineno-152-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-152-6" name="__codelineno-152-6" href="#__codelineno-152-6"></a><span class="p">};</span>
</code></pre></div>
<h3 id="6_1">6. 提高可读性和组织性<a class="headerlink" href="#6_1" title="Permanent link">&para;</a></h3>
<p><strong>目的</strong>：将一些与对象无关的功能组织在类中，以提高代码的可读性和组织性。</p>
<ul>
<li><strong>示例</strong>：将相关的实用工具函数组织在一个类中。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-153-1" name="__codelineno-153-1" href="#__codelineno-153-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">StringUtil</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-153-2" name="__codelineno-153-2" href="#__codelineno-153-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-153-3" name="__codelineno-153-3" href="#__codelineno-153-3"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">toUpperCase</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-153-4" name="__codelineno-153-4" href="#__codelineno-153-4"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<a id="__codelineno-153-5" name="__codelineno-153-5" href="#__codelineno-153-5"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="o">::</span><span class="n">toupper</span><span class="p">);</span>
<a id="__codelineno-153-6" name="__codelineno-153-6" href="#__codelineno-153-6"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<a id="__codelineno-153-7" name="__codelineno-153-7" href="#__codelineno-153-7"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-153-8" name="__codelineno-153-8" href="#__codelineno-153-8"></a><span class="p">};</span>
</code></pre></div>
<h3 id="_58">总结<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h3>
<p>将类的成员函数声明为 <code>static</code> 的主要原因包括：</p>
<ol>
<li>函数不依赖于实例成员。</li>
<li>函数的行为在全局范围内唯一。</li>
<li>提供工厂方法创建实例。</li>
<li>访问或操作类的静态成员变量。</li>
<li>函数不需要多态行为。</li>
<li>提高代码的可读性和组织性。</li>
</ol>
<p>通过将合适的函数声明为 <code>static</code>，可以提高代码的清晰度、可维护性和性能。</p>
<h2 id="85this">85、this指针的作用<a class="headerlink" href="#85this" title="Permanent link">&para;</a></h2>
<p><strong>1. this指针的用处:</strong>
一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this<a href="https://so.csdn.net/so/search?q=作用域&amp;spm=1001.2101.3001.7020">作用域</a>是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 　　例如，调用date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换 .
<strong>2. 2.this指针的使用:</strong>
一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</p>
<h2 id="90">90、类的虚函数声明<a class="headerlink" href="#90" title="Permanent link">&para;</a></h2>
<p>在C++中，函数声明后加上空的花括号 <code>{}</code> 表示该函数是一个空的实现。这在定义抽象基类或接口类时是常见的做法，尤其是当你希望提供一个默认的空实现，以便派生类可以选择性地覆盖这些方法。</p>
<ol>
<li><strong>接口类</strong>：为接口类中的虚函数提供默认的空实现，使得派生类可以选择性地实现这些方法。</li>
<li>
<p><strong>抽象基类</strong>：为抽象基类中的虚函数提供默认的空实现，避免派生类必须实现所有的虚函数。</p>
</li>
<li>
<p><strong>不加 <code>{}</code> 并且不提供定义</strong>：编译器会报链接错误，除非这些函数是纯虚函数（使用 <code>= 0</code>）。</p>
</li>
<li><strong>加 <code>{}</code></strong>：提供一个默认的空实现，派生类可以选择性地重载这些方法。</li>
<li><strong>使用 <code>= 0</code></strong>：声明纯虚函数，强制派生类必须实现这些方法。</li>
</ol>
<h2 id="95">95、回调函数什么时候需要声明成静态<a class="headerlink" href="#95" title="Permanent link">&para;</a></h2>
<p>在编程中，回调函数（callback function）是一种通过函数指针传递的函数，它允许一个函数调用另一个函数。回调函数可以用于事件处理、异步操作等。回调函数是否需要声明为静态取决于具体的使用场景和需求。</p>
<h3 id="_59">什么时候需要声明回调函数为静态<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>与类无关的回调函数</strong>：</li>
<li>如果回调函数不依赖于类的实例成员或状态，可以将其声明为静态函数。这种情况下，回调函数只需要访问静态成员或全局变量。</li>
<li><strong>与类实例无关的回调函数</strong>：</li>
<li>如果回调函数的逻辑与类的具体实例无关，声明为静态可以避免不必要的对象创建和传递。</li>
<li><strong>C 风格的回调函数</strong>：</li>
<li>在 C 语言中，回调函数通常是全局函数或静态函数（文件作用域），因为 C 不支持类和成员函数。</li>
<li><strong>避免对象实例传递</strong>：</li>
<li>在某些情况下，回调函数需要传递给 C 库或其他不支持成员函数回调的接口。这时，可以将回调函数声明为静态，以避免传递对象实例。</li>
</ol>
<h3 id="_60">示例<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h3>
<h4 id="_61">静态成员函数作为回调函数<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h4>
<p>假设我们有一个类 <code>MyClass</code>，其中有一个静态回调函数：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-154-1" name="__codelineno-154-1" href="#__codelineno-154-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-154-2" name="__codelineno-154-2" href="#__codelineno-154-2"></a>
<a id="__codelineno-154-3" name="__codelineno-154-3" href="#__codelineno-154-3"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-154-4" name="__codelineno-154-4" href="#__codelineno-154-4"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-154-5" name="__codelineno-154-5" href="#__codelineno-154-5"></a><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">staticCallback</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-154-6" name="__codelineno-154-6" href="#__codelineno-154-6"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Static callback called with value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-154-7" name="__codelineno-154-7" href="#__codelineno-154-7"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-154-8" name="__codelineno-154-8" href="#__codelineno-154-8"></a><span class="p">};</span>
<a id="__codelineno-154-9" name="__codelineno-154-9" href="#__codelineno-154-9"></a>
<a id="__codelineno-154-10" name="__codelineno-154-10" href="#__codelineno-154-10"></a><span class="kt">void</span><span class="w"> </span><span class="nf">registerCallback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-154-11" name="__codelineno-154-11" href="#__codelineno-154-11"></a><span class="w">    </span><span class="c1">// 模拟注册回调函数</span>
<a id="__codelineno-154-12" name="__codelineno-154-12" href="#__codelineno-154-12"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<a id="__codelineno-154-13" name="__codelineno-154-13" href="#__codelineno-154-13"></a><span class="p">}</span>
<a id="__codelineno-154-14" name="__codelineno-154-14" href="#__codelineno-154-14"></a>
<a id="__codelineno-154-15" name="__codelineno-154-15" href="#__codelineno-154-15"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-154-16" name="__codelineno-154-16" href="#__codelineno-154-16"></a><span class="w">    </span><span class="c1">// 注册静态回调函数</span>
<a id="__codelineno-154-17" name="__codelineno-154-17" href="#__codelineno-154-17"></a><span class="w">    </span><span class="n">registerCallback</span><span class="p">(</span><span class="n">MyClass</span><span class="o">::</span><span class="n">staticCallback</span><span class="p">);</span>
<a id="__codelineno-154-18" name="__codelineno-154-18" href="#__codelineno-154-18"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-154-19" name="__codelineno-154-19" href="#__codelineno-154-19"></a><span class="p">}</span>
</code></pre></div>
<p>在上述示例中，<code>staticCallback</code> 是一个静态成员函数，它可以直接传递给 <code>registerCallback</code>，因为它不依赖于 <code>MyClass</code> 的实例。</p>
<h4 id="_62">非静态成员函数作为回调函数<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h4>
<p>如果回调函数需要访问类的实例成员，可以使用 <code>std::function</code> 和 <code>std::bind</code>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-155-1" name="__codelineno-155-1" href="#__codelineno-155-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-155-2" name="__codelineno-155-2" href="#__codelineno-155-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>
<a id="__codelineno-155-3" name="__codelineno-155-3" href="#__codelineno-155-3"></a>
<a id="__codelineno-155-4" name="__codelineno-155-4" href="#__codelineno-155-4"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-155-5" name="__codelineno-155-5" href="#__codelineno-155-5"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-155-6" name="__codelineno-155-6" href="#__codelineno-155-6"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">memberCallback</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-155-7" name="__codelineno-155-7" href="#__codelineno-155-7"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Member callback called with value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-155-8" name="__codelineno-155-8" href="#__codelineno-155-8"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-155-9" name="__codelineno-155-9" href="#__codelineno-155-9"></a><span class="p">};</span>
<a id="__codelineno-155-10" name="__codelineno-155-10" href="#__codelineno-155-10"></a>
<a id="__codelineno-155-11" name="__codelineno-155-11" href="#__codelineno-155-11"></a><span class="kt">void</span><span class="w"> </span><span class="nf">registerCallback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-155-12" name="__codelineno-155-12" href="#__codelineno-155-12"></a><span class="w">    </span><span class="c1">// 模拟注册回调函数</span>
<a id="__codelineno-155-13" name="__codelineno-155-13" href="#__codelineno-155-13"></a><span class="w">    </span><span class="n">callback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<a id="__codelineno-155-14" name="__codelineno-155-14" href="#__codelineno-155-14"></a><span class="p">}</span>
<a id="__codelineno-155-15" name="__codelineno-155-15" href="#__codelineno-155-15"></a>
<a id="__codelineno-155-16" name="__codelineno-155-16" href="#__codelineno-155-16"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-155-17" name="__codelineno-155-17" href="#__codelineno-155-17"></a><span class="w">    </span><span class="n">MyClass</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span>
<a id="__codelineno-155-18" name="__codelineno-155-18" href="#__codelineno-155-18"></a><span class="w">    </span><span class="c1">// 使用 std::bind 将成员函数绑定到对象实例</span>
<a id="__codelineno-155-19" name="__codelineno-155-19" href="#__codelineno-155-19"></a><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">memberCallback</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<a id="__codelineno-155-20" name="__codelineno-155-20" href="#__codelineno-155-20"></a><span class="w">    </span><span class="n">registerCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
<a id="__codelineno-155-21" name="__codelineno-155-21" href="#__codelineno-155-21"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-155-22" name="__codelineno-155-22" href="#__codelineno-155-22"></a><span class="p">}</span>
</code></pre></div>
<p>在这个示例中，<code>memberCallback</code> 是一个非静态成员函数。我们使用 <code>std::bind</code> 将其绑定到对象实例 <code>obj</code>，并传递给 <code>registerCallback</code>。</p>
<h3 id="_63">总结<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h3>
<p>回调函数声明为静态的情况主要包括：</p>
<ol>
<li>回调函数不依赖于类的实例成员或状态。</li>
<li>回调函数的逻辑与类的具体实例无关。</li>
<li>回调函数需要传递给不支持成员函数回调的接口。</li>
</ol>
<p>在这些情况下，声明回调函数为静态可以简化代码，并避免不必要的对象创建和传递。如果回调函数需要访问类的实例成员，则可以考虑使用 <code>std::function</code> 和 <code>std::bind</code> 或其他类似的机制来实现。</p>
<h2 id="100switch-case">100、switch-case中变量的作用域<a class="headerlink" href="#100switch-case" title="Permanent link">&para;</a></h2>
<p>case没加括号，变量在整个switch里都存在</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-156-1" name="__codelineno-156-1" href="#__codelineno-156-1"></a><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<a id="__codelineno-156-2" name="__codelineno-156-2" href="#__codelineno-156-2"></a><span class="p">{</span>
<a id="__codelineno-156-3" name="__codelineno-156-3" href="#__codelineno-156-3"></a><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<a id="__codelineno-156-4" name="__codelineno-156-4" href="#__codelineno-156-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-156-5" name="__codelineno-156-5" href="#__codelineno-156-5"></a><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<a id="__codelineno-156-6" name="__codelineno-156-6" href="#__codelineno-156-6"></a>
<a id="__codelineno-156-7" name="__codelineno-156-7" href="#__codelineno-156-7"></a><span class="p">}</span>
</code></pre></div>
<p>case加了括号，在case的括号没了之后，变量就没了</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-157-1" name="__codelineno-157-1" href="#__codelineno-157-1"></a><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<a id="__codelineno-157-2" name="__codelineno-157-2" href="#__codelineno-157-2"></a><span class="p">{</span>
<a id="__codelineno-157-3" name="__codelineno-157-3" href="#__codelineno-157-3"></a><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<a id="__codelineno-157-4" name="__codelineno-157-4" href="#__codelineno-157-4"></a><span class="p">{</span>
<a id="__codelineno-157-5" name="__codelineno-157-5" href="#__codelineno-157-5"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">         </span>
<a id="__codelineno-157-6" name="__codelineno-157-6" href="#__codelineno-157-6"></a><span class="p">}</span>
<a id="__codelineno-157-7" name="__codelineno-157-7" href="#__codelineno-157-7"></a><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<a id="__codelineno-157-8" name="__codelineno-157-8" href="#__codelineno-157-8"></a>
<a id="__codelineno-157-9" name="__codelineno-157-9" href="#__codelineno-157-9"></a><span class="p">}</span>
</code></pre></div>
<h2 id="105c_str">105、c_str<a class="headerlink" href="#105c_str" title="Permanent link">&para;</a></h2>
<p><code>c_str()</code> 方法返回一个指向字符串内部字符数组的指针。这个指针的生命周期与字符串对象的生命周期一致。也就是说，只要字符串对象存在并且没有被修改，<code>c_str()</code> 返回的指针就是有效的。</p>
<h3 id="_64">详细解释<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h3>
<p><code>std::string::c_str()</code> 返回一个 <code>const char*</code>，指向字符串对象内部的字符数据。这个指针在以下情况下是安全的：</p>
<ol>
<li><strong>字符串对象存在</strong>：只要字符串对象本身没有被销毁。</li>
<li><strong>字符串对象未被修改</strong>：只要字符串对象没有被修改（如通过非 <code>const</code> 方法）。</li>
</ol>
<h2 id="110">110、什么时候接口或回调函数传入*或**<a class="headerlink" href="#110" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-158-1" name="__codelineno-158-1" href="#__codelineno-158-1"></a>const * ：不希望修改变量时
<a id="__codelineno-158-2" name="__codelineno-158-2" href="#__codelineno-158-2"></a>* ：需要对这个变量进行更改时，比如void* arg，经常需要进行类型强转
<a id="__codelineno-158-3" name="__codelineno-158-3" href="#__codelineno-158-3"></a>** ：1、需要修改指针本身时 2、释放内存的函数，需要将指针设置为null以避免悬空指针
</code></pre></div>
<h2 id="_65">示例<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-159-1" name="__codelineno-159-1" href="#__codelineno-159-1"></a><span class="cm">/**</span>
<a id="__codelineno-159-2" name="__codelineno-159-2" href="#__codelineno-159-2"></a><span class="cm">    * @brief                同步发送请求，并阻塞等待响应</span>
<a id="__codelineno-159-3" name="__codelineno-159-3" href="#__codelineno-159-3"></a><span class="cm">    * @param conn_id        [IN] 连接id</span>
<a id="__codelineno-159-4" name="__codelineno-159-4" href="#__codelineno-159-4"></a><span class="cm">    * @param req            [IN] 请求的内容</span>
<a id="__codelineno-159-5" name="__codelineno-159-5" href="#__codelineno-159-5"></a><span class="cm">    * @param resp_data      [OUT] 响应的内容，上层需要传入一个指针的地址</span>
<a id="__codelineno-159-6" name="__codelineno-159-6" href="#__codelineno-159-6"></a><span class="cm">    * @param resp_data_len  [OUT] resp_data的长度</span>
<a id="__codelineno-159-7" name="__codelineno-159-7" href="#__codelineno-159-7"></a><span class="cm">    * @return               请求结果：200表示成功，其它失败(&lt;0为自定义错误码 ucc_ucp_error_e)</span>
<a id="__codelineno-159-8" name="__codelineno-159-8" href="#__codelineno-159-8"></a><span class="cm">    * @note                 resp_data使用后需要调用ucc_free_resp_data释放内存</span>
<a id="__codelineno-159-9" name="__codelineno-159-9" href="#__codelineno-159-9"></a><span class="cm">    */</span>
<a id="__codelineno-159-10" name="__codelineno-159-10" href="#__codelineno-159-10"></a><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ucc_conn_req_sync</span><span class="p">)(</span><span class="n">ucc_conn_id</span><span class="w"> </span><span class="n">conn_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ucc_conn_req_t</span><span class="w"> </span><span class="o">*</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">resp_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">resp_data_len</span><span class="p">);</span>
</code></pre></div>
<ol>
<li><strong>动态分配内存并返回指针</strong>：</li>
<li>函数 <code>ucc_conn_req_sync</code> 需要在内部为响应数据分配内存，并将该内存的地址返回给调用者。</li>
<li>如果使用 <code>char*</code>，函数只能修改局部变量的值，无法将新分配的内存地址传递回调用者。</li>
<li>使用 <code>char**</code> 允许函数修改调用者传入的指针，使其指向新分配的内存。</li>
<li><strong>避免悬空指针</strong>：</li>
<li>当函数内部为 <code>resp_data</code> 分配内存时，使用 <code>char**</code> 允许函数确保调用者的指针指向有效的内存地址。</li>
<li>这样可以避免调用者在函数返回后使用未初始化或无效的指针。</li>
</ol>
<h4 id="_66">函数实现示例<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h4>
<p>以下是一个可能的实现示例，展示了为什么需要使用 <code>char**</code>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-160-1" name="__codelineno-160-1" href="#__codelineno-160-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<a id="__codelineno-160-2" name="__codelineno-160-2" href="#__codelineno-160-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-160-3" name="__codelineno-160-3" href="#__codelineno-160-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<a id="__codelineno-160-4" name="__codelineno-160-4" href="#__codelineno-160-4"></a>
<a id="__codelineno-160-5" name="__codelineno-160-5" href="#__codelineno-160-5"></a><span class="c1">// 定义连接 ID 和请求类型（具体类型根据实际情况定义）</span>
<a id="__codelineno-160-6" name="__codelineno-160-6" href="#__codelineno-160-6"></a><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ucc_conn_id</span><span class="p">;</span>
<a id="__codelineno-160-7" name="__codelineno-160-7" href="#__codelineno-160-7"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-8" name="__codelineno-160-8" href="#__codelineno-160-8"></a><span class="w">    </span><span class="c1">// 请求内容的具体字段</span>
<a id="__codelineno-160-9" name="__codelineno-160-9" href="#__codelineno-160-9"></a><span class="p">}</span><span class="w"> </span><span class="n">ucc_conn_req_t</span><span class="p">;</span>
<a id="__codelineno-160-10" name="__codelineno-160-10" href="#__codelineno-160-10"></a>
<a id="__codelineno-160-11" name="__codelineno-160-11" href="#__codelineno-160-11"></a><span class="c1">// 自定义错误码（示例）</span>
<a id="__codelineno-160-12" name="__codelineno-160-12" href="#__codelineno-160-12"></a><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-13" name="__codelineno-160-13" href="#__codelineno-160-13"></a><span class="w">    </span><span class="n">UCC_SUCCESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span>
<a id="__codelineno-160-14" name="__codelineno-160-14" href="#__codelineno-160-14"></a><span class="w">    </span><span class="n">UCC_ERROR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span>
<a id="__codelineno-160-15" name="__codelineno-160-15" href="#__codelineno-160-15"></a><span class="p">}</span><span class="w"> </span><span class="n">ucc_ucp_error_e</span><span class="p">;</span>
<a id="__codelineno-160-16" name="__codelineno-160-16" href="#__codelineno-160-16"></a>
<a id="__codelineno-160-17" name="__codelineno-160-17" href="#__codelineno-160-17"></a><span class="c1">// 模拟的同步请求函数</span>
<a id="__codelineno-160-18" name="__codelineno-160-18" href="#__codelineno-160-18"></a><span class="kt">int</span><span class="w"> </span><span class="nf">ucc_conn_req_sync</span><span class="p">(</span><span class="n">ucc_conn_id</span><span class="w"> </span><span class="n">conn_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ucc_conn_req_t</span><span class="w"> </span><span class="o">*</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">resp_data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">resp_data_len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-19" name="__codelineno-160-19" href="#__codelineno-160-19"></a><span class="w">    </span><span class="c1">// 模拟响应数据</span>
<a id="__codelineno-160-20" name="__codelineno-160-20" href="#__codelineno-160-20"></a><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Response from server&quot;</span><span class="p">;</span>
<a id="__codelineno-160-21" name="__codelineno-160-21" href="#__codelineno-160-21"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
<a id="__codelineno-160-22" name="__codelineno-160-22" href="#__codelineno-160-22"></a>
<a id="__codelineno-160-23" name="__codelineno-160-23" href="#__codelineno-160-23"></a><span class="w">    </span><span class="c1">// 分配内存并复制响应数据</span>
<a id="__codelineno-160-24" name="__codelineno-160-24" href="#__codelineno-160-24"></a><span class="w">    </span><span class="o">*</span><span class="n">resp_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<a id="__codelineno-160-25" name="__codelineno-160-25" href="#__codelineno-160-25"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">resp_data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-26" name="__codelineno-160-26" href="#__codelineno-160-26"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">UCC_ERROR</span><span class="p">;</span><span class="w"> </span><span class="c1">// 内存分配失败</span>
<a id="__codelineno-160-27" name="__codelineno-160-27" href="#__codelineno-160-27"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-160-28" name="__codelineno-160-28" href="#__codelineno-160-28"></a><span class="w">    </span><span class="n">strcpy</span><span class="p">(</span><span class="o">*</span><span class="n">resp_data</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">);</span>
<a id="__codelineno-160-29" name="__codelineno-160-29" href="#__codelineno-160-29"></a>
<a id="__codelineno-160-30" name="__codelineno-160-30" href="#__codelineno-160-30"></a><span class="w">    </span><span class="c1">// 设置响应数据长度</span>
<a id="__codelineno-160-31" name="__codelineno-160-31" href="#__codelineno-160-31"></a><span class="w">    </span><span class="o">*</span><span class="n">resp_data_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<a id="__codelineno-160-32" name="__codelineno-160-32" href="#__codelineno-160-32"></a>
<a id="__codelineno-160-33" name="__codelineno-160-33" href="#__codelineno-160-33"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">UCC_SUCCESS</span><span class="p">;</span>
<a id="__codelineno-160-34" name="__codelineno-160-34" href="#__codelineno-160-34"></a><span class="p">}</span>
<a id="__codelineno-160-35" name="__codelineno-160-35" href="#__codelineno-160-35"></a>
<a id="__codelineno-160-36" name="__codelineno-160-36" href="#__codelineno-160-36"></a><span class="c1">// 释放响应数据的函数</span>
<a id="__codelineno-160-37" name="__codelineno-160-37" href="#__codelineno-160-37"></a><span class="kt">void</span><span class="w"> </span><span class="nf">ucc_conn_free_resp_data</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">respData</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-38" name="__codelineno-160-38" href="#__codelineno-160-38"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">respData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">respData</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-39" name="__codelineno-160-39" href="#__codelineno-160-39"></a><span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">respData</span><span class="p">);</span>
<a id="__codelineno-160-40" name="__codelineno-160-40" href="#__codelineno-160-40"></a><span class="w">        </span><span class="o">*</span><span class="n">respData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将指针置为 NULL 以避免悬空指针</span>
<a id="__codelineno-160-41" name="__codelineno-160-41" href="#__codelineno-160-41"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-160-42" name="__codelineno-160-42" href="#__codelineno-160-42"></a><span class="p">}</span>
<a id="__codelineno-160-43" name="__codelineno-160-43" href="#__codelineno-160-43"></a>
<a id="__codelineno-160-44" name="__codelineno-160-44" href="#__codelineno-160-44"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-45" name="__codelineno-160-45" href="#__codelineno-160-45"></a><span class="w">    </span><span class="n">ucc_conn_id</span><span class="w"> </span><span class="n">conn_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<a id="__codelineno-160-46" name="__codelineno-160-46" href="#__codelineno-160-46"></a><span class="w">    </span><span class="n">ucc_conn_req_t</span><span class="w"> </span><span class="n">req</span><span class="p">;</span>
<a id="__codelineno-160-47" name="__codelineno-160-47" href="#__codelineno-160-47"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">resp_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<a id="__codelineno-160-48" name="__codelineno-160-48" href="#__codelineno-160-48"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">resp_data_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-160-49" name="__codelineno-160-49" href="#__codelineno-160-49"></a>
<a id="__codelineno-160-50" name="__codelineno-160-50" href="#__codelineno-160-50"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ucc_conn_req_sync</span><span class="p">(</span><span class="n">conn_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resp_data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resp_data_len</span><span class="p">);</span>
<a id="__codelineno-160-51" name="__codelineno-160-51" href="#__codelineno-160-51"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UCC_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-52" name="__codelineno-160-52" href="#__codelineno-160-52"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Response: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">resp_data</span><span class="p">);</span>
<a id="__codelineno-160-53" name="__codelineno-160-53" href="#__codelineno-160-53"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Response Length: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">resp_data_len</span><span class="p">);</span>
<a id="__codelineno-160-54" name="__codelineno-160-54" href="#__codelineno-160-54"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-55" name="__codelineno-160-55" href="#__codelineno-160-55"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Request failed with error code: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<a id="__codelineno-160-56" name="__codelineno-160-56" href="#__codelineno-160-56"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-160-57" name="__codelineno-160-57" href="#__codelineno-160-57"></a>
<a id="__codelineno-160-58" name="__codelineno-160-58" href="#__codelineno-160-58"></a><span class="w">    </span><span class="c1">// 释放响应数据</span>
<a id="__codelineno-160-59" name="__codelineno-160-59" href="#__codelineno-160-59"></a><span class="w">    </span><span class="n">ucc_conn_free_resp_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resp_data</span><span class="p">);</span>
<a id="__codelineno-160-60" name="__codelineno-160-60" href="#__codelineno-160-60"></a>
<a id="__codelineno-160-61" name="__codelineno-160-61" href="#__codelineno-160-61"></a><span class="w">    </span><span class="c1">// 确认内存已释放并且指针已置为 NULL</span>
<a id="__codelineno-160-62" name="__codelineno-160-62" href="#__codelineno-160-62"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">resp_data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-63" name="__codelineno-160-63" href="#__codelineno-160-63"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Response data memory has been freed and pointer is NULL.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-160-64" name="__codelineno-160-64" href="#__codelineno-160-64"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-160-65" name="__codelineno-160-65" href="#__codelineno-160-65"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Failed to free response data memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<a id="__codelineno-160-66" name="__codelineno-160-66" href="#__codelineno-160-66"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-160-67" name="__codelineno-160-67" href="#__codelineno-160-67"></a>
<a id="__codelineno-160-68" name="__codelineno-160-68" href="#__codelineno-160-68"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-160-69" name="__codelineno-160-69" href="#__codelineno-160-69"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_67">解释<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h4>
<ol>
<li><strong>动态内存分配</strong>：</li>
<li>在 <code>ucc_conn_req_sync</code> 函数中，使用 <code>malloc</code> 分配内存，并将分配的内存地址赋值给 <code>*resp_data</code>。</li>
<li>由于 <code>resp_data</code> 是 <code>char**</code> 类型，<code>*resp_data</code> 是 <code>char*</code>，可以用来存储分配的内存地址。</li>
<li><strong>返回分配的内存地址</strong>：</li>
<li>函数返回后，调用者可以通过 <code>resp_data</code> 访问分配的内存，因为 <code>resp_data</code> 被传递的是指针的地址。</li>
<li><strong>避免悬空指针</strong>：</li>
<li>使用 <code>char**</code> 确保 <code>ucc_conn_req_sync</code> 函数可以正确地将分配的内存地址返回给调用者，避免调用者使用未初始化的指针。</li>
</ol>
<h4 id="_68">总结<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h4>
<p>使用 <code>char**</code> 是为了能够在函数内部为响应数据分配内存，并将分配的内存地址返回给调用者。这种方式确保了调用者能够正确接收到并使用分配的内存，从而避免悬空指针和未初始化指针的问题。</p>
<h3 id="_69">释放内存示例<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h3>
<h4 id="char">使用 <code>char*</code><a class="headerlink" href="#char" title="Permanent link">&para;</a></h4>
<p>如果你只需要释放内存，但不需要修改指针本身，可以使用 <code>char*</code>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-161-1" name="__codelineno-161-1" href="#__codelineno-161-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-161-2" name="__codelineno-161-2" href="#__codelineno-161-2"></a>
<a id="__codelineno-161-3" name="__codelineno-161-3" href="#__codelineno-161-3"></a><span class="kt">void</span><span class="w"> </span><span class="nf">free_memory</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-161-4" name="__codelineno-161-4" href="#__codelineno-161-4"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<a id="__codelineno-161-5" name="__codelineno-161-5" href="#__codelineno-161-5"></a><span class="w">    </span><span class="c1">// 这里不能将 ptr 置为 NULL，因为 ptr 是局部变量，修改它不会影响到调用者的指针</span>
<a id="__codelineno-161-6" name="__codelineno-161-6" href="#__codelineno-161-6"></a><span class="p">}</span>
<a id="__codelineno-161-7" name="__codelineno-161-7" href="#__codelineno-161-7"></a>
<a id="__codelineno-161-8" name="__codelineno-161-8" href="#__codelineno-161-8"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-161-9" name="__codelineno-161-9" href="#__codelineno-161-9"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<a id="__codelineno-161-10" name="__codelineno-161-10" href="#__codelineno-161-10"></a><span class="w">    </span><span class="c1">// 使用 str ...</span>
<a id="__codelineno-161-11" name="__codelineno-161-11" href="#__codelineno-161-11"></a><span class="w">    </span><span class="n">free_memory</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<a id="__codelineno-161-12" name="__codelineno-161-12" href="#__codelineno-161-12"></a><span class="w">    </span><span class="c1">// 这里 str 仍然指向已经释放的内存，可能导致悬空指针问题</span>
<a id="__codelineno-161-13" name="__codelineno-161-13" href="#__codelineno-161-13"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-161-14" name="__codelineno-161-14" href="#__codelineno-161-14"></a><span class="p">}</span>
</code></pre></div>
<h4 id="char_1">使用 <code>char**</code><a class="headerlink" href="#char_1" title="Permanent link">&para;</a></h4>
<p>如果你需要在释放内存后将指针设置为 <code>NULL</code>，以避免悬空指针问题，可以使用 <code>char**</code>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-162-1" name="__codelineno-162-1" href="#__codelineno-162-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<a id="__codelineno-162-2" name="__codelineno-162-2" href="#__codelineno-162-2"></a>
<a id="__codelineno-162-3" name="__codelineno-162-3" href="#__codelineno-162-3"></a><span class="kt">void</span><span class="w"> </span><span class="nf">free_memory</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-162-4" name="__codelineno-162-4" href="#__codelineno-162-4"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<a id="__codelineno-162-5" name="__codelineno-162-5" href="#__codelineno-162-5"></a><span class="w">    </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// 将指针设置为 NULL</span>
<a id="__codelineno-162-6" name="__codelineno-162-6" href="#__codelineno-162-6"></a><span class="p">}</span>
<a id="__codelineno-162-7" name="__codelineno-162-7" href="#__codelineno-162-7"></a>
<a id="__codelineno-162-8" name="__codelineno-162-8" href="#__codelineno-162-8"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-162-9" name="__codelineno-162-9" href="#__codelineno-162-9"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<a id="__codelineno-162-10" name="__codelineno-162-10" href="#__codelineno-162-10"></a><span class="w">    </span><span class="c1">// 使用 str ...</span>
<a id="__codelineno-162-11" name="__codelineno-162-11" href="#__codelineno-162-11"></a><span class="w">    </span><span class="n">free_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
<a id="__codelineno-162-12" name="__codelineno-162-12" href="#__codelineno-162-12"></a><span class="w">    </span><span class="c1">// 这里 str 已经被设置为 NULL，不会导致悬空指针问题</span>
<a id="__codelineno-162-13" name="__codelineno-162-13" href="#__codelineno-162-13"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-162-14" name="__codelineno-162-14" href="#__codelineno-162-14"></a><span class="p">}</span>
</code></pre></div>
<h4 id="_70">示例说明<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>使用 <code>char\*</code></strong>：只适用于释放内存，但不会修改调用者的指针。如果调用者继续使用该指针，可能会导致悬空指针问题。</li>
<li><strong>使用 <code>char\**</code></strong>：适用于释放内存并将指针设置为 <code>NULL</code>，避免悬空指针问题。通过传递指针的地址，函数可以修改调用者的指针。</li>
</ul>
<h4 id="_71">总结<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>释放内存但不修改指针</strong>：使用 <code>char*</code>。</li>
<li><strong>释放内存并将指针设置为 <code>NULL</code></strong>：使用 <code>char**</code>。</li>
</ul>
<h2 id="115">115、指针终极理解<a class="headerlink" href="#115" title="Permanent link">&para;</a></h2>
<p>指针本身存放的东西是个地址，你在操作这个地址时，操作的是这个地址上的变量（即指针指向的变量）</p>
<p>如果想要操作指针本身，就得用 <code>**</code> (就是获取这个指针本身的地址)</p>
<h2 id="120stdmutex">120、明确std::mutex锁<a class="headerlink" href="#120stdmutex" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>明确锁的作用域</strong>：确保每个互斥锁只保护特定的数据区域。</li>
<li><strong>使用 RAII</strong>：使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 自动管理锁的生命周期。</li>
<li><strong>避免死锁</strong>：如果需要同时锁定多个互斥锁，确保总是以相同的顺序锁定它们。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-163-1" name="__codelineno-163-1" href="#__codelineno-163-1"></a><span class="c1">// 实现了具体的UCP客户端功能</span>
<a id="__codelineno-163-2" name="__codelineno-163-2" href="#__codelineno-163-2"></a><span class="n">class</span><span class="w"> </span><span class="n">BlegClientUcp</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-163-3" name="__codelineno-163-3" href="#__codelineno-163-3"></a><span class="n">public</span><span class="o">:</span>
<a id="__codelineno-163-4" name="__codelineno-163-4" href="#__codelineno-163-4"></a><span class="w">    </span><span class="n">using</span><span class="w"> </span><span class="n">Ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BlegClientUcp</span><span class="o">&gt;</span><span class="p">;</span>
<a id="__codelineno-163-5" name="__codelineno-163-5" href="#__codelineno-163-5"></a>
<a id="__codelineno-163-6" name="__codelineno-163-6" href="#__codelineno-163-6"></a><span class="w">    </span><span class="n">BlegClientUcp</span><span class="p">();</span>
<a id="__codelineno-163-7" name="__codelineno-163-7" href="#__codelineno-163-7"></a><span class="w">    </span><span class="o">~</span><span class="n">BlegClientUcp</span><span class="p">();</span>
<a id="__codelineno-163-8" name="__codelineno-163-8" href="#__codelineno-163-8"></a><span class="w">    </span><span class="n">BlegClientUcp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">BlegClientUcp</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delete</span><span class="p">;</span>
<a id="__codelineno-163-9" name="__codelineno-163-9" href="#__codelineno-163-9"></a><span class="w">    </span><span class="n">BlegClientUcp</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">BlegClientUcp</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delete</span><span class="p">;</span>
<a id="__codelineno-163-10" name="__codelineno-163-10" href="#__codelineno-163-10"></a>
<a id="__codelineno-163-11" name="__codelineno-163-11" href="#__codelineno-163-11"></a><span class="w">    </span><span class="kt">bool</span><span class="w">            </span><span class="nf">Init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">bleg_client_init_param_t</span><span class="o">*</span><span class="w"> </span><span class="n">initParam</span><span class="p">);</span>
<a id="__codelineno-163-12" name="__codelineno-163-12" href="#__codelineno-163-12"></a><span class="w">    </span><span class="n">switch_status_t</span><span class="w"> </span><span class="nf">Start</span><span class="p">();</span>
<a id="__codelineno-163-13" name="__codelineno-163-13" href="#__codelineno-163-13"></a><span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="nf">Exit</span><span class="p">();</span>
<a id="__codelineno-163-14" name="__codelineno-163-14" href="#__codelineno-163-14"></a><span class="w">    </span><span class="n">TypeClientId</span><span class="w">    </span><span class="nf">GetClientId</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_clientId</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<a id="__codelineno-163-15" name="__codelineno-163-15" href="#__codelineno-163-15"></a><span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="nf">UcpMessageHandle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">endpoint_ucp_message_cb_t</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span><span class="w">                             </span><span class="c1">// ucp回调处理入口</span>
<a id="__codelineno-163-16" name="__codelineno-163-16" href="#__codelineno-163-16"></a><span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="nf">UcpMsgRespParse</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">url</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dataLen</span><span class="p">);</span><span class="w">                    </span><span class="c1">// 对ucp异步响应的消息进行解析</span>
<a id="__codelineno-163-17" name="__codelineno-163-17" href="#__codelineno-163-17"></a><span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="nf">UcpVarQuery</span><span class="p">();</span><span class="w">                                                                      </span><span class="c1">// 定时发送变量查询消息</span>
<a id="__codelineno-163-18" name="__codelineno-163-18" href="#__codelineno-163-18"></a><span class="w">    </span><span class="n">switch_status_t</span><span class="w"> </span><span class="nf">SendMsgSync</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">bleg_msg_t</span><span class="o">*</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w">                                    </span><span class="c1">// 发送同步消息</span>
<a id="__codelineno-163-19" name="__codelineno-163-19" href="#__codelineno-163-19"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w">           </span><span class="nf">GetVarSync</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">varName</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">bleg_get_var_param_t</span><span class="o">*</span><span class="w"> </span><span class="n">varParam</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w"> </span><span class="c1">// 同步获取变量的值</span>
<a id="__codelineno-163-20" name="__codelineno-163-20" href="#__codelineno-163-20"></a><span class="w">    </span><span class="n">switch_status_t</span><span class="w"> </span><span class="nf">SubscribeVar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">varName</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">bleg_sub_var_param_t</span><span class="o">*</span><span class="w"> </span><span class="n">subParam</span><span class="p">);</span><span class="w">            </span><span class="c1">// 变量订阅</span>
<a id="__codelineno-163-21" name="__codelineno-163-21" href="#__codelineno-163-21"></a><span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="nf">UnSubscribeVar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">varName</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">bleg_msg_t</span><span class="o">*</span><span class="w"> </span><span class="n">unsubMsg</span><span class="p">);</span><span class="w">                    </span><span class="c1">// 变量解订阅</span>
<a id="__codelineno-163-22" name="__codelineno-163-22" href="#__codelineno-163-22"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">     </span><span class="nf">DumpInfo</span><span class="p">();</span>
<a id="__codelineno-163-23" name="__codelineno-163-23" href="#__codelineno-163-23"></a>
<a id="__codelineno-163-24" name="__codelineno-163-24" href="#__codelineno-163-24"></a><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w">           </span><span class="nf">GetVarSyncVideoSourceAuto</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<a id="__codelineno-163-25" name="__codelineno-163-25" href="#__codelineno-163-25"></a>
<a id="__codelineno-163-26" name="__codelineno-163-26" href="#__codelineno-163-26"></a><span class="n">private</span><span class="o">:</span>
<a id="__codelineno-163-27" name="__codelineno-163-27" href="#__codelineno-163-27"></a><span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="n">VarUnSubInternal</span><span class="p">(</span><span class="n">VarSubInfo</span><span class="o">::</span><span class="n">Ptr</span><span class="w"> </span><span class="n">varInfo</span><span class="p">);</span>
<a id="__codelineno-163-28" name="__codelineno-163-28" href="#__codelineno-163-28"></a>
<a id="__codelineno-163-29" name="__codelineno-163-29" href="#__codelineno-163-29"></a><span class="n">private</span><span class="o">:</span>
<a id="__codelineno-163-30" name="__codelineno-163-30" href="#__codelineno-163-30"></a><span class="w">    </span><span class="c1">// 变量相关</span>
<a id="__codelineno-163-31" name="__codelineno-163-31" href="#__codelineno-163-31"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">VarSubInfo</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="w">    </span><span class="n">m_varInfoMap</span><span class="p">;</span><span class="w">           </span><span class="c1">// 变量信息的索引表：key是var的name，value是varInfo</span>
<a id="__codelineno-163-32" name="__codelineno-163-32" href="#__codelineno-163-32"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w">                                          </span><span class="n">m_varInfoMapMutex</span><span class="p">;</span>
<a id="__codelineno-163-33" name="__codelineno-163-33" href="#__codelineno-163-33"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">UcpMsg</span><span class="p">,</span><span class="w"> </span><span class="n">VarSubInfoVec</span><span class="p">,</span><span class="w"> </span><span class="n">UcpMsgCompare</span><span class="o">&gt;</span><span class="w">      </span><span class="n">m_varSendMap</span><span class="p">;</span><span class="w">           </span><span class="c1">// 定时发送变量的msg映射表：key是ucp的get指令的msg，value是相同get-msg的变量集</span>
<a id="__codelineno-163-34" name="__codelineno-163-34" href="#__codelineno-163-34"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w">                                          </span><span class="n">m_varSendMapMutex</span><span class="p">;</span>
<a id="__codelineno-163-35" name="__codelineno-163-35" href="#__codelineno-163-35"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">VarSubInfoVec</span><span class="o">&gt;</span><span class="w">      </span><span class="n">m_varRecvMap</span><span class="p">;</span><span class="w">           </span><span class="c1">// 处理ucp响应的变量映射表：key是ucp的url，value是相同url的变量集</span>
<a id="__codelineno-163-36" name="__codelineno-163-36" href="#__codelineno-163-36"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w">                                          </span><span class="n">m_varRecvMapMutex</span><span class="p">;</span>
<a id="__codelineno-163-37" name="__codelineno-163-37" href="#__codelineno-163-37"></a>
<a id="__codelineno-163-38" name="__codelineno-163-38" href="#__codelineno-163-38"></a><span class="w">    </span><span class="c1">// 连接相关</span>
<a id="__codelineno-163-39" name="__codelineno-163-39" href="#__codelineno-163-39"></a><span class="w">    </span><span class="n">TypeClientId</span><span class="w">                                        </span><span class="n">m_clientId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-163-40" name="__codelineno-163-40" href="#__codelineno-163-40"></a><span class="w">    </span><span class="n">endpoint_ucp_h</span><span class="w">                                      </span><span class="n">m_ucpHld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<a id="__codelineno-163-41" name="__codelineno-163-41" href="#__codelineno-163-41"></a><span class="w">    </span><span class="kt">bool</span><span class="w">                                                </span><span class="n">m_isConnected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// 连接状态</span>
<a id="__codelineno-163-42" name="__codelineno-163-42" href="#__codelineno-163-42"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w">                                          </span><span class="n">m_connectionMutex</span><span class="p">;</span>
<a id="__codelineno-163-43" name="__codelineno-163-43" href="#__codelineno-163-43"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">                                         </span><span class="n">m_remoteIp</span><span class="p">;</span>
<a id="__codelineno-163-44" name="__codelineno-163-44" href="#__codelineno-163-44"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w">                                         </span><span class="n">m_localIp</span><span class="p">;</span>
<a id="__codelineno-163-45" name="__codelineno-163-45" href="#__codelineno-163-45"></a><span class="w">    </span><span class="kt">int</span><span class="w">                                                 </span><span class="n">m_remotePort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-163-46" name="__codelineno-163-46" href="#__codelineno-163-46"></a>
<a id="__codelineno-163-47" name="__codelineno-163-47" href="#__codelineno-163-47"></a><span class="w">    </span><span class="c1">// 上层参数</span>
<a id="__codelineno-163-48" name="__codelineno-163-48" href="#__codelineno-163-48"></a><span class="w">    </span><span class="n">bleg_client_status_cb_f</span><span class="w">                             </span><span class="n">m_statusCb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<a id="__codelineno-163-49" name="__codelineno-163-49" href="#__codelineno-163-49"></a><span class="w">    </span><span class="n">bleg_client_destroy_cb_f</span><span class="w">                            </span><span class="n">m_destroyCb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<a id="__codelineno-163-50" name="__codelineno-163-50" href="#__codelineno-163-50"></a><span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w">                                               </span><span class="n">m_cbArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>
<a id="__codelineno-163-51" name="__codelineno-163-51" href="#__codelineno-163-51"></a>
<a id="__codelineno-163-52" name="__codelineno-163-52" href="#__codelineno-163-52"></a><span class="w">    </span><span class="c1">// 其他参数</span>
<a id="__codelineno-163-53" name="__codelineno-163-53" href="#__codelineno-163-53"></a><span class="w">    </span><span class="n">cell</span><span class="o">::</span><span class="n">timer_id_t</span><span class="w"> </span><span class="n">m_varGetTimerId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-163-54" name="__codelineno-163-54" href="#__codelineno-163-54"></a><span class="p">};</span>
</code></pre></div>
<h3 id="stdlock_guard_1"><code>std::lock_guard</code><a class="headerlink" href="#stdlock_guard_1" title="Permanent link">&para;</a></h3>
<h4 id="1-stdlock_guard">1. <code>std::lock_guard</code> 什么时候释放<a class="headerlink" href="#1-stdlock_guard" title="Permanent link">&para;</a></h4>
<p><code>std::lock_guard</code> 是一个 RAII 类型的锁管理器，它在构造时锁定互斥锁，并在析构时自动释放互斥锁。这意味着锁的释放是在 <code>std::lock_guard</code> 对象的生命周期结束时发生的。</p>
<p>具体来说，当 <code>std::lock_guard</code> 对象离开其作用域时（例如，当函数返回或作用域块结束时），它的析构函数会被调用，从而解锁互斥锁。</p>
<p><strong>示例</strong>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-164-1" name="__codelineno-164-1" href="#__codelineno-164-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>
<a id="__codelineno-164-2" name="__codelineno-164-2" href="#__codelineno-164-2"></a>
<a id="__codelineno-164-3" name="__codelineno-164-3" href="#__codelineno-164-3"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<a id="__codelineno-164-4" name="__codelineno-164-4" href="#__codelineno-164-4"></a>
<a id="__codelineno-164-5" name="__codelineno-164-5" href="#__codelineno-164-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">exampleFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-164-6" name="__codelineno-164-6" href="#__codelineno-164-6"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-164-7" name="__codelineno-164-7" href="#__codelineno-164-7"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="w"> </span><span class="c1">// Lock is acquired here</span>
<a id="__codelineno-164-8" name="__codelineno-164-8" href="#__codelineno-164-8"></a><span class="w">        </span><span class="c1">// Critical section</span>
<a id="__codelineno-164-9" name="__codelineno-164-9" href="#__codelineno-164-9"></a><span class="w">        </span><span class="c1">// Do some work with the shared resource</span>
<a id="__codelineno-164-10" name="__codelineno-164-10" href="#__codelineno-164-10"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// Lock is released here when lock goes out of scope</span>
<a id="__codelineno-164-11" name="__codelineno-164-11" href="#__codelineno-164-11"></a><span class="w">    </span><span class="c1">// Do other work</span>
<a id="__codelineno-164-12" name="__codelineno-164-12" href="#__codelineno-164-12"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的例子中，<code>std::lock_guard</code> 对象 <code>lock</code> 在创建时锁定了 <code>mtx</code>，并在离开作用域时自动解锁。</p>
<h4 id="2_2">2. 避免死锁：确保总是以相同的顺序锁定多个互斥锁<a class="headerlink" href="#2_2" title="Permanent link">&para;</a></h4>
<p>死锁发生在两个或多个线程相互等待对方持有的锁时，导致所有线程都无法继续执行。为了避免死锁，当需要同时锁定多个互斥锁时，必须确保所有线程以相同的顺序锁定这些锁。</p>
<p><strong>示例</strong>：</p>
<p>假设有两个互斥锁 <code>mtx1</code> 和 <code>mtx2</code>，如果线程 A 和线程 B 以不同的顺序锁定它们，就可能发生死锁。</p>
<p><strong>错误示例（可能导致死锁）</strong>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-165-1" name="__codelineno-165-1" href="#__codelineno-165-1"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx1</span><span class="p">;</span>
<a id="__codelineno-165-2" name="__codelineno-165-2" href="#__codelineno-165-2"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx2</span><span class="p">;</span>
<a id="__codelineno-165-3" name="__codelineno-165-3" href="#__codelineno-165-3"></a>
<a id="__codelineno-165-4" name="__codelineno-165-4" href="#__codelineno-165-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">threadA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-165-5" name="__codelineno-165-5" href="#__codelineno-165-5"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">);</span>
<a id="__codelineno-165-6" name="__codelineno-165-6" href="#__codelineno-165-6"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">);</span>
<a id="__codelineno-165-7" name="__codelineno-165-7" href="#__codelineno-165-7"></a><span class="w">    </span><span class="c1">// Critical section</span>
<a id="__codelineno-165-8" name="__codelineno-165-8" href="#__codelineno-165-8"></a><span class="p">}</span>
<a id="__codelineno-165-9" name="__codelineno-165-9" href="#__codelineno-165-9"></a>
<a id="__codelineno-165-10" name="__codelineno-165-10" href="#__codelineno-165-10"></a><span class="kt">void</span><span class="w"> </span><span class="nf">threadB</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-165-11" name="__codelineno-165-11" href="#__codelineno-165-11"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">);</span>
<a id="__codelineno-165-12" name="__codelineno-165-12" href="#__codelineno-165-12"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">);</span>
<a id="__codelineno-165-13" name="__codelineno-165-13" href="#__codelineno-165-13"></a><span class="w">    </span><span class="c1">// Critical section</span>
<a id="__codelineno-165-14" name="__codelineno-165-14" href="#__codelineno-165-14"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的例子中，线程 A 先锁定 <code>mtx1</code>，然后锁定 <code>mtx2</code>，而线程 B 先锁定 <code>mtx2</code>，然后锁定 <code>mtx1</code>。如果线程 A 持有 <code>mtx1</code> 并等待 <code>mtx2</code>，而线程 B 持有 <code>mtx2</code> 并等待 <code>mtx1</code>，就会发生死锁。</p>
<p><strong>正确示例（避免死锁）</strong>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-166-1" name="__codelineno-166-1" href="#__codelineno-166-1"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx1</span><span class="p">;</span>
<a id="__codelineno-166-2" name="__codelineno-166-2" href="#__codelineno-166-2"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx2</span><span class="p">;</span>
<a id="__codelineno-166-3" name="__codelineno-166-3" href="#__codelineno-166-3"></a>
<a id="__codelineno-166-4" name="__codelineno-166-4" href="#__codelineno-166-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">threadA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-166-5" name="__codelineno-166-5" href="#__codelineno-166-5"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">);</span>
<a id="__codelineno-166-6" name="__codelineno-166-6" href="#__codelineno-166-6"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">);</span>
<a id="__codelineno-166-7" name="__codelineno-166-7" href="#__codelineno-166-7"></a><span class="w">    </span><span class="c1">// Critical section</span>
<a id="__codelineno-166-8" name="__codelineno-166-8" href="#__codelineno-166-8"></a><span class="p">}</span>
<a id="__codelineno-166-9" name="__codelineno-166-9" href="#__codelineno-166-9"></a>
<a id="__codelineno-166-10" name="__codelineno-166-10" href="#__codelineno-166-10"></a><span class="kt">void</span><span class="w"> </span><span class="nf">threadB</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-166-11" name="__codelineno-166-11" href="#__codelineno-166-11"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">);</span>
<a id="__codelineno-166-12" name="__codelineno-166-12" href="#__codelineno-166-12"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">);</span>
<a id="__codelineno-166-13" name="__codelineno-166-13" href="#__codelineno-166-13"></a><span class="w">    </span><span class="c1">// Critical section</span>
<a id="__codelineno-166-14" name="__codelineno-166-14" href="#__codelineno-166-14"></a><span class="p">}</span>
</code></pre></div>
<p>在这个例子中，线程 A 和线程 B 都以相同的顺序锁定 <code>mtx1</code> 和 <code>mtx2</code>（先 <code>mtx1</code>，再 <code>mtx2</code>），因此不会发生死锁。</p>
<h4 id="stdlock">使用 <code>std::lock</code> 来避免死锁<a class="headerlink" href="#stdlock" title="Permanent link">&para;</a></h4>
<p>C++11 提供了 <code>std::lock</code> 函数，可以同时锁定多个互斥锁，并且避免死锁。<code>std::lock</code> 保证所有互斥锁都成功锁定，或者没有任何锁被锁定。</p>
<p><strong>示例</strong>：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-167-1" name="__codelineno-167-1" href="#__codelineno-167-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>
<a id="__codelineno-167-2" name="__codelineno-167-2" href="#__codelineno-167-2"></a>
<a id="__codelineno-167-3" name="__codelineno-167-3" href="#__codelineno-167-3"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx1</span><span class="p">;</span>
<a id="__codelineno-167-4" name="__codelineno-167-4" href="#__codelineno-167-4"></a><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx2</span><span class="p">;</span>
<a id="__codelineno-167-5" name="__codelineno-167-5" href="#__codelineno-167-5"></a>
<a id="__codelineno-167-6" name="__codelineno-167-6" href="#__codelineno-167-6"></a><span class="kt">void</span><span class="w"> </span><span class="nf">threadFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-167-7" name="__codelineno-167-7" href="#__codelineno-167-7"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span><span class="w"> </span><span class="n">mtx2</span><span class="p">);</span><span class="w"> </span><span class="c1">// Lock both mutexes without risk of deadlock</span>
<a id="__codelineno-167-8" name="__codelineno-167-8" href="#__codelineno-167-8"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock1</span><span class="p">(</span><span class="n">mtx1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span><span class="w"> </span><span class="c1">// Adopt the lock</span>
<a id="__codelineno-167-9" name="__codelineno-167-9" href="#__codelineno-167-9"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock2</span><span class="p">(</span><span class="n">mtx2</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span><span class="w"> </span><span class="c1">// Adopt the lock</span>
<a id="__codelineno-167-10" name="__codelineno-167-10" href="#__codelineno-167-10"></a><span class="w">    </span><span class="c1">// Critical section</span>
<a id="__codelineno-167-11" name="__codelineno-167-11" href="#__codelineno-167-11"></a><span class="w">    </span><span class="c1">// Both mtx1 and mtx2 are locked</span>
<a id="__codelineno-167-12" name="__codelineno-167-12" href="#__codelineno-167-12"></a><span class="w">    </span><span class="c1">// Locks are released when lock1 and lock2 go out of scope</span>
<a id="__codelineno-167-13" name="__codelineno-167-13" href="#__codelineno-167-13"></a><span class="p">}</span>
</code></pre></div>
<p>在这个例子中，<code>std::lock</code> 同时锁定 <code>mtx1</code> 和 <code>mtx2</code>，并且 <code>std::lock_guard</code> 使用 <code>std::adopt_lock</code> 标记来表明互斥锁已经被锁定，从而避免了死锁的风险。</p>
<h4 id="_72">总结<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h4>
<ol>
<li><strong><code>std::lock_guard</code> 的释放时机</strong>：<code>std::lock_guard</code> 在其作用域结束时自动释放锁。</li>
<li><strong>避免死锁</strong>：当需要同时锁定多个互斥锁时，确保所有线程以相同的顺序锁定这些锁。可以使用 <code>std::lock</code> 函数来同时锁定多个互斥锁，以避免死锁。</li>
</ol>
<h2 id="125r">125、构建字符串前加不加R<a class="headerlink" href="#125r" title="Permanent link">&para;</a></h2>
<p>在C++中，字符串字面值可以使用两种方式表示：带有R前缀的原始字符串字面值（Raw String Literal）和普通字符串字面值。</p>
<ol>
<li>原始字符串字面值（Raw String Literal）：带有R前缀的字符串字面值，例如 <code>R"(...)"</code>。使用原始字符串字面值时，可以在字符串中包含特殊字符（如反斜杠和引号）而无需进行转义。这对于包含大量特殊字符的字符串（例如JSON、正则表达式等）非常有用。</li>
<li>普通字符串字面值：不带有R前缀的字符串字面值，例如 <code>"..."</code>。使用普通字符串字面值时，特殊字符需要进行转义，例如使用 <code>\"</code> 表示双引号。</li>
</ol>
<h2 id="130const-stdstring-stdstring-stdstring">130、函数的入参什么时候设置为const std::string&amp;或 std::string&amp;或 std::string<a class="headerlink" href="#130const-stdstring-stdstring-stdstring" title="Permanent link">&para;</a></h2>
<p>在函数的参数中，选择使用<code>const std::string&amp;</code>、<code>std::string&amp;</code>还是<code>std::string</code>取决于你对参数的使用需求和语义。</p>
<ol>
<li><code>const std::string&amp;</code>：如果你只需要读取参数的值而不修改它，并且不需要复制参数的内容，可以使用<code>const std::string&amp;</code>。这样做可以避免不必要的复制操作，并且显式地表明函数不会修改参数的值。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-168-1" name="__codelineno-168-1" href="#__codelineno-168-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printString</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-168-2" name="__codelineno-168-2" href="#__codelineno-168-2"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-168-3" name="__codelineno-168-3" href="#__codelineno-168-3"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><code>std::string&amp;</code>：如果你需要修改参数的值，并且希望修改后的值在函数调用结束后对调用者可见，可以使用<code>std::string&amp;</code>。这样做可以直接在函数中修改参数的值，而不需要进行额外的复制操作。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-169-1" name="__codelineno-169-1" href="#__codelineno-169-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">appendWorld</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-169-2" name="__codelineno-169-2" href="#__codelineno-169-2"></a><span class="w">    </span><span class="n">str</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot; World&quot;</span><span class="p">;</span>
<a id="__codelineno-169-3" name="__codelineno-169-3" href="#__codelineno-169-3"></a><span class="p">}</span>
</code></pre></div>
<ol>
<li><code>std::string</code>：如果你需要在函数中对参数进行修改，但不需要修改后的值对调用者可见，或者你需要对参数进行复制操作以保留独立的副本，可以使用<code>std::string</code>。这样做会在函数调用时进行参数的复制，使得函数内部的修改不会影响到调用者的原始值。例如：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-170-1" name="__codelineno-170-1" href="#__codelineno-170-1"></a><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">toUpperCase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-170-2" name="__codelineno-170-2" href="#__codelineno-170-2"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-170-3" name="__codelineno-170-3" href="#__codelineno-170-3"></a><span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<a id="__codelineno-170-4" name="__codelineno-170-4" href="#__codelineno-170-4"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-170-5" name="__codelineno-170-5" href="#__codelineno-170-5"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<a id="__codelineno-170-6" name="__codelineno-170-6" href="#__codelineno-170-6"></a><span class="p">}</span>
</code></pre></div>
<p>需要注意的是，使用<code>std::string</code>作为参数类型会进行一次字符串的复制操作，可能会带来额外的性能开销。因此，如果只需要读取参数的值而不修改它，使用<code>const std::string&amp;</code>更为高效。如果需要修改参数的值，并希望修改后的值对调用者可见，使用<code>std::string&amp;</code>更为合适。</p>
<p>综上所述，你可以根据函数对参数的使用需求来选择适当的参数类型：<code>const std::string&amp;</code>用于只读取参数值，<code>std::string&amp;</code>用于修改参数值并使修改对调用者可见，<code>std::string</code>用于修改参数值但不需要对调用者可见或需要进行复制操作的情况。</p>
<h2 id="135structclass">135、struct和class里定义哪些必须赋初值<a class="headerlink" href="#135structclass" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>必须赋初值</strong>：指针类型、引用类型、类类型（无默认构造函数）、文件或网络句柄等。<strong>基本数据类型（如 <code>int</code>, <code>float</code>，最好也给个初值）</strong></li>
<li><strong>可以不赋初值</strong>：<strong>基本数据类型（如 <code>int</code>, <code>float</code>，但要确保在使用前赋值，所有说最好也给个初值）</strong>、标准库容器类型（如 <code>std::vector</code>，因为默认构造函数会初始化为空）。</li>
</ul>
<h2 id="140">140、类什么时候拥有默认构造函数<a class="headerlink" href="#140" title="Permanent link">&para;</a></h2>
<p>并非所有类在 C++ 中都自动拥有默认构造函数。默认构造函数的存在与否取决于类的定义和其成员的类型。以下是一些关于默认构造函数的详细说明：</p>
<h3 id="_73">默认构造函数的存在条件<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>自动生成默认构造函数</strong>：</li>
<li>如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数。</li>
<li>例子：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-171-1" name="__codelineno-171-1" href="#__codelineno-171-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-171-2" name="__codelineno-171-2" href="#__codelineno-171-2"></a><span class="w">    </span><span class="c1">// 没有定义任何构造函数，编译器会自动生成一个默认构造函数</span>
<a id="__codelineno-171-3" name="__codelineno-171-3" href="#__codelineno-171-3"></a><span class="p">};</span>
</code></pre></div>
<ol>
<li><strong>用户定义的构造函数</strong>：</li>
<li>如果用户定义了任何构造函数（包括复制构造函数、移动构造函数等），编译器不会自动生成默认构造函数，除非显式声明。</li>
<li>例子：</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-172-1" name="__codelineno-172-1" href="#__codelineno-172-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-172-2" name="__codelineno-172-2" href="#__codelineno-172-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-172-3" name="__codelineno-172-3" href="#__codelineno-172-3"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">  </span><span class="c1">// 用户定义的构造函数</span>
<a id="__codelineno-172-4" name="__codelineno-172-4" href="#__codelineno-172-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<a id="__codelineno-172-5" name="__codelineno-172-5" href="#__codelineno-172-5"></a><span class="p">};</span>
<a id="__codelineno-172-6" name="__codelineno-172-6" href="#__codelineno-172-6"></a>
<a id="__codelineno-172-7" name="__codelineno-172-7" href="#__codelineno-172-7"></a><span class="n">MyClass</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w">  </span><span class="c1">// 错误：没有默认构造函数</span>
</code></pre></div>
<ol>
<li>
<p><strong>成员的类型决定默认构造函数的存在</strong>：</p>
</li>
<li>
<p>如果类的成员包含没有默认构造函数的类，编译器也不会生成默认构造函数。</p>
</li>
<li>例子：</li>
</ol>
<p>```cpp
   class NoDefaultConstructor {
   public:
       NoDefaultConstructor(int x) : value(x) {}
   private:
       int value;
};</p>
<p>class MyClass {
   public:
       NoDefaultConstructor member;  // 成员没有默认构造函数
   };</p>
<p>MyClass obj;  // 错误：MyClass 没有默认构造函数
   ```</p>
<h3 id="_74">显式声明默认构造函数<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h3>
<p>如果需要默认构造函数而编译器不会自动生成，可以显式声明：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-173-1" name="__codelineno-173-1" href="#__codelineno-173-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-173-2" name="__codelineno-173-2" href="#__codelineno-173-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-173-3" name="__codelineno-173-3" href="#__codelineno-173-3"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w">  </span><span class="c1">// 显式声明默认构造函数</span>
<a id="__codelineno-173-4" name="__codelineno-173-4" href="#__codelineno-173-4"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-173-5" name="__codelineno-173-5" href="#__codelineno-173-5"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-173-6" name="__codelineno-173-6" href="#__codelineno-173-6"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<a id="__codelineno-173-7" name="__codelineno-173-7" href="#__codelineno-173-7"></a><span class="p">};</span>
</code></pre></div>
<h2 id="145clear-str">145、<code>clear()</code> 和赋值操作 <code>str = ""</code><a class="headerlink" href="#145clear-str" title="Permanent link">&para;</a></h2>
<p><code>clear()</code> 和赋值操作 <code>str = ""</code> 都可以用于清空 <code>std::string</code>，但它们在性能和内存管理上有一些差异。<code>clear()</code> 更快且保留容量，而赋值操作可能涉及内存重新分配。选择哪种方法取决于你的具体需求。</p>
<ul>
<li>如果你希望清空字符串但保留其容量以便后续使用，建议使用 <code>clear()</code>。</li>
<li>如果你希望清空字符串并可能释放不再需要的内存，建议使用赋值操作 <code>str = ""</code>。</li>
</ul>
<h2 id="150">150、防止类的拷贝和赋值操作<a class="headerlink" href="#150" title="Permanent link">&para;</a></h2>
<p>这段代码是 C++ 中的一种常见技术，用于防止类的拷贝和赋值操作。具体来说，这段代码禁用了 <code>BlegClientUdp</code> 类的拷贝构造函数和拷贝赋值运算符。让我们详细解释一下：</p>
<ol>
<li><strong>拷贝构造函数</strong> (<code>BlegClientUdp(const BlegClientUdp&amp;) = delete;</code>):</li>
<li>这行代码声明并删除了 <code>BlegClientUdp</code> 类的拷贝构造函数。</li>
<li>
<p>这意味着你不能通过拷贝现有的 <code>BlegClientUdp</code> 对象来创建新的 <code>BlegClientUdp</code> 对象。例如，以下代码将导致编译错误：
     <div class="highlight"><pre><span></span><code><a id="__codelineno-174-1" name="__codelineno-174-1" href="#__codelineno-174-1"></a><span class="n">BlegClientUdp</span><span class="w"> </span><span class="n">obj1</span><span class="p">;</span>
<a id="__codelineno-174-2" name="__codelineno-174-2" href="#__codelineno-174-2"></a><span class="n">BlegClientUdp</span><span class="w"> </span><span class="n">obj2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错误：拷贝构造函数被删除</span>
</code></pre></div></p>
</li>
<li>
<p><strong>拷贝赋值运算符</strong> (<code>BlegClientUdp&amp; operator=(const BlegClientUdp&amp;) = delete;</code>):</p>
</li>
<li>这行代码声明并删除了 <code>BlegClientUdp</code> 类的拷贝赋值运算符。</li>
<li>这意味着你不能将一个 <code>BlegClientUdp</code> 对象赋值给另一个 <code>BlegClientUdp</code> 对象。例如，以下代码也会导致编译错误：
     <div class="highlight"><pre><span></span><code><a id="__codelineno-175-1" name="__codelineno-175-1" href="#__codelineno-175-1"></a><span class="n">BlegClientUdp</span><span class="w"> </span><span class="n">obj1</span><span class="p">;</span>
<a id="__codelineno-175-2" name="__codelineno-175-2" href="#__codelineno-175-2"></a><span class="n">BlegClientUdp</span><span class="w"> </span><span class="n">obj2</span><span class="p">;</span>
<a id="__codelineno-175-3" name="__codelineno-175-3" href="#__codelineno-175-3"></a><span class="n">obj2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 错误：拷贝赋值运算符被删除</span>
</code></pre></div></li>
</ol>
<p>通过删除拷贝构造函数和拷贝赋值运算符，类的作者明确表示这个类的对象不应该被拷贝。这通常用于以下几种情况：</p>
<ul>
<li><strong>资源管理</strong>：类可能管理某种资源（如文件句柄、网络连接、内存等），拷贝这些资源可能会导致资源管理问题（如双重释放、资源泄露等）。</li>
<li><strong>单例模式</strong>：类可能是单例模式的一部分，确保只有一个实例存在。</li>
<li><strong>避免意外拷贝</strong>：防止无意中拷贝对象，导致意料之外的行为或性能问题。</li>
</ul>
<p>在现代 C++ 中，使用 <code>= delete</code> 是一种推荐的方法来显式禁用类的某些默认行为。</p>
<h2 id="155free">155、什么时候需要free内存<a class="headerlink" href="#155free" title="Permanent link">&para;</a></h2>
<p>当函数内部，对于这个变量是通过malloc或者strdup产生的，</p>
<p>函数内部没释放，你外部就要释放</p>
<h2 id="160stdenable_shared_from_this">160、继承时使用std::enable_shared_from_this<a class="headerlink" href="#160stdenable_shared_from_this" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-176-1" name="__codelineno-176-1" href="#__codelineno-176-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">VirtualDevice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Element</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">VirtualDevice</span><span class="o">&gt;</span>
</code></pre></div>
<ul>
<li>继承 <code>std::enable_shared_from_this&lt;VirtualDevice&gt;</code> 允许 <code>VirtualDevice</code> 类使用 <code>shared_from_this()</code> 方法。</li>
<li><code>shared_from_this()</code> 方法返回一个 <code>std::shared_ptr&lt;VirtualDevice&gt;</code>，指向当前对象。</li>
</ul>
<p>使用 <code>enable_shared_from_this</code> 可以避免一些常见的错误，例如：</p>
<ul>
<li><strong>避免重复创建 <code>shared_ptr</code></strong>：如果一个对象已经由一个 <code>shared_ptr</code> 管理，那么创建一个新的 <code>shared_ptr</code> 指向同一个对象可能会导致未定义行为。使用 <code>shared_from_this</code> 可以确保安全地获取一个现有的 <code>shared_ptr</code>。</li>
<li><strong>确保对象的生命周期</strong>：在类的成员函数中使用 <code>shared_from_this</code> 可以确保对象在使用期间不会被销毁。</li>
</ul>
<h2 id="165">165、在程序接口中传入指针又传出指针，要记得判空<a class="headerlink" href="#165" title="Permanent link">&para;</a></h2>
<p>1、传入指针给一个函数，要记得判空，不然会导致函数内部失败，程序崩溃</p>
<p>2、接口返回后，这个指针后要记得判空；不然你使用nlohmann::json去parse这种nullptr的指针时会出错</p>
<p>3、所有通过指针获取到东西的地方，都需要在传入函数之前判空，以及获取之后判断指针是否为空（包括普通指针和智能指针）</p>
<h2 id="180">180、对于空字符串进入进出函数，也最好需要判断<a class="headerlink" href="#180" title="Permanent link">&para;</a></h2>
<p>也是要防止一些函数调用崩溃</p>
<h2 id="181stdmovenlohmannjson">181、有些临时对象记得用std::move，避免不必要的拷贝操作。特别是对于nlohmann::json这种大的对象<a class="headerlink" href="#181stdmovenlohmannjson" title="Permanent link">&para;</a></h2>
<p>问：什么时候应该使用<code>std::move</code>？ 答：应该在你想要“转移”一个对象的资源，而不是复制它们的时候使用<code>std::move</code>。 这通常出现在对象即将离开其当前作用域或不再需要其内容时。 例如，<strong>在返回局部对象时使用<code>std::move</code>可以避免不必要的复制</strong>。</p>
<h2 id="182returnreturn">182、在所有的return之前一定要记得释放资源，而不要提前return了，却没有释放。（包括文件、指针之类的都算）<a class="headerlink" href="#182returnreturn" title="Permanent link">&para;</a></h2>
<h2 id="185">185、对同一块内容不能锁定两次<a class="headerlink" href="#185" title="Permanent link">&para;</a></h2>
<p>原对象的内存，又引用或指针了源对象的内存，</p>
<h2 id="190static">190、在局部函数里用static，定义比较大的一块内存，比如数组之类，这样不用每次进入都浪费内存<a class="headerlink" href="#190static" title="Permanent link">&para;</a></h2>
<h2 id="195">195、迭代器<a class="headerlink" href="#195" title="Permanent link">&para;</a></h2>
<p>迭代器本身是一个轻量级对象，通常不需要使用引用来避免拷贝。更常见的做法是直接使用迭代器，而不是引用迭代器。</p>
<h2 id="200">200、什么时候需要前向声明<a class="headerlink" href="#200" title="Permanent link">&para;</a></h2>
<p>前向声明在C++中是一种声明类型的方式，而不提供其完整定义。前向声明的主要目的是为了减少头文件之间的依赖关系，从而提高编译速度和减少编译依赖。以下是一些需要前向声明的常见情况：</p>
<h3 id="1_4">1. 减少头文件依赖<a class="headerlink" href="#1_4" title="Permanent link">&para;</a></h3>
<p>当一个类只需要使用另一个类的指针或引用，而不需要访问其成员时，可以使用前向声明来代替包含完整的头文件。这可以减少头文件之间的依赖关系，从而提高编译速度。</p>
<h4 id="_75">示例<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-177-1" name="__codelineno-177-1" href="#__codelineno-177-1"></a><span class="c1">// A.h</span>
<a id="__codelineno-177-2" name="__codelineno-177-2" href="#__codelineno-177-2"></a><span class="cp">#ifndef A_H</span>
<a id="__codelineno-177-3" name="__codelineno-177-3" href="#__codelineno-177-3"></a><span class="cp">#define A_H</span>
<a id="__codelineno-177-4" name="__codelineno-177-4" href="#__codelineno-177-4"></a>
<a id="__codelineno-177-5" name="__codelineno-177-5" href="#__codelineno-177-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">;</span><span class="w"> </span><span class="c1">// 前向声明</span>
<a id="__codelineno-177-6" name="__codelineno-177-6" href="#__codelineno-177-6"></a>
<a id="__codelineno-177-7" name="__codelineno-177-7" href="#__codelineno-177-7"></a><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-177-8" name="__codelineno-177-8" href="#__codelineno-177-8"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-177-9" name="__codelineno-177-9" href="#__codelineno-177-9"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setB</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<a id="__codelineno-177-10" name="__codelineno-177-10" href="#__codelineno-177-10"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-177-11" name="__codelineno-177-11" href="#__codelineno-177-11"></a><span class="w">    </span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-177-12" name="__codelineno-177-12" href="#__codelineno-177-12"></a><span class="p">};</span>
<a id="__codelineno-177-13" name="__codelineno-177-13" href="#__codelineno-177-13"></a>
<a id="__codelineno-177-14" name="__codelineno-177-14" href="#__codelineno-177-14"></a><span class="cp">#endif </span><span class="c1">// A_H</span>
</code></pre></div>
<p>在这个示例中，<code>A</code> 类只需要一个指向 <code>B</code> 类的指针，因此可以使用前向声明来避免包含 <code>B</code> 类的头文件。</p>
<h3 id="2_3">2. 解决循环依赖<a class="headerlink" href="#2_3" title="Permanent link">&para;</a></h3>
<p>当两个类互相包含对方时，会产生循环依赖，导致编译错误。使用前向声明可以解决这个问题。</p>
<h4 id="_76">示例<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-178-1" name="__codelineno-178-1" href="#__codelineno-178-1"></a><span class="c1">// A.h</span>
<a id="__codelineno-178-2" name="__codelineno-178-2" href="#__codelineno-178-2"></a><span class="cp">#ifndef A_H</span>
<a id="__codelineno-178-3" name="__codelineno-178-3" href="#__codelineno-178-3"></a><span class="cp">#define A_H</span>
<a id="__codelineno-178-4" name="__codelineno-178-4" href="#__codelineno-178-4"></a>
<a id="__codelineno-178-5" name="__codelineno-178-5" href="#__codelineno-178-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">;</span><span class="w"> </span><span class="c1">// 前向声明</span>
<a id="__codelineno-178-6" name="__codelineno-178-6" href="#__codelineno-178-6"></a>
<a id="__codelineno-178-7" name="__codelineno-178-7" href="#__codelineno-178-7"></a><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-178-8" name="__codelineno-178-8" href="#__codelineno-178-8"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-178-9" name="__codelineno-178-9" href="#__codelineno-178-9"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setB</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<a id="__codelineno-178-10" name="__codelineno-178-10" href="#__codelineno-178-10"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-178-11" name="__codelineno-178-11" href="#__codelineno-178-11"></a><span class="w">    </span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<a id="__codelineno-178-12" name="__codelineno-178-12" href="#__codelineno-178-12"></a><span class="p">};</span>
<a id="__codelineno-178-13" name="__codelineno-178-13" href="#__codelineno-178-13"></a>
<a id="__codelineno-178-14" name="__codelineno-178-14" href="#__codelineno-178-14"></a><span class="cp">#endif </span><span class="c1">// A_H</span>
<a id="__codelineno-178-15" name="__codelineno-178-15" href="#__codelineno-178-15"></a>
<a id="__codelineno-178-16" name="__codelineno-178-16" href="#__codelineno-178-16"></a><span class="c1">// B.h</span>
<a id="__codelineno-178-17" name="__codelineno-178-17" href="#__codelineno-178-17"></a><span class="cp">#ifndef B_H</span>
<a id="__codelineno-178-18" name="__codelineno-178-18" href="#__codelineno-178-18"></a><span class="cp">#define B_H</span>
<a id="__codelineno-178-19" name="__codelineno-178-19" href="#__codelineno-178-19"></a>
<a id="__codelineno-178-20" name="__codelineno-178-20" href="#__codelineno-178-20"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;A.h&quot;</span>
<a id="__codelineno-178-21" name="__codelineno-178-21" href="#__codelineno-178-21"></a>
<a id="__codelineno-178-22" name="__codelineno-178-22" href="#__codelineno-178-22"></a><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-178-23" name="__codelineno-178-23" href="#__codelineno-178-23"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-178-24" name="__codelineno-178-24" href="#__codelineno-178-24"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setA</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<a id="__codelineno-178-25" name="__codelineno-178-25" href="#__codelineno-178-25"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-178-26" name="__codelineno-178-26" href="#__codelineno-178-26"></a><span class="w">    </span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<a id="__codelineno-178-27" name="__codelineno-178-27" href="#__codelineno-178-27"></a><span class="p">};</span>
<a id="__codelineno-178-28" name="__codelineno-178-28" href="#__codelineno-178-28"></a>
<a id="__codelineno-178-29" name="__codelineno-178-29" href="#__codelineno-178-29"></a><span class="cp">#endif </span><span class="c1">// B_H</span>
</code></pre></div>
<p>在这个示例中，<code>A</code> 类和 <code>B</code> 类互相包含对方。通过在 <code>A.h</code> 中前向声明 <code>B</code> 类，可以避免循环依赖。</p>
<h3 id="3_2">3. 减少编译时间<a class="headerlink" href="#3_2" title="Permanent link">&para;</a></h3>
<p>在大型项目中，包含头文件会显著增加编译时间。通过使用前向声明，可以减少不必要的头文件包含，从而提高编译效率。</p>
<h3 id="4_1">4. 隐藏实现细节<a class="headerlink" href="#4_1" title="Permanent link">&para;</a></h3>
<p>前向声明可以用来隐藏类的实现细节，这对于实现信息隐藏和封装非常有用。</p>
<h4 id="_77">示例<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-179-1" name="__codelineno-179-1" href="#__codelineno-179-1"></a><span class="c1">// MyClass.h</span>
<a id="__codelineno-179-2" name="__codelineno-179-2" href="#__codelineno-179-2"></a><span class="cp">#ifndef MYCLASS_H</span>
<a id="__codelineno-179-3" name="__codelineno-179-3" href="#__codelineno-179-3"></a><span class="cp">#define MYCLASS_H</span>
<a id="__codelineno-179-4" name="__codelineno-179-4" href="#__codelineno-179-4"></a>
<a id="__codelineno-179-5" name="__codelineno-179-5" href="#__codelineno-179-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClassImpl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 前向声明</span>
<a id="__codelineno-179-6" name="__codelineno-179-6" href="#__codelineno-179-6"></a>
<a id="__codelineno-179-7" name="__codelineno-179-7" href="#__codelineno-179-7"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-179-8" name="__codelineno-179-8" href="#__codelineno-179-8"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-179-9" name="__codelineno-179-9" href="#__codelineno-179-9"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">();</span>
<a id="__codelineno-179-10" name="__codelineno-179-10" href="#__codelineno-179-10"></a><span class="w">    </span><span class="o">~</span><span class="n">MyClass</span><span class="p">();</span>
<a id="__codelineno-179-11" name="__codelineno-179-11" href="#__codelineno-179-11"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">();</span>
<a id="__codelineno-179-12" name="__codelineno-179-12" href="#__codelineno-179-12"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-179-13" name="__codelineno-179-13" href="#__codelineno-179-13"></a><span class="w">    </span><span class="n">MyClassImpl</span><span class="o">*</span><span class="w"> </span><span class="n">pImpl</span><span class="p">;</span><span class="w"> </span><span class="c1">// 使用前向声明的指针</span>
<a id="__codelineno-179-14" name="__codelineno-179-14" href="#__codelineno-179-14"></a><span class="p">};</span>
<a id="__codelineno-179-15" name="__codelineno-179-15" href="#__codelineno-179-15"></a>
<a id="__codelineno-179-16" name="__codelineno-179-16" href="#__codelineno-179-16"></a><span class="cp">#endif </span><span class="c1">// MYCLASS_H</span>
</code></pre></div>
<p>在这个示例中，<code>MyClass</code> 使用了一个指向 <code>MyClassImpl</code> 的指针，而 <code>MyClassImpl</code> 的定义可以放在源文件中。这种技术被称为Pimpl（Pointer to Implementation）惯用法，用于隐藏实现细节。</p>
<h3 id="_78">什么时候不需要前向声明<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>需要访问类的成员</strong>：如果需要访问类的成员，则必须包含该类的完整定义，前向声明是不够的。</li>
<li><strong>模板类</strong>：在模板类中，前向声明通常不起作用，因为模板的实现需要完整的类型定义。</li>
<li><strong>继承关系</strong>：如果一个类继承自另一个类，则必须包含基类的完整定义。</li>
<li>如果在  <code>.h</code> 并不直接使用这些子类的类型，只是 <code>.cpp</code> 需要知道这些子类的定义，那也不需要进行前向声明</li>
</ul>
<h2 id="205">205、常量定义的地方<a class="headerlink" href="#205" title="Permanent link">&para;</a></h2>
<p>常量定义时，需要充分考虑其定义的位置，如果只是这个cpp文件需要，就只在这个cpp文件定义，然后使用static定义，其好处是：</p>
<ol>
<li><strong>避免命名冲突</strong>：<code>static</code> 变量的作用域仅限于定义它的文件，这样可以避免与其他文件中定义的同名变量发生冲突。</li>
<li><strong>提高可读性和可维护性</strong>：通过限制变量的作用域，可以更容易地理解变量的使用范围和生命周期，减少意外修改或误用的风险。</li>
<li><strong>优化编译和链接</strong>：编译器在处理 <code>static</code> 变量时，可以进行更多的优化，因为它知道这些变量不会在文件外部被引用。这可能会带来一些性能上的提升。</li>
</ol>
<p>除非真的很通用的才定义在h头文件，不然会：</p>
<p>导致每个包含这个头文件的源文件都有一个独立的 <code>variable</code> 变量实例。这会导致以下问题：</p>
<ol>
<li><strong>多个定义</strong>：每个包含头文件的源文件都会有一个独立的 <code>variable</code> 变量实例，而不是共享同一个变量。这在某些情况下可能会导致意外的行为，特别是当你希望所有源文件共享同一个常量时。</li>
<li><strong>增加编译时间</strong>：每次编译都会重新定义这个常量，增加编译时间。</li>
</ol>
<blockquote>
<p>所以通常的做法是在头文件中用extern声明常量，在一个源文件中定义常量，这种方式确保了常量在整个程序中只有一个定义，同时可以在多个源文件中访问。</p>
</blockquote>
<h2 id="210externstatic">210、extern和static关键字<a class="headerlink" href="#210externstatic" title="Permanent link">&para;</a></h2>
<p>static和extern能同时使用吗？ 答案是不能。</p>
<p>extern修饰全局变量和函数，被修饰的变量和函数可以在别的文件里使用。<br />
static修饰的变量和函数作用范围仅限于定义它的文件内部。 </p>
<p>static要求去除符号表名称，extern要求通过符号名称链接，他俩先天就矛盾，不能一起使用。</p>
<p>说起extern 这个关键字，相信大家都用的很多，一般都是在编译程序的时候，出现了全局变量找不到，不是定义在本文件中，然后就会在前面加上extern来解决这类编译错误。 相对其他关键字，extern的使用比较简单。</p>
<h2 id="215mapnlohamnnjson">215、map里nlohamnn::json的指针或者迭代器失效的问题<a class="headerlink" href="#215mapnlohamnnjson" title="Permanent link">&para;</a></h2>
<p><code>nlohmann::json</code> 使用的是动态数组（类似于 <code>std::vector</code>），当您删除数组中的某个元素时，数组的其他元素可能会被移动，从而导致指向这些元素的指针、迭代器失效。</p>
<p>我的解决办法：</p>
<p>是直接使用</p>
<h2 id="220">220、在基类函数中判断子类的类型<a class="headerlink" href="#220" title="Permanent link">&para;</a></h2>
<p>dynamic_cast<ClassChildren*>(this) == nullptr</p>
<h2 id="225dynamic_pointer_castdynamic_cast">225、dynamic_pointer_cast和dynamic_cast区别<a class="headerlink" href="#225dynamic_pointer_castdynamic_cast" title="Permanent link">&para;</a></h2>
<p><code>dynamic_pointer_cast</code> 和 <code>dynamic_cast</code> 是 C++ 中用于类型转换的两个不同的操作符。它们主要用于处理继承关系中的指针或引用类型转换。</p>
<ol>
<li><code>dynamic_pointer_cast</code>：这是 C++11 引入的一个智能指针操作符，用于在继承关系中进行动态类型转换。它用于将一个 <code>std::shared_ptr</code> 或 <code>std::unique_ptr</code> 智能指针从一个派生类指针转换为一个基类指针。如果转换成功，返回一个新的智能指针，指向基类类型；如果转换失败，返回一个空的智能指针。这个操作符只能用于智能指针，不能用于裸指针。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-180-1" name="__codelineno-180-1" href="#__codelineno-180-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-180-2" name="__codelineno-180-2" href="#__codelineno-180-2"></a><span class="w">    </span><span class="c1">// 基类定义</span>
<a id="__codelineno-180-3" name="__codelineno-180-3" href="#__codelineno-180-3"></a><span class="p">};</span>
<a id="__codelineno-180-4" name="__codelineno-180-4" href="#__codelineno-180-4"></a>
<a id="__codelineno-180-5" name="__codelineno-180-5" href="#__codelineno-180-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-180-6" name="__codelineno-180-6" href="#__codelineno-180-6"></a><span class="w">    </span><span class="c1">// 派生类定义</span>
<a id="__codelineno-180-7" name="__codelineno-180-7" href="#__codelineno-180-7"></a><span class="p">};</span>
<a id="__codelineno-180-8" name="__codelineno-180-8" href="#__codelineno-180-8"></a>
<a id="__codelineno-180-9" name="__codelineno-180-9" href="#__codelineno-180-9"></a><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">();</span>
<a id="__codelineno-180-10" name="__codelineno-180-10" href="#__codelineno-180-10"></a><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="w"> </span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">(</span><span class="n">basePtr</span><span class="p">);</span>
</code></pre></div>
<p>在上面的示例中，<code>dynamic_pointer_cast</code> 将 <code>basePtr</code> 智能指针从 <code>Base</code> 类型转换为 <code>Derived</code> 类型，返回一个指向 <code>Derived</code> 类型的智能指针 <code>derivedPtr</code>。</p>
<ol>
<li><code>dynamic_cast</code>：这是 C++ 中的一个运算符，用于在继承关系中进行动态类型转换。它可以用于指针或引用类型的转换。与 <code>dynamic_pointer_cast</code> 不同，<code>dynamic_cast</code> 可以用于裸指针和引用，但不能用于智能指针。如果转换成功，返回一个指向目标类型的指针或引用；如果转换失败，返回一个空指针或引用。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-181-1" name="__codelineno-181-1" href="#__codelineno-181-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-181-2" name="__codelineno-181-2" href="#__codelineno-181-2"></a><span class="w">    </span><span class="c1">// 基类定义</span>
<a id="__codelineno-181-3" name="__codelineno-181-3" href="#__codelineno-181-3"></a><span class="p">};</span>
<a id="__codelineno-181-4" name="__codelineno-181-4" href="#__codelineno-181-4"></a>
<a id="__codelineno-181-5" name="__codelineno-181-5" href="#__codelineno-181-5"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-181-6" name="__codelineno-181-6" href="#__codelineno-181-6"></a><span class="w">    </span><span class="c1">// 派生类定义</span>
<a id="__codelineno-181-7" name="__codelineno-181-7" href="#__codelineno-181-7"></a><span class="p">};</span>
<a id="__codelineno-181-8" name="__codelineno-181-8" href="#__codelineno-181-8"></a>
<a id="__codelineno-181-9" name="__codelineno-181-9" href="#__codelineno-181-9"></a><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Derived</span><span class="p">();</span>
<a id="__codelineno-181-10" name="__codelineno-181-10" href="#__codelineno-181-10"></a><span class="n">Derived</span><span class="o">*</span><span class="w"> </span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">basePtr</span><span class="p">);</span>
</code></pre></div>
<p>在上面的示例中，<code>dynamic_cast</code> 将 <code>basePtr</code> 指针从 <code>Base</code> 类型转换为 <code>Derived</code> 类型，返回一个指向 <code>Derived</code> 类型的指针 <code>derivedPtr</code>。</p>
<p>需要注意的是，<code>dynamic_cast</code> 在进行类型转换时会进行运行时类型检查，因此它的性能可能相对较低。在使用这些操作符时，应谨慎处理，确保类型转换的安全性和正确性。</p>
<h2 id="230stdmove">230、什么时候使用std::move<a class="headerlink" href="#230stdmove" title="Permanent link">&para;</a></h2>
<p>当对象很大的时候，在用std::move吧</p>
<h2 id="235">235、检查准则<a class="headerlink" href="#235" title="Permanent link">&para;</a></h2>
<ol>
<li>严禁使用未经初始化的变量。<ol>
<li><code>类内初始化：类成员初始化，统一在类声明的时候初始化。尽量减少在构造函数初始化。</code></li>
</ol>
</li>
<li>函数入口总是进行参数合法性校验，包括函数过程中的条件判断。</li>
</ol>
<h2 id="240intconst">240、int入参，我感觉就没必要const引用了，反正很小；如果要修改入参的话再用引用<a class="headerlink" href="#240intconst" title="Permanent link">&para;</a></h2>
<h2 id="245">245、迭代器全部失效而不是部分失效的原因<a class="headerlink" href="#245" title="Permanent link">&para;</a></h2>
<p>你提到的迭代器失效问题确实是一个复杂的情况。在使用 <code>std::vector</code> 时，迭代器失效的情况通常如下：</p>
<ol>
<li><strong>重新分配内存</strong>：当 <code>std::vector</code> 需要扩展容量时，它会分配新的内存并将现有元素复制到新位置。这会导致所有指向旧内存位置的迭代器失效。</li>
<li><strong>插入或删除元素</strong>：插入或删除元素可能会导致部分或全部迭代器失效，具体取决于操作的位置和容器的实现。</li>
</ol>
<h3 id="_79">为什么会全部失效？<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h3>
<p>当 <code>std::vector</code> 重新分配内存时，所有指向该容器的迭代器都会失效，这是因为新分配的内存地址与旧的内存地址不同。重新分配内存时，所有现有元素会被复制到新地址，这意味着旧的迭代器指向的地址不再有效。</p>
<h2 id="250emplace_back">250、emplace_back什么时候会重新分配内存<a class="headerlink" href="#250emplace_back" title="Permanent link">&para;</a></h2>
<p><code>emplace_back</code> 是用于在 C++ 的容器中插入元素的成员函数，比如 <code>std::vector</code>。它会在容器的末尾直接构造一个新的元素，并将其添加到容器中。</p>
<p><code>emplace_back</code> 在以下情况下可能会触发重新分配内存：</p>
<ol>
<li>
<p>当容器的当前容量不足以容纳新元素时，需要重新分配更大的内存空间。这是因为 <code>std::vector</code> 使用动态数组来存储元素，当容器的大小接近当前容量时，为了容纳新元素，它需要分配更大的内存空间，并将现有元素复制到新的内存空间中。</p>
</li>
<li>
<p>当容器的内存分配策略发生变化时，也可能触发重新分配内存。例如，当使用自定义的内存分配器（allocator）时，如果分配器的策略要求重新分配内存，那么 <code>emplace_back</code> 可能会触发重新分配。</p>
</li>
</ol>
<p>需要注意的是，重新分配内存可能会导致已有元素的迭代器、引用和指针失效，因为内存的重新分配会导致元素在内存中的位置发生变化。因此，在使用 <code>emplace_back</code> 插入元素之后，如果持有容器中元素的迭代器、引用或指针，需要小心处理，以避免使用失效的迭代器、引用或指针。</p>
<p>总之，<code>emplace_back</code> 在容器需要扩容时会触发重新分配内存。这通常发生在容器的当前容量不足以容纳新元素时。</p>
<h2 id="255">255、命名空间的相关问题<a class="headerlink" href="#255" title="Permanent link">&para;</a></h2>
<p>使用命名空间是为了避免不同模块中的函数、类、变量等命名冲突，以便更好地组织和管理代码。命名空间提供了一种逻辑上的隔离机制，将相关的实体封装在一个命名空间中，以便在代码中引用和使用。</p>
<p>在C++中，可以使用关键字 <code>namespace</code> 来定义命名空间，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-182-1" name="__codelineno-182-1" href="#__codelineno-182-1"></a><span class="k">namespace</span><span class="w"> </span><span class="nn">MyNamespace</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-182-2" name="__codelineno-182-2" href="#__codelineno-182-2"></a><span class="w">    </span><span class="c1">// 命名空间中的函数、类、变量等定义</span>
<a id="__codelineno-182-3" name="__codelineno-182-3" href="#__codelineno-182-3"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">myFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-182-4" name="__codelineno-182-4" href="#__codelineno-182-4"></a><span class="w">        </span><span class="c1">// 函数的实现</span>
<a id="__codelineno-182-5" name="__codelineno-182-5" href="#__codelineno-182-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-182-6" name="__codelineno-182-6" href="#__codelineno-182-6"></a><span class="p">}</span>
</code></pre></div>
<p>在使用命名空间中的实体时，可以通过限定名来引用，例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-183-1" name="__codelineno-183-1" href="#__codelineno-183-1"></a><span class="n">MyNamespace</span><span class="o">::</span><span class="n">myFunction</span><span class="p">();</span><span class="w">  </span><span class="c1">// 使用命名空间中的函数</span>
</code></pre></div>
<p>关于 <code>using namespace</code>，它是一个C++的编译指令，用于在当前作用域中引入一个命名空间的所有实体，以便在代码中直接使用命名空间中的实体，而无需使用限定名。例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-184-1" name="__codelineno-184-1" href="#__codelineno-184-1"></a><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">MyNamespace</span><span class="p">;</span><span class="w">  </span><span class="c1">// 引入命名空间</span>
<a id="__codelineno-184-2" name="__codelineno-184-2" href="#__codelineno-184-2"></a>
<a id="__codelineno-184-3" name="__codelineno-184-3" href="#__codelineno-184-3"></a><span class="n">myFunction</span><span class="p">();</span><span class="w">  </span><span class="c1">// 直接使用命名空间中的函数</span>
</code></pre></div>
<p>尽管 <code>using namespace</code> 可以简化代码，但也存在一些潜在的问题。使用该指令可能导致命名冲突，特别是当不同命名空间中存在相同名称的实体时。此外，使用该指令可能使代码更难理解和维护，因为无法清楚地知道特定实体是来自哪个命名空间。</p>
<p>因此，一般建议避免在头文件中使用 <code>using namespace</code>，尤其是全局命名空间，以减少潜在的冲突和混淆。相反，应该使用限定名来引用命名空间中的实体，或者在局部作用域中使用 <code>using</code> 来引入特定的实体。</p>
<p>总之，命名空间是用来隔离不同模块中的命名冲突，并提供更好的代码组织和管理。在使用命名空间时，应谨慎使用 <code>using namespace</code>，并根据具体情况选择合适的引入方式。</p>
<h2 id="230nlohmannjsontry-catch">230、nlohmann::json与try-catch<a class="headerlink" href="#230nlohmannjsontry-catch" title="Permanent link">&para;</a></h2>
<p>只要是涉及到nlohmann::json的操作，都要使用try-catch来捕获异常</p>
<h2 id="235dynamic_caststatic_cast">235、dynamic_cast和static_cast有什么区别<a class="headerlink" href="#235dynamic_caststatic_cast" title="Permanent link">&para;</a></h2>
<p>在C++中，<code>dynamic_cast</code>和<code>static_cast</code>是两种类型转换操作符，它们具有不同的行为和用途。</p>
<ol>
<li><code>static_cast</code>：</li>
<li><code>static_cast</code>用于执行静态类型转换，它在编译时进行类型检查。</li>
<li><code>static_cast</code>可以执行常见的类型转换，如基本类型之间的转换、隐式转换、向上转型等。</li>
<li><code>static_cast</code>还可以用于将指针或引用转换为其他相关类型的指针或引用。</li>
<li>例如，将一个整数转换为浮点数或将一个基类指针转换为派生类指针，可以使用<code>static_cast</code>。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-185-1" name="__codelineno-185-1" href="#__codelineno-185-1"></a><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<a id="__codelineno-185-2" name="__codelineno-185-2" href="#__codelineno-185-2"></a><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<a id="__codelineno-185-3" name="__codelineno-185-3" href="#__codelineno-185-3"></a>
<a id="__codelineno-185-4" name="__codelineno-185-4" href="#__codelineno-185-4"></a><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Derived</span><span class="p">();</span>
<a id="__codelineno-185-5" name="__codelineno-185-5" href="#__codelineno-185-5"></a><span class="n">Derived</span><span class="o">*</span><span class="w"> </span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">basePtr</span><span class="p">);</span>
</code></pre></div>
<ul>
<li>
<p><code>static_cast</code>的转换是在编译时确定的，不进行运行时类型检查。因此，如果使用<code>static_cast</code>执行不安全的类型转换，可能会导致未定义行为。</p>
</li>
<li>
<p><code>dynamic_cast</code>：</p>
</li>
<li><code>dynamic_cast</code>用于执行动态类型转换，它在运行时进行类型检查。</li>
<li><code>dynamic_cast</code>主要用于处理多态类型（即包含虚函数的类）之间的转换。</li>
<li><code>dynamic_cast</code>会检查对象的实际类型，并在转换时进行安全检查。如果转换不合法，<code>dynamic_cast</code>将返回一个空指针（对于指针转换）或抛出<code>std::bad_cast</code>异常（对于引用转换）。</li>
<li>例如，将一个基类指针转换为派生类指针时，如果基类指针指向的实际对象类型不是派生类，<code>dynamic_cast</code>将返回一个空指针。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-186-1" name="__codelineno-186-1" href="#__codelineno-186-1"></a><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Derived</span><span class="p">();</span>
<a id="__codelineno-186-2" name="__codelineno-186-2" href="#__codelineno-186-2"></a><span class="n">Derived</span><span class="o">*</span><span class="w"> </span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">basePtr</span><span class="p">);</span>
<a id="__codelineno-186-3" name="__codelineno-186-3" href="#__codelineno-186-3"></a><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-186-4" name="__codelineno-186-4" href="#__codelineno-186-4"></a><span class="w">    </span><span class="c1">// 转换成功</span>
<a id="__codelineno-186-5" name="__codelineno-186-5" href="#__codelineno-186-5"></a><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-186-6" name="__codelineno-186-6" href="#__codelineno-186-6"></a><span class="w">    </span><span class="c1">// 转换失败</span>
<a id="__codelineno-186-7" name="__codelineno-186-7" href="#__codelineno-186-7"></a><span class="p">}</span>
</code></pre></div>
<ul>
<li><code>dynamic_cast</code>的转换是在运行时进行的，它需要运行时类型信息（RTTI）的支持。因此，使用<code>dynamic_cast</code>会稍微增加一些运行时开销。</li>
</ul>
<p>综上所述，<code>static_cast</code>和<code>dynamic_cast</code>在C++中具有不同的行为和用途。<code>static_cast</code>用于执行静态类型转换，它在编译时进行类型检查。<code>dynamic_cast</code>用于执行动态类型转换，它在运行时进行类型检查，并且主要用于处理多态类型之间的转换。选择使用哪种类型转换取决于您的具体需求和转换的类型关系。</p>
<h2 id="240delete">240、delete掉拷贝构造函数和移动构造函数<a class="headerlink" href="#240delete" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-187-1" name="__codelineno-187-1" href="#__codelineno-187-1"></a><span class="n">Object</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<a id="__codelineno-187-2" name="__codelineno-187-2" href="#__codelineno-187-2"></a><span class="n">Object</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Object</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<a id="__codelineno-187-3" name="__codelineno-187-3" href="#__codelineno-187-3"></a><span class="n">Object</span><span class="p">(</span><span class="n">Object</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<a id="__codelineno-187-4" name="__codelineno-187-4" href="#__codelineno-187-4"></a><span class="n">Object</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Object</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<a id="__codelineno-187-5" name="__codelineno-187-5" href="#__codelineno-187-5"></a><span class="n">Object</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Object</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
</code></pre></div>
<p>在给定的代码中，以下函数被标记为 delete：</p>
<p>Object(const Object&amp;)：拷贝构造函数被删除。这意味着禁止通过拷贝构造函数创建 Object 类型的对象的副本。
Object(Object&amp;&amp;)：移动构造函数被删除。这意味着禁止通过移动构造函数创建 Object 类型的对象的副本。</p>
<p>Object&amp; operator=(const Object&amp;)：拷贝赋值运算符被删除。这意味着禁止通过拷贝赋值运算符将一个 Object 类型的对象赋值给另一个对象。
Object&amp; operator=(Object&amp;&amp;)：移动赋值运算符被删除。这意味着禁止通过移动赋值运算符将一个 Object 类型的对象赋值给另一个对象。
通过将这些特殊成员函数标记为 delete，可以阻止对它们的隐式调用，从而禁止对象的拷贝和移动操作。只有声明为 delete 的特殊成员函数，才能阻止它们的使用。</p>
<p>此外，Object() 构造函数被声明为 = default，这表示使用默认的生成方式来定义构造函数。这样的声明通常用于显式指定默认构造函数，以便在其他特殊成员函数被删除的情况下，仍然可以创建对象。</p>
<p>最后，析构函数 ~Object() 被定义为停止（Stop）工作，并在对象销毁时调用。这可能是一个自定义的函数，用于执行对象的清理和资源释放操作。</p>
<h2 id="245_1">245、赋值运算符和构造函数的区别是什么<a class="headerlink" href="#245_1" title="Permanent link">&para;</a></h2>
<p>赋值运算符（<code>operator=</code>）和构造函数（构造器）在 C++ 中有不同的作用和用法。</p>
<p>构造函数用于创建对象时初始化对象的成员变量。它可以被调用来创建一个新的对象，或者用于初始化已经存在的对象。</p>
<p>在类定义中，构造函数的名称与类名相同，没有返回类型，并且可以有不同的重载形式。常见的构造函数包括默认构造函数（无参数构造函数）和带参数的构造函数。</p>
<p>例如，下面是一个带参数的构造函数的示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-188-1" name="__codelineno-188-1" href="#__codelineno-188-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-188-2" name="__codelineno-188-2" href="#__codelineno-188-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-188-3" name="__codelineno-188-3" href="#__codelineno-188-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<a id="__codelineno-188-4" name="__codelineno-188-4" href="#__codelineno-188-4"></a>
<a id="__codelineno-188-5" name="__codelineno-188-5" href="#__codelineno-188-5"></a><span class="w">    </span><span class="c1">// 带参数的构造函数</span>
<a id="__codelineno-188-6" name="__codelineno-188-6" href="#__codelineno-188-6"></a><span class="w">    </span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-188-7" name="__codelineno-188-7" href="#__codelineno-188-7"></a><span class="p">};</span>
<a id="__codelineno-188-8" name="__codelineno-188-8" href="#__codelineno-188-8"></a>
<a id="__codelineno-188-9" name="__codelineno-188-9" href="#__codelineno-188-9"></a><span class="c1">// 使用构造函数创建对象</span>
<a id="__codelineno-188-10" name="__codelineno-188-10" href="#__codelineno-188-10"></a><span class="n">MyClass</span><span class="w"> </span><span class="nf">obj</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div>
<p>在上面的示例中，<code>MyClass</code> 类定义了一个带有 <code>int</code> 参数的构造函数，它将传递的值 <code>v</code> 分配给对象的 <code>value</code> 成员变量。然后，我们可以使用该构造函数创建 <code>MyClass</code> 类型的对象 <code>obj</code>。</p>
<p>相比之下，赋值运算符（<code>operator=</code>）用于将一个对象的值赋给另一个对象。它定义了对象之间的赋值操作。赋值运算符通常用于将一个已经存在的对象的状态复制到另一个对象，以使它们具有相同的值。</p>
<p>赋值运算符是一个成员函数，用于给定类的对象。它通常被定义为类的成员函数，接受一个同类型的参数，并返回一个引用到该类型的对象。赋值运算符的默认实现执行浅拷贝，即简单地将一个对象的成员变量的值复制到另一个对象。</p>
<p>例如，下面是一个自定义的赋值运算符的示例：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-189-1" name="__codelineno-189-1" href="#__codelineno-189-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-189-2" name="__codelineno-189-2" href="#__codelineno-189-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-189-3" name="__codelineno-189-3" href="#__codelineno-189-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<a id="__codelineno-189-4" name="__codelineno-189-4" href="#__codelineno-189-4"></a>
<a id="__codelineno-189-5" name="__codelineno-189-5" href="#__codelineno-189-5"></a><span class="w">    </span><span class="c1">// 自定义赋值运算符</span>
<a id="__codelineno-189-6" name="__codelineno-189-6" href="#__codelineno-189-6"></a><span class="w">    </span><span class="n">MyClass</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyClass</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-189-7" name="__codelineno-189-7" href="#__codelineno-189-7"></a><span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<a id="__codelineno-189-8" name="__codelineno-189-8" href="#__codelineno-189-8"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<a id="__codelineno-189-9" name="__codelineno-189-9" href="#__codelineno-189-9"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-189-10" name="__codelineno-189-10" href="#__codelineno-189-10"></a><span class="p">};</span>
<a id="__codelineno-189-11" name="__codelineno-189-11" href="#__codelineno-189-11"></a>
<a id="__codelineno-189-12" name="__codelineno-189-12" href="#__codelineno-189-12"></a><span class="c1">// 创建两个对象</span>
<a id="__codelineno-189-13" name="__codelineno-189-13" href="#__codelineno-189-13"></a><span class="n">MyClass</span><span class="w"> </span><span class="n">obj1</span><span class="p">;</span>
<a id="__codelineno-189-14" name="__codelineno-189-14" href="#__codelineno-189-14"></a><span class="n">MyClass</span><span class="w"> </span><span class="n">obj2</span><span class="p">;</span>
<a id="__codelineno-189-15" name="__codelineno-189-15" href="#__codelineno-189-15"></a>
<a id="__codelineno-189-16" name="__codelineno-189-16" href="#__codelineno-189-16"></a><span class="c1">// 使用赋值运算符将 obj1 的值赋给 obj2</span>
<a id="__codelineno-189-17" name="__codelineno-189-17" href="#__codelineno-189-17"></a><span class="n">obj2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj1</span><span class="p">;</span>
</code></pre></div>
<p>在上面的示例中，<code>MyClass</code> 类定义了一个自定义的赋值运算符 <code>operator=</code>，它将另一个 <code>MyClass</code> 类型的对象 <code>other</code> 的值赋给当前对象。通过使用赋值运算符，我们可以将 <code>obj1</code> 的值赋给 <code>obj2</code>。</p>
<p>总结来说，构造函数用于创建对象并初始化其成员变量，而赋值运算符用于将一个对象的值赋给另一个对象。构造函数在对象创建时调用，而赋值运算符在对象已经存在时调用。</p>
<h2 id="250vector">250、vector容器的注意点<a class="headerlink" href="#250vector" title="Permanent link">&para;</a></h2>
<p>如果一个类的拷贝构造函数和赋值构造函数被 <code>delete</code> 掉，那么该类的对象不能直接存储在 <code>std::vector</code> 容器中，因为 <code>std::vector</code> 要求存储的元素类型是可复制或可移动的。</p>
<p>当你尝试将一个没有拷贝构造函数或赋值构造函数的对象添加到 <code>std::vector</code> 中时，编译器会报错，因为它无法生成默认的拷贝构造函数或移动构造函数来复制或移动对象。</p>
<p>在这种情况下，你可以考虑以下几种解决方案：</p>
<ol>
<li>使用指针或智能指针：将对象存储在指针或智能指针中，然后将指针添加到 <code>std::vector</code> 中。这样，你只需要复制或移动指针，而不是对象本身。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-190-1" name="__codelineno-190-1" href="#__codelineno-190-1"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">myVector</span><span class="p">;</span>
<a id="__codelineno-190-2" name="__codelineno-190-2" href="#__codelineno-190-2"></a><span class="n">myVector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">));</span><span class="w">  </span><span class="c1">// 添加对象到 std::vector</span>
</code></pre></div>
<ol>
<li>使用 <code>emplace_back()</code> 函数：使用 <code>emplace_back()</code> 函数直接在 <code>std::vector</code> 中构造对象，而不是复制或移动已有的对象。</li>
</ol>
<div class="highlight"><pre><span></span><code><a id="__codelineno-191-1" name="__codelineno-191-1" href="#__codelineno-191-1"></a><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myVector</span><span class="p">;</span>
<a id="__codelineno-191-2" name="__codelineno-191-2" href="#__codelineno-191-2"></a><span class="n">myVector</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">args</span><span class="p">);</span><span class="w">  </span><span class="c1">// 在 std::vector 中构造对象</span>
</code></pre></div>
<ol>
<li>重新设计类：如果你的类需要被存储在 <code>std::vector</code> 中，并且不能被复制或移动，你可能需要重新设计该类，以使其满足 <code>std::vector</code> 的要求。你可以考虑使用指针或智能指针来管理类的资源，并确保正确地处理对象的复制和移动操作。</li>
</ol>
<p>总结来说，如果一个类的拷贝构造函数和赋值构造函数被 <code>delete</code> 掉，你可以使用指针或智能指针来存储对象的引用，或者使用 <code>emplace_back()</code> 函数直接在 <code>std::vector</code> 中构造对象。如果这些解决方案不适用，你可能需要重新设计类以满足 <code>std::vector</code> 的要求。</p>
<h2 id="255-stdunique_lock-stdlock_guard">255、等待条件变量时，使用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code><a class="headerlink" href="#255-stdunique_lock-stdlock_guard" title="Permanent link">&para;</a></h2>
<p>在等待条件变量时，使用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code> 是因为 <code>std::unique_lock</code> 提供了锁的灵活管理功能，包括可以显式地锁定和解锁，而 <code>std::lock_guard</code> 在构造时锁定，析构时解锁，无法提供这种灵活性。</p>
<p>具体来说，在等待条件变量时，线程需要在调用 <code>wait</code> 方法时释放锁，以便其他线程可以获得锁并改变条件变量的状态。如果使用 <code>std::lock_guard</code>，在调用 <code>wait</code> 方法时无法释放锁，因为 <code>std::lock_guard</code> 不提供显式的解锁功能。而 <code>std::unique_lock</code> 可以在调用 <code>wait</code> 方法时自动释放锁，并在 <code>wait</code> 返回后重新锁定。</p>
<h3 id="_80">代码示例<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-192-1" name="__codelineno-192-1" href="#__codelineno-192-1"></a><span class="p">{</span>
<a id="__codelineno-192-2" name="__codelineno-192-2" href="#__codelineno-192-2"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">m_deployMutex</span><span class="p">);</span>
<a id="__codelineno-192-3" name="__codelineno-192-3" href="#__codelineno-192-3"></a><span class="w">    </span><span class="n">m_deployCv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-192-4" name="__codelineno-192-4" href="#__codelineno-192-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m_remainingDevices</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-192-5" name="__codelineno-192-5" href="#__codelineno-192-5"></a><span class="w">    </span><span class="p">});</span>
<a id="__codelineno-192-6" name="__codelineno-192-6" href="#__codelineno-192-6"></a><span class="p">}</span>
</code></pre></div>
<p>在这段代码中：
- <code>std::unique_lock&lt;std::mutex&gt; lock(m_deployMutex);</code> 锁定 <code>m_deployMutex</code>。
- <code>m_deployCv.wait(lock, [this] { return m_remainingDevices.load() == 0; });</code> 在等待条件变量时自动释放锁，并在条件满足后重新锁定。</p>
<h3 id="_81">总结<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h3>
<p>使用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code> 的原因是 <code>std::unique_lock</code> 提供了显式的锁定和解锁功能，使得在等待条件变量时可以释放锁，以便其他线程可以改变条件变量的状态。这是条件变量正确工作的必要条件。</p>
<p>260、原子变量load和store</p>
<p>在多线程环境中，直接对共享变量进行操作可能会导致竞态条件（race condition）和数据不一致的问题。这是因为多个线程可能同时读取和写入相同的内存位置，导致不确定的结果。</p>
<p>原子变量提供了一种线程安全的方式来对共享变量进行操作，避免了竞态条件和数据不一致的问题。它们保证了操作的原子性，即操作不可分割，不会被其他线程中断。这意味着在多线程环境中，原子变量的操作是线程安全的。</p>
<p>使用原子变量的 <code>store()</code> 和 <code>load()</code> 函数可以确保对共享变量的写入和读取操作是原子的。<code>store()</code> 函数用于将给定的值存储到原子变量中，而 <code>load()</code> 函数用于从原子变量中读取值。</p>
<p>直接对共享变量进行操作可能会导致不确定的结果，因为在多线程环境中，一个线程的写操作可能会与另一个线程的读操作同时发生，导致数据不一致。而使用原子变量的 <code>store()</code> 和 <code>load()</code> 函数可以确保写入和读取操作的完整性和一致性。</p>
<p>以下是一个示例，演示了直接操作共享变量和使用原子变量的区别：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-193-1" name="__codelineno-193-1" href="#__codelineno-193-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-193-2" name="__codelineno-193-2" href="#__codelineno-193-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<a id="__codelineno-193-3" name="__codelineno-193-3" href="#__codelineno-193-3"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span>
<a id="__codelineno-193-4" name="__codelineno-193-4" href="#__codelineno-193-4"></a>
<a id="__codelineno-193-5" name="__codelineno-193-5" href="#__codelineno-193-5"></a><span class="kt">int</span><span class="w"> </span><span class="n">sharedVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-193-6" name="__codelineno-193-6" href="#__codelineno-193-6"></a><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">atomicVar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<a id="__codelineno-193-7" name="__codelineno-193-7" href="#__codelineno-193-7"></a>
<a id="__codelineno-193-8" name="__codelineno-193-8" href="#__codelineno-193-8"></a><span class="kt">void</span><span class="w"> </span><span class="nf">incrementSharedVar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-193-9" name="__codelineno-193-9" href="#__codelineno-193-9"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-193-10" name="__codelineno-193-10" href="#__codelineno-193-10"></a><span class="w">        </span><span class="n">sharedVar</span><span class="o">++</span><span class="p">;</span>
<a id="__codelineno-193-11" name="__codelineno-193-11" href="#__codelineno-193-11"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-193-12" name="__codelineno-193-12" href="#__codelineno-193-12"></a><span class="p">}</span>
<a id="__codelineno-193-13" name="__codelineno-193-13" href="#__codelineno-193-13"></a>
<a id="__codelineno-193-14" name="__codelineno-193-14" href="#__codelineno-193-14"></a><span class="kt">void</span><span class="w"> </span><span class="nf">incrementAtomicVar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-193-15" name="__codelineno-193-15" href="#__codelineno-193-15"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-193-16" name="__codelineno-193-16" href="#__codelineno-193-16"></a><span class="w">        </span><span class="n">atomicVar</span><span class="o">++</span><span class="p">;</span>
<a id="__codelineno-193-17" name="__codelineno-193-17" href="#__codelineno-193-17"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-193-18" name="__codelineno-193-18" href="#__codelineno-193-18"></a><span class="p">}</span>
<a id="__codelineno-193-19" name="__codelineno-193-19" href="#__codelineno-193-19"></a>
<a id="__codelineno-193-20" name="__codelineno-193-20" href="#__codelineno-193-20"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-193-21" name="__codelineno-193-21" href="#__codelineno-193-21"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">incrementSharedVar</span><span class="p">);</span>
<a id="__codelineno-193-22" name="__codelineno-193-22" href="#__codelineno-193-22"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t2</span><span class="p">(</span><span class="n">incrementSharedVar</span><span class="p">);</span>
<a id="__codelineno-193-23" name="__codelineno-193-23" href="#__codelineno-193-23"></a>
<a id="__codelineno-193-24" name="__codelineno-193-24" href="#__codelineno-193-24"></a><span class="w">    </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<a id="__codelineno-193-25" name="__codelineno-193-25" href="#__codelineno-193-25"></a><span class="w">    </span><span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<a id="__codelineno-193-26" name="__codelineno-193-26" href="#__codelineno-193-26"></a>
<a id="__codelineno-193-27" name="__codelineno-193-27" href="#__codelineno-193-27"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Shared variable value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sharedVar</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-193-28" name="__codelineno-193-28" href="#__codelineno-193-28"></a>
<a id="__codelineno-193-29" name="__codelineno-193-29" href="#__codelineno-193-29"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t3</span><span class="p">(</span><span class="n">incrementAtomicVar</span><span class="p">);</span>
<a id="__codelineno-193-30" name="__codelineno-193-30" href="#__codelineno-193-30"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t4</span><span class="p">(</span><span class="n">incrementAtomicVar</span><span class="p">);</span>
<a id="__codelineno-193-31" name="__codelineno-193-31" href="#__codelineno-193-31"></a>
<a id="__codelineno-193-32" name="__codelineno-193-32" href="#__codelineno-193-32"></a><span class="w">    </span><span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<a id="__codelineno-193-33" name="__codelineno-193-33" href="#__codelineno-193-33"></a><span class="w">    </span><span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<a id="__codelineno-193-34" name="__codelineno-193-34" href="#__codelineno-193-34"></a>
<a id="__codelineno-193-35" name="__codelineno-193-35" href="#__codelineno-193-35"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Atomic variable value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">atomicVar</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-193-36" name="__codelineno-193-36" href="#__codelineno-193-36"></a>
<a id="__codelineno-193-37" name="__codelineno-193-37" href="#__codelineno-193-37"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-193-38" name="__codelineno-193-38" href="#__codelineno-193-38"></a><span class="p">}</span>
</code></pre></div>
<p>在上面的示例中，我们创建了两个线程 <code>t1</code> 和 <code>t2</code>，它们同时对共享变量 <code>sharedVar</code> 进行递增操作。然后，我们创建了两个线程 <code>t3</code> 和 <code>t4</code>，它们同时对原子变量 <code>atomicVar</code> 进行递增操作。最后，我们分别输出了 <code>sharedVar</code> 和 <code>atomicVar</code> 的值。</p>
<p>运行这个程序，你会发现 <code>sharedVar</code> 的值是不确定的，因为多个线程同时对它进行写操作，导致竞态条件。而 <code>atomicVar</code> 的值是确定的，因为原子变量的操作是线程安全的。</p>
<p>因此，为了保证在多线程环境中对共享变量的操作是线程安全的，推荐使用原子变量的 <code>store()</code> 和 <code>load()</code> 函数来进行操作。这样可以避免竞态条件和数据不一致的问题。</p>
<h2 id="260">260、锁的问题<a class="headerlink" href="#260" title="Permanent link">&para;</a></h2>
<p>在使用条件变量 (<code>std::condition_variable</code>) 的过程中，通常不需要在调用 <code>notify_one</code> 或 <code>notify_all</code> 时持有互斥锁。事实上，标准库的实现和最佳实践建议在不持有锁的情况下调用 <code>notify_one</code> 或 <code>notify_all</code>，以避免潜在的死锁和性能问题。</p>
<h3 id="_82">具体原因<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>避免死锁</strong>：如果在持有锁的情况下调用 <code>notify</code>，可能会导致死锁。例如，如果通知线程在持有锁时调用 <code>notify</code>，而被通知的线程在等待锁，这样就会导致死锁。</li>
<li><strong>性能考虑</strong>：在持有锁时调用 <code>notify</code> 可能会导致不必要的锁竞争，影响性能。</li>
</ol>
<h3 id="_83">正确的使用方式<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h3>
<p>通常的做法是，在完成对共享数据的修改后，释放锁，然后调用 <code>notify_one</code> 或 <code>notify_all</code>。这样可以确保通知线程不会在持有锁时阻塞其他线程。</p>
<h2 id="265share_from_thisweak_ptrweak_ptrlockshare_ptr">265、share_from_this返回了一个weak_ptr，然后weak_ptr再去lock得到一个share_ptr是什么操作<a class="headerlink" href="#265share_from_thisweak_ptrweak_ptrlockshare_ptr" title="Permanent link">&para;</a></h2>
<p>在 C++ 中，<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 是两种智能指针类型，用于管理对象的生命周期和解决循环引用问题。<code>std::shared_ptr</code> 持有对象的强引用，而 <code>std::weak_ptr</code> 持有对象的弱引用，不会影响对象的生命周期。</p>
<h3 id="shared_from_this-weak_ptr"><code>shared_from_this</code> 和 <code>weak_ptr</code> 的使用<a class="headerlink" href="#shared_from_this-weak_ptr" title="Permanent link">&para;</a></h3>
<p><code>shared_from_this</code> 是 <code>std::enable_shared_from_this</code> 类提供的一个成员函数，它允许一个类安全地生成一个指向自身的 <code>std::shared_ptr</code>。这在需要从类内部生成 <code>shared_ptr</code> 时非常有用。</p>
<h3 id="weak_ptr-lock"><code>weak_ptr</code> 和 <code>lock</code><a class="headerlink" href="#weak_ptr-lock" title="Permanent link">&para;</a></h3>
<p><code>std::weak_ptr</code> 的主要用途是解决循环引用问题。它不会增加对象的引用计数，但可以通过 <code>lock</code> 方法临时提升为 <code>std::shared_ptr</code>，如果对象已经被销毁，<code>lock</code> 方法会返回一个空的 <code>shared_ptr</code>。</p>
<h3 id="_84">操作步骤<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h3>
<ol>
<li><strong><code>shared_from_this</code> 返回 <code>weak_ptr</code></strong>：</li>
<li>当一个对象需要从自身生成一个 <code>shared_ptr</code> 时，可以调用 <code>shared_from_this</code> 方法。这个方法返回一个 <code>std::shared_ptr</code>，指向当前对象。</li>
<li>然后，可以将这个 <code>shared_ptr</code> 转换为 <code>std::weak_ptr</code>，以避免增加引用计数。</li>
<li><strong><code>weak_ptr</code> 转 <code>shared_ptr</code></strong>：</li>
<li>当需要使用对象时，可以调用 <code>weak_ptr</code> 的 <code>lock</code> 方法。这个方法会返回一个 <code>std::shared_ptr</code>，如果对象仍然存在，则指向该对象；如果对象已经被销毁，则返回一个空的 <code>shared_ptr</code>。</li>
</ol>
<h2 id="270stdmutexlockunlocklock_guardunique_lock">270、std::mutex直接lock和unlock、lock_guard、unique_lock的区别<a class="headerlink" href="#270stdmutexlockunlocklock_guardunique_lock" title="Permanent link">&para;</a></h2>
<p><code>std::mutex</code> 是 C++ 标准库提供的互斥量类型，用于实现线程之间的互斥访问。在使用 <code>std::mutex</code> 时，可以使用以下三种方式来管理互斥量：</p>
<ol>
<li>
<p>直接调用 <code>lock</code> 和 <code>unlock</code>：可以通过调用 <code>lock</code> 来获得互斥量的所有权，然后在使用完互斥量后调用 <code>unlock</code> 来释放互斥量。这种方式需要手动管理互斥量的锁定和解锁，容易出错，不建议直接使用，除非有特殊的需求。</p>
</li>
<li>
<p><code>std::lock_guard</code>：<code>std::lock_guard</code> 是一个模板类，用于自动管理互斥量。在创建 <code>std::lock_guard</code> 对象时，会自动调用 <code>lock</code> 来获得互斥量的所有权，并在对象生命周期结束时调用 <code>unlock</code> 来释放互斥量。这样可以确保在退出作用域时自动释放互斥量，避免忘记解锁的问题。<code>std::lock_guard</code> 只提供了锁定和解锁的功能，没有其他额外的灵活性。</p>
</li>
<li>
<p><code>std::unique_lock</code>：<code>std::unique_lock</code> 是一个更灵活的互斥量管理类。与 <code>std::lock_guard</code> 不同，<code>std::unique_lock</code> 对象可以手动锁定和解锁互斥量，也可以在构造函数中指定是否锁定互斥量。此外，<code>std::unique_lock</code> 还提供了更多的功能，如延迟锁定、可转移所有权等。与 <code>std::lock_guard</code> 类似，<code>std::unique_lock</code> 在对象生命周期结束时会自动调用 <code>unlock</code> 来释放互斥量。</p>
</li>
</ol>
<p>总结一下，<code>std::mutex</code> 的直接调用 <code>lock</code> 和 <code>unlock</code> 需要手动管理互斥量的锁定和解锁，容易出错。<code>std::lock_guard</code> 提供了自动锁定和解锁的功能，适用于简单的互斥访问场景。而 <code>std::unique_lock</code> 则更加灵活，可以手动控制锁定和解锁的时机，并提供了更多的功能。在一般情况下，推荐使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 来管理互斥量，以确保在退出作用域时自动释放互斥量，避免忘记解锁的问题。</p>
<h2 id="275unique_locklockunlock">275、unique_lock手动lock和unlock的区别<a class="headerlink" href="#275unique_locklockunlock" title="Permanent link">&para;</a></h2>
<p><code>std::unique_lock</code> 提供了手动控制互斥量的锁定和解锁的能力，与 <code>std::lock_guard</code> 不同，它允许在需要的时候手动调用 <code>lock</code> 和 <code>unlock</code>。</p>
<p>使用 <code>std::unique_lock</code> 的手动锁定和解锁可以提供更大的灵活性和控制能力。下面是手动调用 <code>lock</code> 和 <code>unlock</code> 的一些常见用例和区别：</p>
<ol>
<li>
<p>延迟锁定：<code>std::unique_lock</code> 允许在构造函数中指定是否锁定互斥量。如果使用 <code>std::unique_lock</code> 的默认构造函数创建对象，互斥量不会被自动锁定，需要手动调用 <code>lock</code> 来锁定互斥量。这种延迟锁定的机制可以在一些情况下提高性能，只在需要的时候才获取互斥量的所有权。</p>
</li>
<li>
<p>临时解锁：<code>std::unique_lock</code> 允许临时解锁互斥量，然后再次锁定。通过调用 <code>unlock</code> 可以释放互斥量的所有权，让其他线程有机会获得互斥量的所有权。然后可以通过调用 <code>lock</code> 再次锁定互斥量，继续执行互斥代码块。这种临时解锁的机制可以在某些情况下减少互斥量的持有时间，提高并发性能。</p>
</li>
<li>
<p>转移所有权：<code>std::unique_lock</code> 对象可以通过移动语义进行转移。这意味着可以将一个 <code>std::unique_lock</code> 对象的所有权转移到另一个 <code>std::unique_lock</code> 对象，而不需要手动解锁和重新锁定互斥量。这在一些复杂的场景中可以方便地传递互斥量的所有权。</p>
</li>
</ol>
<p>总结一下，与 <code>std::lock_guard</code> 不同，<code>std::unique_lock</code> 提供了更多的灵活性和控制能力。它允许延迟锁定、临时解锁和转移所有权，可以根据具体的需求进行操作。这些功能使得 <code>std::unique_lock</code> 在一些复杂的并发场景中更加有用。然而，在简单的互斥访问场景中，如果不需要手动控制锁定和解锁的时机，使用 <code>std::lock_guard</code> 更加简单和方便。</p>
<p><strong>所以说这时unique_lock有没有真正锁定互斥量</strong></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-194-1" name="__codelineno-194-1" href="#__codelineno-194-1"></a>void notifyingThread()
<a id="__codelineno-194-2" name="__codelineno-194-2" href="#__codelineno-194-2"></a>{
<a id="__codelineno-194-3" name="__codelineno-194-3" href="#__codelineno-194-3"></a>    std::this_thread::sleep_for(std::chrono::seconds(2));
<a id="__codelineno-194-4" name="__codelineno-194-4" href="#__codelineno-194-4"></a>    std::unique_lock&lt;std::mutex&gt; lock(mtx);  // 获取互斥量
<a id="__codelineno-194-5" name="__codelineno-194-5" href="#__codelineno-194-5"></a>    ready = true;
<a id="__codelineno-194-6" name="__codelineno-194-6" href="#__codelineno-194-6"></a>    cv.notify_one();  // 唤醒等待线程，并自动释放互斥量
<a id="__codelineno-194-7" name="__codelineno-194-7" href="#__codelineno-194-7"></a>}
</code></pre></div>
<p>在你提供的代码中，<code>std::unique_lock</code> 调用的 <code>lock</code> 函数会真正锁定互斥量。在这之后，你可以对互斥量进行操作，修改 <code>ready</code> 的值，并使用 <code>cv.notify_one()</code> 唤醒等待线程。</p>
<p><code>std::unique_lock</code> 的构造函数会调用 <code>lock</code> 函数，以获取互斥量的所有权。这意味着在构造函数完成后，互斥量已经被成功锁定。在你的代码中，<code>std::unique_lock</code> 对象 <code>lock</code> 的构造函数会获取 <code>mtx</code> 互斥量的所有权。</p>
<p>在 <code>std::unique_lock</code> 对象的生命周期内，互斥量会一直保持锁定状态，直到 <code>std::unique_lock</code> 对象被销毁。在你的代码中，<code>std::unique_lock</code> 对象 <code>lock</code> 的生命周期是在函数结束时。所以，在函数结束时，<code>std::unique_lock</code> 对象 <code>lock</code> 会被销毁，同时会调用 <code>unlock</code> 函数来释放互斥量。</p>
<p>需要注意的是，当调用 <code>cv.notify_one()</code> 唤醒等待线程时，<code>std::unique_lock</code> 对象 <code>lock</code> 会自动释放互斥量。这是因为 <code>std::unique_lock</code> 对象的析构函数会在对象被销毁时自动调用 <code>unlock</code> 函数来释放互斥量。这样可以确保在唤醒等待线程后，互斥量会被正确释放，让其他线程有机会获取互斥量的所有权。</p>
<p>综上所述，你的代码中的 <code>std::unique_lock</code> 对象 <code>lock</code> 会真正锁定互斥量，并在函数结束时自动释放互斥量。（这种操作和lock_guard是一样的）</p>
<p><strong>正常说我不想锁定，真正要操作的时候再锁定如何实现</strong></p>
<p>如果你不想在 <code>std::unique_lock</code> 的构造函数中立即锁定互斥量，而是在需要执行操作时再锁定互斥量，你可以使用 <code>std::unique_lock</code> 的默认构造函数创建一个未锁定的对象，然后在需要的时候调用 <code>lock</code> 函数来手动锁定互斥量。</p>
<p>下面是一个示例代码：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-195-1" name="__codelineno-195-1" href="#__codelineno-195-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">notifyingThread</span><span class="p">()</span>
<a id="__codelineno-195-2" name="__codelineno-195-2" href="#__codelineno-195-2"></a><span class="p">{</span>
<a id="__codelineno-195-3" name="__codelineno-195-3" href="#__codelineno-195-3"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<a id="__codelineno-195-4" name="__codelineno-195-4" href="#__codelineno-195-4"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span><span class="w">  </span><span class="c1">// 创建未锁定的 unique_lock 对象</span>
<a id="__codelineno-195-5" name="__codelineno-195-5" href="#__codelineno-195-5"></a><span class="w">    </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<a id="__codelineno-195-6" name="__codelineno-195-6" href="#__codelineno-195-6"></a>
<a id="__codelineno-195-7" name="__codelineno-195-7" href="#__codelineno-195-7"></a><span class="w">    </span><span class="c1">// 执行一些其他操作</span>
<a id="__codelineno-195-8" name="__codelineno-195-8" href="#__codelineno-195-8"></a>
<a id="__codelineno-195-9" name="__codelineno-195-9" href="#__codelineno-195-9"></a><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w">  </span><span class="c1">// 手动锁定互斥量</span>
<a id="__codelineno-195-10" name="__codelineno-195-10" href="#__codelineno-195-10"></a><span class="w">    </span><span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w">  </span><span class="c1">// 唤醒等待线程</span>
<a id="__codelineno-195-11" name="__codelineno-195-11" href="#__codelineno-195-11"></a><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w">  </span><span class="c1">// 手动解锁互斥量</span>
<a id="__codelineno-195-12" name="__codelineno-195-12" href="#__codelineno-195-12"></a><span class="p">}</span>
</code></pre></div>
<p>在这个示例中，我们使用了 <code>std::unique_lock</code> 的构造函数的第二个参数 <code>std::defer_lock</code>，它指示 <code>std::unique_lock</code> 对象不会立即锁定互斥量。</p>
<p>在 <code>ready = true;</code> 之后，我们可以执行一些其他的操作，然后调用 <code>lock.lock()</code> 来手动锁定互斥量。这样，我们可以在需要的时候控制互斥量的锁定时机。</p>
<p>然后，我们可以执行一些其他操作，最后调用 <code>lock.unlock()</code> 来手动解锁互斥量。这样可以确保在唤醒等待线程后，互斥量会被正确地释放。</p>
<p>这种方式允许你在需要时手动控制互斥量的锁定和解锁，提供了更大的灵活性。</p>
<p><strong>构造时立即锁定，然后手动unlock也可以</strong></p>
<p>如果你不想在 <code>std::unique_lock</code> 的构造函数中立即锁定互斥量，而是在需要执行操作时再锁定互斥量，你可以使用 <code>std::unique_lock</code> 的默认构造函数创建一个未锁定的对象，然后在需要的时候调用 <code>lock</code> 函数来手动锁定互斥量。</p>
<p>下面是一个示例代码：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-196-1" name="__codelineno-196-1" href="#__codelineno-196-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">notifyingThread</span><span class="p">()</span>
<a id="__codelineno-196-2" name="__codelineno-196-2" href="#__codelineno-196-2"></a><span class="p">{</span>
<a id="__codelineno-196-3" name="__codelineno-196-3" href="#__codelineno-196-3"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<a id="__codelineno-196-4" name="__codelineno-196-4" href="#__codelineno-196-4"></a><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span><span class="w">  </span><span class="c1">// 创建未锁定的 unique_lock 对象</span>
<a id="__codelineno-196-5" name="__codelineno-196-5" href="#__codelineno-196-5"></a><span class="w">    </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<a id="__codelineno-196-6" name="__codelineno-196-6" href="#__codelineno-196-6"></a>
<a id="__codelineno-196-7" name="__codelineno-196-7" href="#__codelineno-196-7"></a><span class="w">    </span><span class="c1">// 执行一些其他操作</span>
<a id="__codelineno-196-8" name="__codelineno-196-8" href="#__codelineno-196-8"></a>
<a id="__codelineno-196-9" name="__codelineno-196-9" href="#__codelineno-196-9"></a><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w">  </span><span class="c1">// 手动锁定互斥量</span>
<a id="__codelineno-196-10" name="__codelineno-196-10" href="#__codelineno-196-10"></a><span class="w">    </span><span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w">  </span><span class="c1">// 唤醒等待线程</span>
<a id="__codelineno-196-11" name="__codelineno-196-11" href="#__codelineno-196-11"></a><span class="w">    </span><span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span><span class="w">  </span><span class="c1">// 手动解锁互斥量</span>
<a id="__codelineno-196-12" name="__codelineno-196-12" href="#__codelineno-196-12"></a><span class="p">}</span>
</code></pre></div>
<p>在这个示例中，我们使用了 <code>std::unique_lock</code> 的构造函数的第二个参数 <code>std::defer_lock</code>，它指示 <code>std::unique_lock</code> 对象不会立即锁定互斥量。</p>
<p>在 <code>ready = true;</code> 之后，我们可以执行一些其他的操作，然后调用 <code>lock.lock()</code> 来手动锁定互斥量。这样，我们可以在需要的时候控制互斥量的锁定时机。</p>
<p>然后，我们可以执行一些其他操作，最后调用 <code>lock.unlock()</code> 来手动解锁互斥量。这样可以确保在唤醒等待线程后，互斥量会被正确地释放。</p>
<p>这种方式允许你在需要时手动控制互斥量的锁定和解锁，提供了更大的灵活性。</p>
<h2 id="280notify">280、什么时候调用notify<a class="headerlink" href="#280notify" title="Permanent link">&para;</a></h2>
<p>在多线程编程中，<code>notify</code>（或 <code>notify_one</code>、<code>notify_all</code>）方法用于通知等待的线程某个条件已经满足。具体来说，<code>notify</code> 方法通常与条件变量（<code>std::condition_variable</code>）一起使用，以实现线程间的同步。</p>
<h3 id="notify">什么时候调用 <code>notify</code><a class="headerlink" href="#notify" title="Permanent link">&para;</a></h3>
<p>你应该在某个共享状态发生变化，并且这个变化可能会解除其他线程的等待条件时调用 <code>notify</code>。以下是一些常见的场景：</p>
<ol>
<li><strong>生产者-消费者模式</strong>：当生产者线程向队列中添加新元素时，它会调用 <code>notify</code> 来通知消费者线程有新数据可用。</li>
<li><strong>任务完成通知</strong>：当某个异步任务完成时，回调函数会调用 <code>notify</code> 来通知等待的线程任务已经完成。</li>
<li><strong>状态变化通知</strong>：当某个共享状态发生变化，并且其他线程正在等待这个状态变化时，调用 <code>notify</code> 以解除等待。</li>
</ol>
<p>在你提供的代码中，我们需要在所有设备的部署操作完成后调用 <code>notify_all</code>，以通知等待的线程所有设备的部署操作已经完成。</p>
<h2 id="285">285、前向声明<a class="headerlink" href="#285" title="Permanent link">&para;</a></h2>
<p>C++的类可以进行前向声明。但是，仅仅进行前向声明而没有定义的类是不完整的，这样的类，<strong>只能用于定义指针、引用、以及用于函数形参的指针、引用（函数声明的形参本身也可以，因为声明时也不需要知道该形参本身的大小）。</strong>
而不能定义对象(因为此时编译器只知道这是个类，还不知道这个类的大小有多大)，也不能访问类的对象，任何形式的访问都不允许(因为此时根本不知道有些什么成员，继承就更不行了)。等到类正式定义以后，就可以以各种方式使用该类了。  </p>
<h2 id="290">290、不要出现交叉引用的问题<a class="headerlink" href="#290" title="Permanent link">&para;</a></h2>
<p>头文件之间不要交叉引用</p>
<p>类之间不要交叉引用</p>
<h2 id="295">295、虚函数在基类要声明成什么访问类型，在子类重载时又要声明成什么访问类型<a class="headerlink" href="#295" title="Permanent link">&para;</a></h2>
<p>在基类中，虚函数的访问类型通常声明为 <code>public</code>。这是因为虚函数是用来实现多态性的，子类需要能够重写（或称为覆盖）基类的虚函数。</p>
<p>在子类中，重载（或称为覆盖）虚函数时，访问类型应保持一致，即与基类中的虚函数的访问类型相同。这是为了确保子类可以正确地覆盖基类的虚函数，并且在通过基类指针或引用调用虚函数时，能够调用到正确的子类实现。</p>
<p>下面是一个示例，展示了虚函数在基类和子类中的访问类型声明：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-197-1" name="__codelineno-197-1" href="#__codelineno-197-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-197-2" name="__codelineno-197-2" href="#__codelineno-197-2"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-197-3" name="__codelineno-197-3" href="#__codelineno-197-3"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-197-4" name="__codelineno-197-4" href="#__codelineno-197-4"></a><span class="w">        </span><span class="c1">// 基类虚函数的实现</span>
<a id="__codelineno-197-5" name="__codelineno-197-5" href="#__codelineno-197-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-197-6" name="__codelineno-197-6" href="#__codelineno-197-6"></a><span class="p">};</span>
<a id="__codelineno-197-7" name="__codelineno-197-7" href="#__codelineno-197-7"></a>
<a id="__codelineno-197-8" name="__codelineno-197-8" href="#__codelineno-197-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-197-9" name="__codelineno-197-9" href="#__codelineno-197-9"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-197-10" name="__codelineno-197-10" href="#__codelineno-197-10"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-197-11" name="__codelineno-197-11" href="#__codelineno-197-11"></a><span class="w">        </span><span class="c1">// 子类重载虚函数的实现</span>
<a id="__codelineno-197-12" name="__codelineno-197-12" href="#__codelineno-197-12"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-197-13" name="__codelineno-197-13" href="#__codelineno-197-13"></a><span class="p">};</span>
</code></pre></div>
<p>在上述示例中，基类 <code>Base</code> 声明了一个公有的虚函数 <code>foo()</code>。子类 <code>Derived</code> 继承自 <code>Base</code> 并重载了 <code>foo()</code> 函数，同时保持了访问类型为 <code>public</code>。</p>
<p>请注意，子类中重载虚函数时，可以使用 <code>override</code> 关键字显式指示重载关系。这样做有助于编译器检查是否正确地重载了基类的虚函数。如果在子类中使用了错误的访问类型或函数签名与基类不匹配，编译器将产生错误。</p>
<p>总结起来，在基类中将虚函数声明为 <code>public</code>（protected也一样），<strong>在子类中重载虚函数时保持相同的访问类型</strong>，这是一种常见的做法，用于实现多态性和正确的函数调用。</p>
<h2 id="300protectedprivate">300、虚函数在基类声明成protected成员，子类可以声明成private吗<a class="headerlink" href="#300protectedprivate" title="Permanent link">&para;</a></h2>
<p>虚函数在基类中声明为 <code>protected</code> 成员时，子类不可以将其声明为 <code>private</code>。这是因为虚函数的访问级别在派生类中必须保持一致。</p>
<p>在 C++ 中，虚函数用于实现多态性，允许派生类通过重写基类的虚函数来改变其行为。为了实现多态性，派生类必须能够覆盖（重写）基类的虚函数。如果将虚函数在派生类中声明为 <code>private</code>，则无法在派生类中访问该函数，从而无法重写它。</p>
<p>以下是一个示例，展示了虚函数在基类中声明为 <code>protected</code>，以及在子类中无法将其声明为 <code>private</code> 的情况：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-198-1" name="__codelineno-198-1" href="#__codelineno-198-1"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-198-2" name="__codelineno-198-2" href="#__codelineno-198-2"></a><span class="k">protected</span><span class="o">:</span>
<a id="__codelineno-198-3" name="__codelineno-198-3" href="#__codelineno-198-3"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">protectedVirtualFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-198-4" name="__codelineno-198-4" href="#__codelineno-198-4"></a><span class="w">        </span><span class="c1">// 基类的虚函数实现</span>
<a id="__codelineno-198-5" name="__codelineno-198-5" href="#__codelineno-198-5"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-198-6" name="__codelineno-198-6" href="#__codelineno-198-6"></a><span class="p">};</span>
<a id="__codelineno-198-7" name="__codelineno-198-7" href="#__codelineno-198-7"></a>
<a id="__codelineno-198-8" name="__codelineno-198-8" href="#__codelineno-198-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-198-9" name="__codelineno-198-9" href="#__codelineno-198-9"></a><span class="k">private</span><span class="o">:</span>
<a id="__codelineno-198-10" name="__codelineno-198-10" href="#__codelineno-198-10"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">protectedVirtualFunction</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 错误！无法将虚函数声明为 private</span>
<a id="__codelineno-198-11" name="__codelineno-198-11" href="#__codelineno-198-11"></a><span class="w">        </span><span class="c1">// 派生类的虚函数实现</span>
<a id="__codelineno-198-12" name="__codelineno-198-12" href="#__codelineno-198-12"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-198-13" name="__codelineno-198-13" href="#__codelineno-198-13"></a><span class="p">};</span>
</code></pre></div>
<p>在上述示例中，基类 <code>Base</code> 声明了一个 <code>protected</code> 的虚函数 <code>protectedVirtualFunction()</code>。子类 <code>Derived</code> 继承自 <code>Base</code>，并试图将虚函数声明为 <code>private</code>，但这是不允许的。</p>
<p>需要注意的是，派生类可以将基类的虚函数声明为 <code>public</code> 或 <code>protected</code>，以便在派生类中对其进行重写。这样做可以保持虚函数的访问级别一致，并允许派生类实现自己的行为。</p>
<p>总结起来，虚函数在基类中声明为 <code>protected</code> 成员时，子类不可以将其声明为 <code>private</code>。派生类必须能够访问虚函数才能重写它，以实现多态性。</p>
<h2 id="305delete">305、为什么习惯将拷贝构造函数和赋值构造函数声明为delete<a class="headerlink" href="#305delete" title="Permanent link">&para;</a></h2>
<p>将拷贝构造函数和赋值构造函数声明为 <code>delete</code> 的主要目的是防止对象的拷贝和赋值操作，以确保对象的唯一性和正确的资源管理。这样做可以避免一些潜在的问题和错误用法。</p>
<p>以下是一些常见的原因：</p>
<ol>
<li>
<p>防止对象的意外复制：有时，对象的拷贝可能会引发意外的行为或错误。通过将拷贝构造函数和赋值构造函数声明为 <code>delete</code>，可以防止在不正确的上下文中进行对象的拷贝操作。</p>
</li>
<li>
<p>禁止浅拷贝：某些类可能包含指针或资源，如果进行浅拷贝，多个对象将共享相同的指针或资源，可能导致资源泄漏、重复释放等问题。通过禁用拷贝构造函数和赋值构造函数，可以强制使用者实现深拷贝或提供其他适当的方式来处理资源。</p>
</li>
<li>
<p>显式表达对象的不可复制性：有时，某些类的设计本身就不支持对象的拷贝或赋值。通过将拷贝构造函数和赋值构造函数声明为 <code>delete</code>，可以明确表达这一点，并防止不正确的使用。</p>
</li>
<li>
<p>C++11 移动语义的支持：在 C++11 中，通过移动语义可以实现高效的资源管理和对象转移。如果一个类已经实现了移动构造函数和移动赋值运算符，并且不希望支持拷贝构造函数和赋值构造函数，可以将它们声明为 <code>delete</code>，以强制使用者使用移动语义。</p>
</li>
</ol>
<p>总的来说，将拷贝构造函数和赋值构造函数声明为 <code>delete</code> 可以帮助确保对象的唯一性、正确的资源管理和避免意外行为。这是一种良好的编程实践，可以提高代码的可靠性和可维护性。</p>
<h2 id="310extern-c">310、什么时候加extern "C"<a class="headerlink" href="#310extern-c" title="Permanent link">&para;</a></h2>
<p>希望这块代码的内容是纯C的，不希望它被cpp进行了编译的转换</p>
<h2 id="315">315、孙子类继承<a class="headerlink" href="#315" title="Permanent link">&para;</a></h2>
<p>孙子类继承自子类时，可以直接使用子类重写的基类虚函数。</p>
<p>孙子类如果向重写该虚函数，也可以继续重写</p>
<h2 id="320">320、基类指针指向子类和孙子类<a class="headerlink" href="#320" title="Permanent link">&para;</a></h2>
<p>在 C++ 中，将基类指针转换为子类指针和孙子类指针的成功与否取决于类之间的继承关系。</p>
<ol>
<li>将基类指针转换为子类指针：</li>
<li>如果基类指针实际上指向一个子类对象，则将基类指针转换为子类指针是有效的，并且转换会成功。</li>
<li>如果基类指针实际上指向一个孙子类对象，则将基类指针直接转换为子类指针是不安全的，转换会失败，返回空指针（<code>nullptr</code>）。</li>
<li>将基类指针转换为孙子类指针：</li>
<li>将基类指针直接转换为孙子类指针是不安全的，转换会失败，返回空指针（<code>nullptr</code>）。</li>
</ol>
<p>这是因为指针类型的转换是基于类之间的继承关系的。子类可以安全地转换为基类，因为子类对象包含了基类的成员。但是，将基类指针转换为子类指针需要确保基类指针实际上指向的是子类对象而不是孙子类对象。同样，将基类指针转换为孙子类指针需要确保基类指针实际上指向的是孙子类对象而不是其他类型的对象。</p>
<p>以下是一个示例代码，演示了基类指针转换为子类指针和孙子类指针的情况：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-199-1" name="__codelineno-199-1" href="#__codelineno-199-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-199-2" name="__codelineno-199-2" href="#__codelineno-199-2"></a>
<a id="__codelineno-199-3" name="__codelineno-199-3" href="#__codelineno-199-3"></a><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-4" name="__codelineno-199-4" href="#__codelineno-199-4"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-199-5" name="__codelineno-199-5" href="#__codelineno-199-5"></a><span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<a id="__codelineno-199-6" name="__codelineno-199-6" href="#__codelineno-199-6"></a><span class="p">};</span>
<a id="__codelineno-199-7" name="__codelineno-199-7" href="#__codelineno-199-7"></a>
<a id="__codelineno-199-8" name="__codelineno-199-8" href="#__codelineno-199-8"></a><span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-9" name="__codelineno-199-9" href="#__codelineno-199-9"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-199-10" name="__codelineno-199-10" href="#__codelineno-199-10"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">derivedFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-11" name="__codelineno-199-11" href="#__codelineno-199-11"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Derived::derivedFunction()&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-199-12" name="__codelineno-199-12" href="#__codelineno-199-12"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-199-13" name="__codelineno-199-13" href="#__codelineno-199-13"></a><span class="p">};</span>
<a id="__codelineno-199-14" name="__codelineno-199-14" href="#__codelineno-199-14"></a>
<a id="__codelineno-199-15" name="__codelineno-199-15" href="#__codelineno-199-15"></a><span class="k">class</span><span class="w"> </span><span class="nc">GrandChild</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Derived</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-16" name="__codelineno-199-16" href="#__codelineno-199-16"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-199-17" name="__codelineno-199-17" href="#__codelineno-199-17"></a><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">grandChildFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-18" name="__codelineno-199-18" href="#__codelineno-199-18"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;GrandChild::grandChildFunction()&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-199-19" name="__codelineno-199-19" href="#__codelineno-199-19"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-199-20" name="__codelineno-199-20" href="#__codelineno-199-20"></a><span class="p">};</span>
<a id="__codelineno-199-21" name="__codelineno-199-21" href="#__codelineno-199-21"></a>
<a id="__codelineno-199-22" name="__codelineno-199-22" href="#__codelineno-199-22"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-23" name="__codelineno-199-23" href="#__codelineno-199-23"></a><span class="w">    </span><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">basePtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GrandChild</span><span class="p">();</span>
<a id="__codelineno-199-24" name="__codelineno-199-24" href="#__codelineno-199-24"></a>
<a id="__codelineno-199-25" name="__codelineno-199-25" href="#__codelineno-199-25"></a><span class="w">    </span><span class="c1">// 将基类指针转换为子类指针</span>
<a id="__codelineno-199-26" name="__codelineno-199-26" href="#__codelineno-199-26"></a><span class="w">    </span><span class="n">Derived</span><span class="o">*</span><span class="w"> </span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">basePtr</span><span class="p">);</span>
<a id="__codelineno-199-27" name="__codelineno-199-27" href="#__codelineno-199-27"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">derivedPtr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-28" name="__codelineno-199-28" href="#__codelineno-199-28"></a><span class="w">        </span><span class="n">derivedPtr</span><span class="o">-&gt;</span><span class="n">derivedFunction</span><span class="p">();</span><span class="w">  </span><span class="c1">// 输出：Derived::derivedFunction()</span>
<a id="__codelineno-199-29" name="__codelineno-199-29" href="#__codelineno-199-29"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-30" name="__codelineno-199-30" href="#__codelineno-199-30"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;dynamic_cast to Derived failed&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-199-31" name="__codelineno-199-31" href="#__codelineno-199-31"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-199-32" name="__codelineno-199-32" href="#__codelineno-199-32"></a>
<a id="__codelineno-199-33" name="__codelineno-199-33" href="#__codelineno-199-33"></a><span class="w">    </span><span class="c1">// 将基类指针转换为孙子类指针</span>
<a id="__codelineno-199-34" name="__codelineno-199-34" href="#__codelineno-199-34"></a><span class="w">    </span><span class="n">GrandChild</span><span class="o">*</span><span class="w"> </span><span class="n">grandChildPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">GrandChild</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">basePtr</span><span class="p">);</span>
<a id="__codelineno-199-35" name="__codelineno-199-35" href="#__codelineno-199-35"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grandChildPtr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-36" name="__codelineno-199-36" href="#__codelineno-199-36"></a><span class="w">        </span><span class="n">grandChildPtr</span><span class="o">-&gt;</span><span class="n">grandChildFunction</span><span class="p">();</span><span class="w">  </span><span class="c1">// 输出：GrandChild::grandChildFunction()</span>
<a id="__codelineno-199-37" name="__codelineno-199-37" href="#__codelineno-199-37"></a><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-199-38" name="__codelineno-199-38" href="#__codelineno-199-38"></a><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;dynamic_cast to GrandChild failed&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-199-39" name="__codelineno-199-39" href="#__codelineno-199-39"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-199-40" name="__codelineno-199-40" href="#__codelineno-199-40"></a>
<a id="__codelineno-199-41" name="__codelineno-199-41" href="#__codelineno-199-41"></a><span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">basePtr</span><span class="p">;</span>
<a id="__codelineno-199-42" name="__codelineno-199-42" href="#__codelineno-199-42"></a>
<a id="__codelineno-199-43" name="__codelineno-199-43" href="#__codelineno-199-43"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-199-44" name="__codelineno-199-44" href="#__codelineno-199-44"></a><span class="p">}</span>
</code></pre></div>
<p>在这个示例中，我们创建了一个指向 <code>GrandChild</code> 类对象的基类指针 <code>basePtr</code>。然后，我们使用 <code>dynamic_cast</code> 将 <code>basePtr</code> 转换为子类指针 <code>derivedPtr</code> 和孙子类指针 <code>grandChildPtr</code>。</p>
<p>由于 <code>basePtr</code> 实际上指向的是 <code>GrandChild</code> 类对象，所以将其转换为子类指针和孙子类指针都是有效的，并且转换成功。我们可以通过这两个指针调用相应的成员函数。</p>
<p>需要注意的是，将基类指针直接转换为子类指针或孙子类指针是不安全的，除非可以确定基类指针实际上指向的是相应的派生类对象。在进行这样的转换时，建议使用 <code>dynamic_cast</code> 进行类型检查，以确保转换的安全性。</p>
<h2 id="325">325、含有默认参数的函数声明与定义<a class="headerlink" href="#325" title="Permanent link">&para;</a></h2>
<p>在 C++ 中，默认参数只能在函数声明中指定，而不能在函数定义中重复指定默认参数。如果在函数定义中再次指定默认参数，会导致编译错误 <code>C2572: redefinition of default argument</code>。</p>
<p>在你的代码中，默认参数 <code>cameraMount = DEVICE_MOUNT_WALL</code> 已经在函数声明中指定，因此在函数定义中不需要再次指定默认参数。</p>
<p>你应该将函数定义中的默认参数去掉。以下是修改后的代码：</p>
<h2 id="330constunordered_map">330、const类型的unordered_map取值<a class="headerlink" href="#330constunordered_map" title="Permanent link">&para;</a></h2>
<p>在C++中，<code>std::unordered_map</code> 的 <code>operator[]</code> 具有两个版本：一个是用于非 <code>const</code> 的 <code>unordered_map</code>，另一个是用于 <code>const</code> 的 <code>unordered_map</code>。当你将 <code>controlTypeMapping</code> 声明为 <code>const</code> 时，只能使用 <code>at</code> 方法来获取元素，因为 <code>operator[]</code> 会尝试插入新元素，这对 <code>const</code> 的 <code>unordered_map</code> 是不允许的。</p>
<p>如果你将 <code>controlTypeMapping</code> 声明为非 <code>const</code>，那么可以使用 <code>operator[]</code> 来获取元素。</p>
<p><strong>（跟nlohmann::json就很像，好像是同一个意思）</strong></p>
<h2 id="335mapinsertmap">335、map容器insert另一个map时的问题<a class="headerlink" href="#335mapinsertmap" title="Permanent link">&para;</a></h2>
<ul>
<li>如果两个map型容器的key值相同，采用的会是合并，而不是补充</li>
<li>需要自己用代码进行处理，从而实现一个补充的效果</li>
</ul>
<h2 id="340goto-end">340、goto end的使用<a class="headerlink" href="#340goto-end" title="Permanent link">&para;</a></h2>
<ul>
<li>尽量不用goto</li>
<li>仅在需要统一进行错误处理的时候使用</li>
<li>一旦使用了goto，所有变量的初始化都必须在函数开头定义</li>
</ul>
<h2 id="345lambda">345、lambda函数捕获变量[&amp;]<a class="headerlink" href="#345lambda" title="Permanent link">&para;</a></h2>
<ol>
<li><strong><code>[&amp;]</code></strong>：捕获所有局部变量（包括 <code>this</code> 指针）并按引用传递给 lambda 函数。这样 lambda 函数可以访问并修改所有局部变量。</li>
<li><strong><code>[&amp;project]</code></strong>：捕获 <code>project</code> 变量并按引用传递给 lambda 函数。其他局部变量不会被捕获，因此 lambda 函数只能访问 <code>project</code>，不能访问或修改其他局部变量。</li>
</ol>
<h2 id="350">350、构造函数<a class="headerlink" href="#350" title="Permanent link">&para;</a></h2>
<p>结构体中定义了一个带参数的构造函数，而没有定义其他构造函数，那么编译器将不会为您自动生成默认构造函数或其他构造函数。换句话说，如果您定义了一个自定义的构造函数，则必须显式定义任何其他您希望存在的构造函数。</p>
<p>如果想要有一个默认构造需要显式定义，可以这么写：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-200-1" name="__codelineno-200-1" href="#__codelineno-200-1"></a>StructExample() = default;
</code></pre></div>
<h2 id="355cc">355、在C和C++编程中，将结构体作为函数参数传递时，使用指针而不是值传递有几个重要原因：<a class="headerlink" href="#355cc" title="Permanent link">&para;</a></h2>
<h3 id="1_5">1. <strong>性能考虑</strong><a class="headerlink" href="#1_5" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>避免拷贝开销</strong>：如果结构体很大，按值传递会导致整个结构体的拷贝，这会带来较大的性能开销。而传递指针只需要拷贝指针本身，这个开销非常小。</li>
<li><strong>内存使用</strong>：按值传递会在栈上创建结构体的副本，可能会导致栈溢出，特别是在递归调用或大结构体的情况下。使用指针可以避免这种情况。</li>
</ul>
<h3 id="2_4">2. <strong>修改原数据</strong><a class="headerlink" href="#2_4" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>直接修改原数据</strong>：通过指针传递结构体，可以直接修改原始结构体的数据。这在需要函数对结构体进行修改时非常重要。按值传递只会修改副本，对原始数据没有影响。</li>
</ul>
<h3 id="3_3">3. <strong>一致性和习惯</strong><a class="headerlink" href="#3_3" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>API一致性</strong>：在设计API时，传递指针是一种常见的做法，特别是在C语言中。这使得API设计更加一致，易于理解和使用。</li>
<li><strong>C语言习惯</strong>：在C语言中，传递指针是一种常见的习惯，特别是在处理复杂数据结构时。C++继承了很多C的习惯，因此这种方式在C++中也很常见。</li>
</ul>
<h2 id="340c">340、在C语言，默认参数不能是引用<a class="headerlink" href="#340c" title="Permanent link">&para;</a></h2>
<h2 id="345">345、函数入参可以传引用，这个强制调用者在外部创造一个拥有自己内存空间的对象<a class="headerlink" href="#345" title="Permanent link">&para;</a></h2>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 - 2024 smileatl
    </div>
  
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://github.com/smileatl" target="_blank" rel="noopener" title="GitHub" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
    <a href="mailto:<songlei.lin@qq.com>" target="_blank" rel="noopener" title="TEmail" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M64 112c-8.8 0-16 7.2-16 16v22.1l172.5 141.6c20.7 17 50.4 17 71.1 0L464 150.1V128c0-8.8-7.2-16-16-16zM48 212.2V384c0 8.8 7.2 16 16 16h384c8.8 0 16-7.2 16-16V212.2L322 328.8c-38.4 31.5-93.7 31.5-132 0zM0 128c0-35.3 28.7-64 64-64h384c35.3 0 64 28.7 64 64v256c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64z"/></svg>
    </a>
  
    
    
    
    
    <a href="https://space.bilibili.com/343556699?spm_id_from=333.999.0.0" target="_blank" rel="noopener" title="Bilibili" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M488.6 104.1c16.7 18.1 24.4 39.7 23.3 65.7v202.4c-.4 26.4-9.2 48.1-26.5 65.1-17.2 17-39.1 25.9-65.5 26.7H92.02c-26.45-.8-48.21-9.8-65.28-27.2C9.682 419.4.767 396.5 0 368.2V169.8c.767-26 9.682-47.6 26.74-65.7C43.81 87.75 65.57 78.77 92.02 78h29.38L96.05 52.19c-5.75-5.73-8.63-13-8.63-21.79 0-8.8 2.88-16.06 8.63-21.797C101.8 2.868 109.1 0 117.9 0q13.2 0 21.9 8.603L213.1 78h88l74.5-69.397C381.7 2.868 389.2 0 398 0q13.2 0 21.9 8.603c5.7 5.737 8.6 12.997 8.6 21.797 0 8.79-2.9 16.06-8.6 21.79L394.6 78h29.3c26.4.77 48 9.75 64.7 26.1m-38.8 69.7c-.4-9.6-3.7-17.4-10.7-23.5-5.2-6.1-14-9.4-22.7-9.8H96.05c-9.59.4-17.45 3.7-23.58 9.8-6.14 6.1-9.4 13.9-9.78 23.5v194.4c0 9.2 3.26 17 9.78 23.5s14.38 9.8 23.58 9.8H416.4c9.2 0 17-3.3 23.3-9.8s9.7-14.3 10.1-23.5zm-264.3 42.7c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2-6.2 6.3-14 9.5-23.6 9.5s-17.5-3.2-23.6-9.5-9.4-14-9.8-23.2v-33.3c.4-9.1 3.8-16.9 10.1-23.2s13.2-9.6 23.3-10c9.2.4 17 3.7 23.3 10m191.5 0c6.3 6.3 9.7 14.1 10.1 23.2V273c-.4 9.2-3.7 16.9-9.8 23.2s-14 9.5-23.6 9.5-17.4-3.2-23.6-9.5c-7-6.3-9.4-14-9.7-23.2v-33.3c.3-9.1 3.7-16.9 10-23.2s14.1-9.6 23.3-10c9.2.4 17 3.7 23.3 10"/></svg>
    </a>
  
    
    
    
    
    <a href="https://www.douban.com/people/172023060/" target="_blank" rel="noopener" title="Douban" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M.51 3.06h22.98V.755H.51zm20.976 2.537v9.608h-2.137l-1.669 5.76H24v2.28H0v-2.28h6.32l-1.67-5.76H2.515V5.597h18.972Zm-5.066 9.608H7.58l1.67 5.76h5.501zM18.367 7.9H5.634v5.025h12.733z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.action.edit", "content.action.view", "content.code.copy", "navigation.tabs", "navigation.top", "navigation.footer", "search.suggest", "search.highlight", "search.share"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
      
    
  </body>
</html>